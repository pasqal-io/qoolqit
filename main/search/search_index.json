{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>QoolQit is a Python library for algorithm development in the Rydberg Analog Model.</p>"},{"location":"#installation","title":"Installation","text":"<p>QoolQit can be installed from PyPi with <code>pip</code>/<code>pipx</code>/<code>uv</code> as follows</p> <p><pre><code>pip install qoolqit\n</code></pre> <pre><code>pipx install qoolqit\n</code></pre> <pre><code>uv pip install qoolqit\n</code></pre></p> <p>Install from source</p> <p>If you wish to install directly from the source, for example, if you are developing code for QoolQit, you can:</p> <p>1) Clone the QoolQit GitHub repository</p> <pre><code>git clone https://github.com/pasqal-io/qoolqit.git\n</code></pre> <p>2) Setup an environment for developing. We recommend using Hatch. From your <code>qoolqit</code> folder run</p> <pre><code>hatch shell\n</code></pre> <p>If you wish to use a different environment manager like <code>conda</code> or <code>venv</code>, activate your environment and run</p> <pre><code>pip install -e .\n</code></pre> <p>Using any pyproject-compatible Python manager</p> <p>For usage within a project with a corresponding <code>pyproject.toml</code> file, you can add</p> <pre><code>  \"qoolqit\"\n</code></pre> <p>to the list of <code>dependencies</code>.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to make participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right, and responsibility, to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned with this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Project maintainers may further define and clarify what constitutes project representation.</p>"},{"location":"CONTRIBUTING/","title":"How to Contribute","text":"<p>We're grateful for your interest in contributing to QoolQit! Please follow our guidelines to ensure a smooth contribution process.</p>"},{"location":"CONTRIBUTING/#reporting-an-issue-or-proposing-a-feature","title":"Reporting an Issue or Proposing a Feature","text":"<p>Your course of action will depend on your objective, but generally, you should start by creating an issue. If you've discovered a bug or have a feature you'd like to see added, feel free to create an issue on the issue tracker. Here are some steps to take:</p> <ol> <li>Quickly search the existing issues using relevant keywords to ensure your issue hasn't been addressed already.</li> <li> <p>If your issue is not listed, create a new one. Try to be as detailed and clear as possible in your description.</p> </li> <li> <p>If you're merely suggesting an improvement or reporting a bug, that's already excellent! We thank you for it. Your issue will be listed and, hopefully, addressed at some point.</p> </li> <li>However, if you're willing to be the one solving the issue, that would be even better! In such instances, you would proceed by preparing a Pull Request.</li> </ol>"},{"location":"CONTRIBUTING/#submitting-a-pull-request","title":"Submitting a Pull Request","text":"<p>We're excited that you're eager to contribute to QoolQit! To contribute, create a branch on the repository and once you are satisfied with your feature and all the tests pass create a Pull Request.</p> <p>Here's the process for making a contribution:</p> <p>Make a new branch via</p> <pre><code>git branch &lt;your initials&gt;/&lt;branch name&gt;\n</code></pre> <p>Next, checkout your new branch, and associate a branch to it on the GitHub server:</p> <pre><code>git checkout &lt;your initials&gt;/&lt;branch name&gt;\ngit push --set-upstream origin &lt;your initials&gt;/&lt;branch name&gt;\n</code></pre>"},{"location":"CONTRIBUTING/#setting-up-your-development-environment","title":"Setting up your development environment","text":"<p>1) Clone the QoolQit GitHub repository</p> <pre><code>git clone https://github.com/pasqal-io/qoolqit.git\n</code></pre> <p>2) Setup an environment for developing. We recommend using Hatch. With Hatch installed, you can enter the <code>qoolqit</code> repository and run</p> <pre><code>hatch shell\n</code></pre> <p>This will automatically take you into an environment with the necessary dependencies. Alternatively, if you wish to use a different environment manager like <code>conda</code> or <code>venv</code>, you can instead enter the <code>qoolqit</code> repository from within the environment and run</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"CONTRIBUTING/#useful-things-for-your-workflow-linting-and-testing","title":"Useful Things for your workflow: Linting and Testing","text":"<p>Use <code>pre-commit</code> hooks to make sure that the code is properly linted before pushing a new commit. Make sure that the unit tests and type checks are passing since the merge request will not be accepted if the automatic CI/CD pipeline do not pass.</p> <pre><code>pip install pre-commit\npre-commit install\npre-commit run --all-files\npytest\n</code></pre>"},{"location":"CONTRIBUTOR_AGREEMENT/","title":"Contributor Agreement","text":"<p>PASQAL CONTRIBUTION AGREEMENT (the \u201cAgreement\u201d)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <p>In the course of its activities, Pasqal carries out and leads quantic projects, in their software components. These projects aim to bring together a community of like-minded individuals to contribute to the development and improvement of Pasqal\u2019s products. Pasqal clearly outlines which projects are open to contributions (\u201cProjects\u201d).</p> <p>This Agreement documents the rights granted by Contributors to Pasqal and is legally binding.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-1-definitions","title":"Article 1: Definitions","text":"<p>You, Your or Contributor: means the intellectual property rights owner or legal entity authorized by the intellectual property rights owner that is entering into this Agreement with\u00a0Pasqal</p> <p>Contribution: means any work, protected or not, that is submitted by You to Pasqal in which You own or assert ownership of the intellectual property rights, subject to proprietary licensing terms, and not otherwise distributer through an open-source license.</p> <p>Material: means the work object of the Project, made available by Pasqal to third parties. When this Agreement covers more than one Project, the Material means the work to which the Contribution was Submitted. After You Submit the Contribution, it may be included in any type of Material.</p> <p>Submit: means any form of electronic, verbal, or written communication sent to Pasqal or its representatives, including but not limited to electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Pasqal for the purpose of discussing and improving the Material.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-2-entering-into-this-agreement","title":"Article 2: Entering into this Agreement","text":"<p>By Submitting any Contribution to Pasqal, You agree to enter into the Agreement with this entity, and be bound by the following terms.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-3-limitations-as-to-the-licensing-of-contributions","title":"Article 3: Limitations as to the licensing of Contributions","text":"<p>You guarantee that any Contribution You Submit to any Project is not licensed under any type of contaminating (even weakly contaminating) license, and that Pasqal will be free to combine your Contribution into any type of Material, for any Project, without any risk of contamination of said Material and/or Project.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-4-granting-of-a-copyright-andor-authors-rights-license","title":"Article 4: Granting of a Copyright and/or author\u2019s rights License","text":"<p>Subject to the terms and conditions of this Agreement, You hereby grant to Pasqal and to recipients of any Project distributed by Pasqal a worldwide, sublicensable, non-exclusive, royalty-free license to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute Your Contributions and your Contribution in combination with the Material for the entire duration of the rights under Applicable law.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-5-granting-of-a-patent-license","title":"Article 5: Granting of a patent license","text":"<p>Subject to the terms and conditions of this Agreement, You grant Pasqal a, worldwide, non-exclusive, transferable, royalty free patent license, with the right to sublicense these rights to third parties, to make, have made, use, sell, offer for sale, import and otherwise  transfer the Contribution and the Contribution in combination with the Material for the entire duration of the rights under Applicable law, if the Contribution implies the implementation of any such patent.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-6-licensing-of-the-material-and-contribution","title":"Article 6: Licensing of the Material and Contribution","text":"<p>Based on the rights granted in articles 2 and 3, if Pasqal includes Your Contribution in a Material, Pasqal may license Material including Your Contribution under any license, whether permissive, weakly contaminating, or contaminating. Pasqal will respect Your moral rights in relation to Your Contribution as provided under the Applicable law.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-7-warranties-and-disclaimer","title":"Article 7: Warranties and disclaimer","text":"<p>You represent that each of Your Contributions is Your creation, or that you have obtained the authorization from the intellectual property rights owner on the Contribution to Submit it over the course of a Project.</p> <p>By making a Contribution, You confirm that, to the best of Your knowledge, the Contribution does not violate the rights of any person or entity. If You make a Contribution on behalf of Your employer, then You confirm that an appropriate representative of that employer has authorized the inclusion of such Contribution to a Project and that it meets these requirements.</p> <p>You acknowledge that Pasqal is not obligated to use Your Contribution as part of the Material and may decide to only include Contributions Pasqal considers appropriate.</p>"},{"location":"CONTRIBUTOR_AGREEMENT/#article-8-applicable-law-and-jurisdiction","title":"Article 8: Applicable law and jurisdiction","text":"<p>The Agreement is governed by the laws of France. Any dispute relating to the interpretation or application of the License shall be subject to best efforts for an amicable settlement. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p>"},{"location":"LICENSE/","title":"License","text":"<p>PASQAL OPEN-SOURCE SOFTWARE LICENSE AGREEMENT (MIT-derived)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <ul> <li> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the \u201cLicensee\u201d) and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software is \u201cas is\u201d, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise arising from, out of or in connection with the Software or the use or other dealings in the Software.</p> </li> <li> <p>If use of the Software leads to the necessary use of any patent of the Licensor and/or any of its Affiliates (defined as a company owned or controlled by the Licensor), the Licensee is granted a royalty-free license, in any country where such patent is in force, to use the object of such patent; or use the process covered by such patent,</p> </li> <li> <p>Such a patent license is granted for internal research or academic use of the Licensee's, which includes use by employees and students of the Licensee, acting on behalf of the Licensee, for research purposes only.</p> </li> <li> <p>The License is governed by the laws of France. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p> </li> </ul>"},{"location":"contents/available_embedders/","title":"The embedding problem","text":"<p>Embedding data and problems into the Rydberg analog model is a broad research topic. Typically, an embedding is a structure preserving map \\(f_\\text{embedding}: X \\rightarrow Y\\), such that an object \\(X\\) is embedded into an object \\(Y\\). Our goal is to define optimal embedding functions such that problem-specific data and definitions are embedded into model-compatible objects with the Rydberg analog model.</p> <p>In QoolQit, all concrete embedders follow a basic interface set by the <code>BaseEmbedder</code> abstract base class:</p> <pre><code>from qoolqit import ConcreteEmbedder\n\n# Initialize the embedder\nembedder = ConcreteEmbedder()\n\n# Access information about the embedding algorithm\nembedder.info\n\n# Access the configuration of the embedding algorithm\nembedder.config\n\n# Change some value of the embedding configuration\nembedder.config.param = new_value\n\n# Define some initial data object\ndata = some_data_generator()\n\n# Embed the data with the embedder\nembedded_data = embedder.embed(data)\n</code></pre> <p>In this case, <code>ConcreteEmbedder</code> exemplifies an embedder that already has a mapping function and the respective configuration dataclass for that mapping function. Below, we will exemplify how to use some of the pre-defined concrete embedders directly available in QoolQit, and then show some considerations when defining custom embedders.</p>"},{"location":"contents/available_embedders/#unit-disk-graph-embedding","title":"Unit-disk graph embedding","text":"<p>Unit-disk graph embedding is the problem of finding a suitable function \\(f_\\text{UD}: V\\rightarrow\\mathbb{R}^2\\) that assigns coordinates to each node in the graph, such that the resulting unit-disk graph exactly matches the original graph (see the graphs page for the definition of a unit-disk graph). In general, not all graphs can be embedded into unit-disk graphs, and deciding if a graph can be embedded into a unit-disk graph is a NP-Hard problem.</p> <p>However, several heuristic algorithms can be developed to tackle the unit-disk graph embedding problem.</p>"},{"location":"contents/available_embedders/#spring-layout-embedding","title":"Spring-layout embedding","text":"<p>The spring-layout embedding utilizes the Fruchterman-Reingold force-directed algorithm. It assigns spring-like forces to the edges that keep nodes closer, while treating nodes themselves as repelling objects. The system is then simulated until the nodes find an equilibrium position, which represent the final coordinates assigned to the nodes.</p> <p>In QoolQit, the <code>SpringLayoutEmbedder</code> directly wraps the <code>nx.spring_layout</code> function, and it maps a <code>DataGraph</code> without coordinates to another <code>DataGraph</code> with coordinates.</p> <pre><code>from qoolqit import SpringLayoutEmbedder\n\nembedder = SpringLayoutEmbedder()\n</code></pre> <pre><code>SpringLayoutEmbedder:\n| Algorithm: spring_layout_embedding\n| Config: SpringLayoutConfig(k=None, iterations=50, threshold=0.0001, seed=None)\n</code></pre> <p>As you can see above it holds an algorithm and a config with a set of default parameters. For information on the algorithm and parameters, you can use the <code>embedder.info</code> property.</p> <pre><code>print(embedder.info)\n</code></pre> <pre><code>-- Embedding algorithm docstring:\n\nForce-directed embedding, wrapping nx.spring_layout.\n\nGenerates a graph with the same nodes and edges as the original graph, but with\nnode coordinates set to be the positions given by nx.spring_layout.\n\nCheck the documentation for nx.spring_layout for more information about each parameter:\nhttps://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html\n\nArguments:\n    graph: the graph to embed.\n    k: optimal distance between nodes.\n    iterations: maximum number of iterations to take.\n    threshold: threshold value for relative error in node position changes.\n    seed: random seed.\n</code></pre> <p>In this case, this embedder is a direct wrapper on top of <code>nx.spring_layout</code>, and any parameters are the ones directly used by that function. For more information, you can check the documentation for NetworkX. The parameters can be directly changed in the config.</p> <pre><code>embedder.config.iterations = 100\nembedder.config.seed = 1\n\nprint(embedder)\n</code></pre> <pre><code>SpringLayoutEmbedder:\n| Algorithm: spring_layout_embedding\n| Config: SpringLayoutConfig(k=None, iterations=100, threshold=0.0001, seed=1)\n</code></pre> <p>Finally, we can run the embedder with the <code>embed</code> method.</p> <pre><code>from qoolqit import DataGraph\n\ngraph_1 = DataGraph.random_er(n = 7, p = 0.3, seed = 3)\n\nembedded_graph_1 = embedder.embed(graph_1)\n\ngraph_1.draw()\nembedded_graph_1.draw()\n</code></pre> 2026-02-10T12:58:54.514516 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ 2026-02-10T12:58:54.557650 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>Now, we can check if the resulting graph is a unit-disk graph</p> <pre><code>embedded_graph_1.is_ud_graph()\n</code></pre> <pre><code>True\n</code></pre> <p>In this case the embedding was successful and we obtained a unit-disk graph. For more densely connected graphs, the spring layout algorithm tends to struggle with finding a unit-disk graph embedding, if it even exists.</p> <pre><code>graph_2 = DataGraph.random_er(n = 7, p = 0.8, seed = 3)\n\nembedded_graph_2 = embedder.embed(graph_2)\n\ngraph_2.draw()\nembedded_graph_2.draw()\n</code></pre> 2026-02-10T12:58:54.680609 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ 2026-02-10T12:58:54.721626 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p><pre><code>embedded_graph_2.is_ud_graph()\n</code></pre> <pre><code>False\n</code></pre>  While the algorithm converged and assigned positions to each node, the resulting embedded graph fails the unit-disk graph test.</p> <p>However, in both cases, we have embedded the original data into a graph with coordinates, which is an object that is compatible with the Rydberg analog model. As such, we can directly instantiate a register of qubits from these graphs.</p> <pre><code>from qoolqit import Register\n\nregister_1 = Register.from_graph(embedded_graph_1)\nregister_2 = Register.from_graph(embedded_graph_2)\n\nregister_1.draw()\nregister_2.draw()\n</code></pre> 2026-02-10T12:58:54.783509 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ 2026-02-10T12:58:55.217731 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/available_embedders/#matrix-embedding","title":"Matrix embedding","text":"<p>Matrix embedding is the problem of encoding a matrix into the Rydberg analog model. Several approaches can be taken, using different algorithms.</p>"},{"location":"contents/available_embedders/#interaction-embedding","title":"Interaction embedding","text":"<p>Interaction embedding means to encode a matrix in the interaction term of the Rydberg analog model. For a matrix \\(U\\), the goal is to find the set of coordinates that minimize</p> \\[ \\min_{\\{(x,\\, y)\\}}~\\sum_{ij}\\left\\|U_{ij}-\\frac{1}{r^6_{ij}}\\right\\|, \\] <p>where \\(r_{ij} = \\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2}\\) is the distance between qubits \\(i\\) and \\(j\\). This requires the matrix \\(U\\) to be positive and symmetric, and only the off-diagonal terms are embedded.</p> <p>In QoolQit, the <code>InteractionEmbedder</code> performs this minimization using <code>scipy.minimize</code>, and it maps a <code>np.ndarray</code> to a <code>DataGraph</code> with coordinates.</p> <pre><code>from qoolqit import InteractionEmbedder\n\nembedder = InteractionEmbedder()\n</code></pre> <pre><code>InteractionEmbedder:\n| Algorithm: interaction_embedding\n| Config: InteractionEmbeddingConfig(method='Nelder-Mead', maxiter=200000, tol=1e-08)\n</code></pre> <p>Checking the <code>info</code> on the embedder, we see a few parameters are available for customization through the <code>config</code>. There are parameters that get passed to <code>scipy.minimize</code>, and their description can be found in the SciPy documentation.</p> <pre><code>print(embedder.info)\n</code></pre> <pre><code>-- Embedding algorithm docstring:\n\nMatrix embedding into the interaction term of the Rydberg Analog Model.\n\nUses scipy.minimize to find the optimal set of node coordinates such that the\nmatrix of values 1/(r_ij)^6 approximate the off-diagonal terms of the input matrix.\n\nCheck the documentation for scipy.minimize for more information about each parameter:\nhttps://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\n\nArguments:\n    matrix: the matrix to embed.\n    method: the method used by scipy.minimize.\n    maxiter: maximum number of iterations.\n    tol: tolerance for termination.\n</code></pre> <p>We can try it out with the default configuration by generating a random symmetric positive matrix.</p> <pre><code>import numpy as np\n\nmatrix = np.random.rand(6, 6)\n\nmatrix = matrix + matrix.T\n</code></pre> <pre><code>[[1.80245405 1.49268002 0.91682217 0.17845209 0.79992362 1.13625065]\n [1.49268002 0.80421956 0.66361173 0.14427123 0.82859734 1.09668098]\n [0.91682217 0.66361173 1.73709635 0.86852109 0.85544737 0.53567149]\n [0.17845209 0.14427123 0.86852109 1.11928864 0.36631821 0.73628227]\n [0.79992362 0.82859734 0.85544737 0.36631821 0.82403592 1.14195363]\n [1.13625065 1.09668098 0.53567149 0.73628227 1.14195363 0.37302602]]\n</code></pre> <p>Finally, running the embedding we obtain a <code>DataGraph</code> with coordinates that can be easily converted to a <code>Register</code> of qubits.</p> <pre><code>import numpy as np\n\nembedded_graph = embedder.embed(matrix)\n\nregister = Register.from_graph(embedded_graph)\n\nembedded_graph.draw()\nregister.draw()\n</code></pre> 2026-02-10T12:58:55.642733 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ 2026-02-10T12:58:55.672006 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>To check how the embedding performed, we can inspect the interaction values in the <code>Register</code> and compare them to the off-diagonal elements in the matrix.</p> <pre><code>interactions = list(register.interactions().values())\n\ntriang_upper = np.triu(matrix, k = 1)\noff_diagonal = triang_upper[triang_upper != 0].tolist()\n\nprint([f\"{f:.4f}\" for f in sorted(interactions)])\nprint([f\"{f:.4f}\" for f in sorted(off_diagonal)])\n</code></pre> <pre><code>['0.0063', '0.0118', '0.0159', '0.0213', '0.0303', '0.0425', '0.1943', '0.6782', '0.7420', '0.8471', '0.9249', '1.0922', '1.1504', '1.1537', '1.4966']\n['0.1443', '0.1785', '0.3663', '0.5357', '0.6636', '0.7363', '0.7999', '0.8286', '0.8554', '0.8685', '0.9168', '1.0967', '1.1363', '1.1420', '1.4927']\n</code></pre>"},{"location":"contents/custom_embedders/","title":"Defining custom embedders","text":"<p>In the available embedders page you saw the usage of some pre-defined embedders. The embedding module in QoolQit is designed to be flexible and extendable to various forms of embedding algorithms developed for the Rydberg analog model, with potentially different inputs and outputs, and different configuration parameters. It is structured in three levels:</p> <p>Level 0: Concretizing the interface</p> <p>The <code>BaseEmbedder</code> is the abstract base class for all embedders, but it is defined on generic input and output data types. It enforces the interface for all embedders by defining the <code>info</code> and <code>config</code> properties, as well as the <code>embed</code> method. It also defines abstract <code>validate_input</code> and <code>validate_output</code> methods that must be overwritten by subclasses.</p> <p>Level 1: Concretizing the data inputs and data outputs</p> <p>The next level is to define the concrete data types involved in the mapping, thus defining a family of embedders. Currently, there are two families of embedders defined in QoolQit:</p> <ul> <li><code>GraphToGraphEmbedder</code> which concretizes the <code>BaseEmbedder</code> with a <code>DataGraph</code> input type and a <code>DataGraph</code> output type.</li> <li><code>MatrixToGraphEmbedder</code> which concretizes the <code>BaseEmbedder</code> with a <code>np.ndarray</code> input type and a <code>DataGraph</code> output type.</li> </ul> <p>In both cases, the <code>validate_input</code> and <code>validate_output</code> are overridden to check the input and output are of the correct type. In the case of the <code>MatrixToGraphEmbedder</code> conditions on the input matrix are also checked such as if the array has the right dimensions and is symmetric. Still, at this level, no specific embedding algorithm is defined.</p> <p>In the future, more families of embedders can be defined that may require different input and output data types.</p> <p>Level 2: Concretizing the algorithms and configurations</p> <p>The final level is defining concrete embedders, such as the ones we have used in the available embedders page. Here the requirement is to define a concrete function that maps the input to the output, along with any parameters required, and a config dataclass inheriting from <code>EmbeddingConfig</code> holding all the configuration parameters. In the previous examples, we used the <code>SpringLayoutEmbedder</code> which is a subclass of a <code>GraphToGraphEmbedder</code> and the <code>InteractionEmbedder</code> which is a subclass of the <code>MatrixToGraphEmbedder</code>.</p> <p>Let's exemplify the case of defining a custom embedder in the family of graph to graph embedders.</p> <pre><code>from qoolqit.embedding import GraphToGraphEmbedder\nfrom qoolqit.embedding import EmbeddingConfig\nfrom qoolqit import DataGraph\nfrom dataclasses import dataclass\n\ndef my_embedding_function(graph: DataGraph, param1: float) -&gt; DataGraph:\n    \"\"\"Some embedding function that manipulates the input graph.\n\n    This docstring should be clear on the embedding logic, because it will be\n    directly accessed by the embedder.info property.\n\n    Arguments:\n        param1: a useless parameter...\n    \"\"\"\n    return graph\n\n@dataclass\nclass MyEmbeddingConfig(EmbeddingConfig):\n    param1: float = 1.0\n\nembedder = GraphToGraphEmbedder(my_embedding_function, MyEmbeddingConfig())\n</code></pre> <pre><code>GraphToGraphEmbedder:\n| Algorithm: my_embedding_function\n| Config: MyEmbeddingConfig(param1=1.0)\n</code></pre> <p>It can now be used like any other embedder.</p> <pre><code>print(embedder.info)\n\nembedder.config.param1 = 2.0\n\ngraph = DataGraph.random_er(5, 0.5)\n\nembedded_graph = embedder.embed(graph)\n</code></pre> <pre><code>-- Embedding algorithm docstring:\n\nSome embedding function that manipulates the input graph.\n\nThis docstring should be clear on the embedding logic, because it will be\ndirectly accessed by the embedder.info property.\n\nArguments:\n    param1: a useless parameter...\n</code></pre> <p>To share this embedder or potentially add it to the QoolQit codebase, we might want to create a concrete embedder wrapper that users can easily import.</p> <pre><code>class MyNewEmbedder(GraphToGraphEmbedder):\n    def __init__(self):\n        super().__init__(my_embedding_function, MyEmbeddingConfig())\n</code></pre>"},{"location":"contents/custom_embedders/#automatic-validation","title":"Automatic validation","text":"<p>To define a custom embedder, the extra arguments in the embedding function (besides the data) must match the fields in the configuration dataclass, otherwise an error will be raised.</p> <pre><code>def my_embedding_function(graph: DataGraph, param1: float) -&gt; DataGraph:\n    return graph\n\n@dataclass\nclass MyWrongConfig(EmbeddingConfig):\n    some_other_param: float = 1.0\n\ntry:\n    wrong_embedder = GraphToGraphEmbedder(my_embedding_function, MyWrongConfig())\nexcept KeyError as error:\n    print(error)\n</code></pre> <pre><code>'Config MyWrongConfig is not compatible with the algorithm my_embedding_function, as not all configuration fields correspond to keyword arguments in the algorithm function.'\n</code></pre> <p>Furthermore, because we are defining an embedder in the <code>GraphToGraphEmbedder</code> the input must be an instance of a <code>DataGraph</code>:</p> <pre><code>embedder = GraphToGraphEmbedder(my_embedding_function, MyEmbeddingConfig())\n\ntry:\n    data = 1.0 # Not a DataGraph\n    embedded_data = embedder.embed(data)\nexcept TypeError as error:\n    print(error)\n</code></pre> <pre><code>Embedding data of type &lt;class 'float'&gt; not supported by this embedder. GraphToGraphEmbedder requires data of type DataGraph.\n</code></pre> <p>The output of the embedding function must also be a <code>DataGraph</code>:</p> <pre><code>def my_wrong_embedding_function(graph: DataGraph, param1: float) -&gt; DataGraph:\n    return param1 # Not a DataGraph\n\nembedder = GraphToGraphEmbedder(my_wrong_embedding_function, MyEmbeddingConfig())\n\ntry:\n    graph = DataGraph.random_er(5, 0.5)\n    embedded_graph = embedder.embed(graph)\nexcept TypeError as error:\n    print(error)\n</code></pre> <pre><code>Expected embedding result to be of type DataGraph, algorithm returned &lt;class 'float'&gt; instead.\n</code></pre>"},{"location":"contents/devices/","title":"Initializing quantum devices","text":"<p>Each <code>Device</code> in QoolQit wraps a Pulser device and defines the hardware characteristics that the program will be compiled to and later executed on.</p> <pre><code>from qoolqit import MockDevice, AnalogDevice, DigitalAnalogDevice\n\n# An example of an mock device with no hardware constrains\ndevice_ideal = MockDevice()\n\n# An example of a real device\ndevice_real = AnalogDevice()\n\n# An example of a real device with digital-analog capabilities.\ndevice_real_digital = DigitalAnalogDevice()\n</code></pre> <p>Besides available default devices, relevant for QPU emulation, new QPU devices can be: - imported remotely - created from custom Pulser devices</p>"},{"location":"contents/devices/#fetching-a-qoolqit-device-from-a-connection","title":"Fetching a QoolQit device from a connection","text":"<p>Depending on your provider you might have different QPUs available to launch your quantum program to. The list of available ones can be fetched through the specific connection handler object, with the generic <code>connection.fetch_available_devices()</code> method. For the Pasqal Cloud service, for example, creating a QoolQit device from a connection object, simply reads as:</p> <pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit import Device\n\nconnection = PasqalCloud()\nprint(connection.fetch_available_devices())\n\n# fetch QoolQit device\nfresnel_device = Device.from_connection(connection=connection, name=\"FRESNEL\")\n</code></pre> <pre><code>{'FRESNEL': FRESNEL}\nFRESNEL: \n \u2514\u2500\u2500 max_duration: 67.85840131753953\n \u2514\u2500\u2500 max_amplitude: 1.0\n \u2514\u2500\u2500 max_abs_detuning: 5.555555555555555\n \u2514\u2500\u2500 min_distance: 0.7673301077365813\n \u2514\u2500\u2500 max_radial_distance: 7.059436991176549\n</code></pre>"},{"location":"contents/devices/#create-a-qoolqit-device-from-a-pulser-device","title":"Create a QoolQit device from a Pulser device","text":"<p>A custom QoolQit device can be also built straight from any Pulser device, with any desired specification. Please, refer to Pulser documentation to learn how to make a custom device.</p> <pre><code>from dataclasses import replace\nfrom pulser import AnalogDevice\nfrom qoolqit import Device\n\n# Converting the pulser Device object in a VirtualDevice object\nVirtualAnalog = AnalogDevice.to_virtual()\n# Replacing desired values\nModdedAnalogDevice = replace(VirtualAnalog, max_radial_distance=100, max_sequence_duration=7000)\n\n# Wrap a Pulser device object into a QoolQit Device\nmod_analog_device = Device(pulser_device=ModdedAnalogDevice)\n</code></pre> <pre><code>AnalogDevice: \n \u2514\u2500\u2500 max_duration: 87.96459430051421\n \u2514\u2500\u2500 max_amplitude: 1.0\n \u2514\u2500\u2500 max_abs_detuning: 10.0\n \u2514\u2500\u2500 min_distance: 0.7809234915702248\n \u2514\u2500\u2500 max_radial_distance: 15.618469831404497\n</code></pre>"},{"location":"contents/devices/#unit-conversion","title":"Unit conversion","text":"<p>Each device has a default unit converter. These are the unit values used when converting an adimensional program in the Rydberg analog model to the physical units of Pulser devices for hardware execution.</p> <pre><code>device_real.converter\n</code></pre> <pre><code>UnitConverter(time = 79.577, energy = 12.566, distance = 6.403)\n</code></pre> <p>The converter handles the logic of converting the adimensional QoolQit model to Pulser units. For theoretical details on how this conversion works between the Rydberg analog model and the implementation that Pulser uses you can check the Rydberg analog model page.</p> <p>By default, each device creates a default converter where the energy unit is set as that device\u2019s maximum amplitude. If you make no changes to the device\u2019s converter, this means that amplitude values in the range \\( [0, 1] \\) will be converted to values in the range \\( [0, \\Omega_{\\max}] \\).</p>"},{"location":"contents/devices/#customizing-units","title":"Customizing units","text":"<p>For advanced users, customizing the unit conversion factors is possible.</p> <pre><code>device_real.set_time_unit(50.0)\n\ndevice_real.set_energy_unit(10.0)\n\ndevice_real.set_distance_unit(6.0)\n</code></pre> <pre><code>UnitConverter(time = 50.000, energy = 20.000, distance = 5.925)\nUnitConverter(time = 100.000, energy = 10.000, distance = 6.651)\nUnitConverter(time = 53.893, energy = 18.555, distance = 6.000)\n</code></pre>"},{"location":"contents/devices/#restoring-defaults","title":"Restoring defaults","text":"<p>You can always restore the default converter:</p> <pre><code>device_real.reset_converter()\n</code></pre> <pre><code>UnitConverter(time = 79.577, energy = 12.566, distance = 6.403)\n</code></pre> <p>Notes</p> <ul> <li>Advanced users may also pass a prebuilt <code>default_converter</code> to the constructor to start in a custom unit system:   <pre><code>from qoolqit import UnitConverter\ncustom_default = UnitConverter.from_energy(C6=device_from_pulser._C6, upper_amp=2.0)\ndevice_custom = Device(pulser_device=devices.AnalogDevice, default_converter=custom_default)\n</code></pre></li> </ul>"},{"location":"contents/drives/","title":"Writing the drive Hamiltonian","text":"<p>The <code>Drive</code> is a composition of waveforms defining the drive Hamiltonian.</p> <pre><code>from qoolqit import Constant, Ramp\nfrom qoolqit import Drive\n\n# Defining two waveforms\nwf0 = Constant(0.5, 1.0) &gt;&gt; Ramp(1.0, 0.0, 0.5)\nwf1 = Ramp(2.0, -1.0, 1.0) &gt;&gt; Constant(1.0, 1.0)\n\n# Defining the drive\ndrive = Drive(\n    amplitude = wf0,\n    detuning = wf1\n)\n\n# Expanding the drive through composition\ndrive = drive &gt;&gt; drive\n</code></pre> <pre><code>Amplitude: \n| 0.00 \u2264 t &lt; 0.50: Constant(t, 1.00)\n| 0.50 \u2264 t &lt; 1.50: Ramp(t, 0.00, 0.50)\n| 1.50 \u2264 t &lt; 3.00: Delay(t)\n| 3.00 \u2264 t &lt; 3.50: Constant(t, 1.00)\n| 3.50 \u2264 t &lt; 4.50: Ramp(t, 0.00, 0.50)\n| 4.50 \u2264 t \u2264 6.00: Delay(t)\n\nDetuning: \n| 0.00 \u2264 t &lt; 2.00: Ramp(t, -1.00, 1.00)\n| 2.00 \u2264 t &lt; 3.00: Constant(t, 1.00)\n| 3.00 \u2264 t &lt; 5.00: Ramp(t, -1.00, 1.00)\n| 5.00 \u2264 t \u2264 6.00: Constant(t, 1.00)\n</code></pre> <pre><code>drive.draw()\n</code></pre> 2026-02-10T12:58:56.800011 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/execution/","title":"Executing a quantum program","text":"<p>A <code>QuantumProgram</code> can be easily run on multiple backends provided by Pasqal: - locally installed emulators - remote cloud emulators - QPUs</p> <p>Remote emulators and QPU require credentials to submit a job. More information on how to access a QPU through your favorite cloud provider, is available at Pasqal's website. Later, we will briefly show how to authenticate and send a remote job.</p>"},{"location":"contents/execution/#a-simple-quantum-program","title":"A simple quantum program","text":"<p>Let us revisit the quantum program definition described before in the Quantum programs page.</p> <pre><code>from qoolqit import Drive, Ramp, Register, Constant\nfrom qoolqit import QuantumProgram\nfrom qoolqit import MockDevice\n\n# Create the register\nregister = Register.from_coordinates([(0,1), (0,-1), (2,0)])\n\n# Defining the drive parameters\nomega = 0.8\ndelta_i = -2.0 * omega\ndelta_f = -delta_i\nT = 25.0\n\n# Defining the drive\nwf_amp = Constant(T, omega)\nwf_det = Ramp(T, delta_i, delta_f)\ndrive = Drive(amplitude = wf_amp, detuning = wf_det)\n\n# Creating the program\nprogram = QuantumProgram(register, drive)\n\n# Compiling the Program\ndevice = MockDevice()\nprogram.compile_to(device)\n</code></pre>"},{"location":"contents/execution/#executing-locally","title":"Executing locally","text":"<p>Executing your program locally is as simple as importing the local emulator and just run your program on it <pre><code>from qoolqit.execution import LocalEmulator\n\nemulator = LocalEmulator()\nresults = emulator.run(program)\n</code></pre> </p> <p>The <code>LocalEmulator</code> allows to emulate the program run on different backends provided by Pasqal:</p> <ul> <li><code>QutipBackendV2</code>: Based on Qutip, runs programs with up to ~12 qubits and return qutip objects in the results (default).</li> <li><code>SVBackend</code>: PyTorch based state vectors and sparse matrices emulator. Runs programs with up to ~25 qubits and return torch objects in the results. Requires installing the <code>emu-sv</code> package.</li> <li><code>MPSBackend</code>: PyTorch based emulator using Matrix Product States (MPS). Runs programs with up to ~80 qubits and return torch objects in the results. Requires installing the <code>emu-mps</code> package.</li> </ul> <p>To use a particular backend it is sufficient to specify it through the <code>backend_type</code> argument:</p> <pre><code>from qoolqit.execution import LocalEmulator, BackendType\n\nemulator = LocalEmulator(backend_type=BackendType.QutipBackendV2)\n</code></pre> <p>More experienced users, might also want to configure an emulator. To fully exploit the potential of each emulator backend, they can be configured through the generic <code>EmulationConfig</code> object. For example, the following configuration,</p> <pre><code>from qoolqit.execution import EmulationConfig, Occupation\n\nobservables = (Occupation(evaluation_times=[0.1, 0.5, 1.0]),)\nemulation_config = EmulationConfig(\n    observables=observables,\n    with_modulation=True\n    )\n</code></pre> <p>simply asks the backend to compute some observable during runtime and to emulate the hardware more closely by considering finite-bandwidth hardware modulation of the drive.</p> <p>Finally, to run a program on a configured emulator (local or remote), we can simply pass the configuration as an additional argument to the emulator instance as:</p> <pre><code>from qoolqit.execution import EmulationConfig\n\nemulator = LocalEmulator(emulation_config=emulation_config)\n</code></pre> <p>Dedicated and specific configuration for each backend also exist: <code>QutipConfig</code>, <code>SVConfig</code>, <code>MPSConfig</code>. They should be used by pairing them with the corresponding backend type and imported from their respective packages, namely <code>pulser-simulation</code>, <code>emu-sv</code> and <code>emu-mps</code>. For more information about how the configuration options, please, refer to Pulser documentation.</p>"},{"location":"contents/execution/#handling-local-results","title":"Handling local results","text":"<p>The call <code>emulator.run(program)</code> will return a <code>Sequence[Results]</code> object type. This is where the results of the computation are stored. For more info about this specific object, please, have a look at Pulser documentation. As an example, lets inspect the results we got in the previous run: <pre><code># single result in the sequence\nresults[0].get_result_tags()\n</code></pre> <p>['bitstrings']</p>  Then the bitstrings can be extracted simply as: <pre><code># single result in the sequence\nfinal_bitstrings = results[0].final_bitstrings\n</code></pre> <p>Counter({'111': 85, '011': 8, '110': 6, '101': 1})</p> </p>"},{"location":"contents/execution/#executing-remotely","title":"Executing remotely","text":"<p>As anticipated, credentials to create a connection is required for most remote workflows. Here we will show how to create the specific handler of Pasqal Cloud services. Again, for more information about Pasqal Cloud and other providers, please refer to the Pasqal Cloud website.</p> <p>Let's first initialize a connection as:</p> <pre><code>from pulser_pasqal import PasqalCloud\n</code></pre> <pre><code>connection = PasqalCloud(\n    username=USERNAME,  # Your username or email address for the Pasqal Cloud Platform\n    password=PASSWORD,  # The password for your Pasqal Cloud Platform account\n    project_id=PROJECT_ID,  # The ID of the project associated to your account\n)\n</code></pre> <p>To use such connection, and to send jobs to the cloud, we first need to initialize a remote emulator:</p> <pre><code>from qoolqit.execution import RemoteEmulator\n\nemulator = RemoteEmulator(connection=connection)\n</code></pre> <p>As before, also <code>RemoteEmulator</code> can be instantiated with: - <code>backend_type</code>: remote counterpart of local backends, namely <code>EmuFreeBackendV2</code> (default), <code>EmuSVBackend</code> (not available yet), <code>EmuMPSBackend</code>. - <code>emulation_config</code>: same as before. - <code>runs</code>: same as before.</p> <p>As an example, below, we specify to emulate the program with the <code>EmuMPSBackend</code>:</p> <pre><code>from qoolqit.execution import RemoteEmulator, BackendType\n\nremote_emulator = RemoteEmulator(\n        backend_type=BackendType.EmuMPSBackend,\n        connection=connection,\n        emulation_config = emulation_config\n        runs=200\n)\nresults = remote_emulator.run(program)\n</code></pre>"},{"location":"contents/execution/#handling-remote-results","title":"Handling remote results","text":"<p>Remote emulators and QPU both have a <code>run()</code> method that will return a <code>Sequence[Results]</code> object type. However, if your program requires intensive resources to be run, or if QPU happens to be on maintenance, the use of this method is discouraged since it might leave your script hanging. In these situations prefer the use of the <code>submit(program) -&gt; RemoteResults</code> instead:</p> <pre><code>remote_emulator = RemoteEmulator(.., connection=connection, ...)\nremote_results = remote_emulator.submit(program)\n</code></pre> <p>Here, the remote results can act as a job handler: - Query the batch status: PENDING, RUNNING, DONE, etc.:     <pre><code>batch_status = remote_results.get_batch_status()\n</code></pre> - Query the batch id, to be saved for later retrieval of results:     <pre><code>batch_id = remote_results.get_batch_id()\n</code></pre> - Retrieve the remote results from <code>batch_id</code> and a <code>connection</code>:     <pre><code>from qoolqit.execution import RemoteResults\n\nremote_results = RemoteResults(batch_id, connection)\n</code></pre></p> <p>Once the batch has been completed (<code>batch_status</code> returns DONE), the complete results can be finally fetched as: <pre><code>results = remote_results.results\n</code></pre></p>"},{"location":"contents/execution/#executing-remotely-on-a-qpu","title":"Executing remotely on a QPU","text":"<p>A connection object can also be used to run the program directly on a QPU. To see the list of available devices, run:</p> <pre><code>connection = PasqalCloud()\nconnection.fetch_available_devices()\n</code></pre> <p>{'FRESNEL': FRESNEL}</p> <p>Finally, on a QPU there is no configuration and, as per the properties of the quantum hardware, results will come as a bitstrings counter of length specified by the <code>runs</code> parameter.</p> <pre><code>from qoolqit.execution import QPU\n\nqpu = QPU(connection=connection, runs=500)\n</code></pre>"},{"location":"contents/graphs/","title":"Standard structure for Graphs","text":"<p>Working with graphs is an essential part of computations with the Rydberg analog model. For that reason, QoolQit implements a specific <code>DataGraph</code> class to serve as the basis of all graph creation and manipulation, and setting the logic related to unit-disk graphs. QoolQit integrates with NetworkX for many operations, and the <code>DataGraph</code> inherits from <code>nx.Graph</code>.</p>"},{"location":"contents/graphs/#basic-construction","title":"Basic construction","text":"<p>The <code>DataGraph</code> is an undirected graph with no self loops. The default way to instantiate a <code>DataGraph</code> is with a set of edges.</p> <pre><code>from qoolqit import DataGraph\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngraph = DataGraph(edges)\n</code></pre> <p>Later in the graph constructors section we also describe how to construct graphs from sets of coordinates, or with built-in constructors.</p> <p>As with any NetworkX graph, the set of nodes and edges can be accessed:</p> <p><pre><code>print(graph.nodes)\n</code></pre> <pre><code>[0, 1, 2, 3]\n</code></pre> <pre><code>print(graph.edges)\n</code></pre> <pre><code>[(0, 1), (0, 3), (1, 2), (2, 3)]\n</code></pre> </p> <p>These are the standard <code>NodeView</code> and <code>EdgeView</code> objects from NetworkX, and thus can be used add and access node and edge attributes.</p>"},{"location":"contents/graphs/#drawing","title":"Drawing","text":"<p>We can draw the graph with <code>graph.draw()</code>, which calls <code>draw_networkx</code>. As such, optional arguments can be passed that will be fed to NetworkX. <pre><code>import networkx as nx\n\npos = nx.circular_layout(graph)\n\ngraph.draw(pos = pos)\n</code></pre> 2026-02-10T12:58:57.888941 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ </p>"},{"location":"contents/graphs/#coordinates-and-distances","title":"Coordinates and distances","text":"<p>One convenient property added by QoolQit is the <code>sorted_edges</code>, which guarantees that the indices in each edge tuple are always provided as \\((u, v):u&lt;v\\). This condition is not guaranteed by calling the NetworkX property <code>graph.edges</code>, but is sometimes useful.</p> <pre><code>print(graph.sorted_edges)\n</code></pre> <pre><code>{(0, 1), (1, 2), (0, 3), (2, 3)}\n</code></pre> <p>Another convenient property is accessing the pairs of all nodes in the graph, which again follow the convention of \\((u, v):u&lt;v\\). <pre><code>print(graph.all_node_pairs)\n</code></pre> <pre><code>{(0, 1), (1, 2), (0, 3), (2, 3), (0, 2), (1, 3)}\n</code></pre> </p> <p>In QoolQit a set of attributes that takes center stage when dealing with graphs are the node coordinates. These are essential for the Rydberg analog model as they directly translate to qubit positions that define the interaction term in the Hamiltonian. This behaviour has a close connection with the study of unit-disk graphs, where node coordinates are also essential. The coordinates can be set directly in the respective property:</p> <p><pre><code># The list must have the same length as the number of nodes:\ngraph.coords = [(-0.5, -0.5), (-0.5, 0.5), (0.5, 0.5), (0.5, -0.5)]\n\ngraph.coords\n</code></pre> <pre><code>{0: (-0.5, -0.5), 1: (-0.5, 0.5), 2: (0.5, 0.5), 3: (0.5, -0.5)}\n</code></pre>  Both a dictionary or a list can be passed, which will be converted to a dictionary. Because the graph now has a set of node coordinates, we can directly access the distance between the nodes. Optionally, a set of node pairs can be given and only those distances will be computed.</p> <pre><code># Compute for all node pairs\ngraph.distances()\n\n# Compute only for connected nodes\ngraph.distances(graph.sorted_edges)\n\n# Compute for a specific set of node pairs\ngraph.distances([(0, 1), (0, 2)])\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 1.0, (0, 3): 1.0, (2, 3): 1.0, (0, 2): 1.4142135623730951, (1, 3): 1.4142135623730951}\n{(0, 1): 1.0, (1, 2): 1.0, (0, 3): 1.0, (2, 3): 1.0}\n{(0, 1): 1.0, (0, 2): 1.4142135623730951}\n</code></pre> <p>Note</p> <p>Accessing distances as NumPy arrays or Torch tensors will be designed later.</p> <p>Furthermore, when calling <code>graph.draw()</code> the coordinate information will be automatically used.</p> <pre><code>graph.draw()\n</code></pre> 2026-02-10T12:58:58.008754 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>Graph coordinates can be rescaled. The <code>rescale_coords</code> method only accepts a keyword argument, which must be either <code>scaling</code> or <code>spacing</code>.</p> <pre><code># Rescale coordinates by a constant factor\ngraph.rescale_coords(scaling = 2.0)\n\n# Rescale coordinates by setting the minimum spacing\ngraph.rescale_coords(spacing = 1.0)\n</code></pre> <p>The minimum and maximum distance can be directly checked.</p> <pre><code># Compute for all node pairs\ngraph.min_distance()\ngraph.max_distance()\n\n# Compute only for connected nodes\ngraph.min_distance(connected = True)\n\n# Compute only for disconnected nodes\ngraph.min_distance(connected = False)\n</code></pre>"},{"location":"contents/graphs/#unit-disk-graphs","title":"Unit-disk graphs","text":"<p>Working with node coordinates and distances is an essential part of dealing with unit-disk graphs.</p> <p></p> <p>Definition: Unit-Disk Graphs</p> <p>For a set of nodes \\(V\\), each node \\(i\\in V\\) marked by a set of coordinates \\((x, y)_i\\) in Euclidean space, a set of edges \\(E\\) and a radius \\(R\\), a Unit-Disk Graph \\(UDG(V, E, R)\\) is such that there exists an edge \\((i, j)\\in E\\) for two nodes \\(i\\) and \\(j\\) if and only if \\(\\text{dist}(i, j) \\leq R\\), where \\(\\text{dist}(i, j)\\) is the Euclidean distance between the coordinates of nodes \\(i\\) and \\(j\\).</p> <p>In other words, a unit-disk graph for a radius \\(R\\) is the graph where the set of edges corresponds to the intersections of disks of radius \\(R/2\\) centered at each node position in Euclidean space.</p> <p>For a <code>DataGraph</code> with a set of node coordinates, we can check if it is a valid unit-disk graph</p> <pre><code>graph.is_ud_graph()\n</code></pre> <pre><code>True\n</code></pre> <p>This method checks that <code>graph.max_distance(connected = True)</code> is smaller than <code>graph.min_distance(connected = False)</code>. If this is <code>True</code>, then for every value of \\(R\\) inside that interval the unit-disk condition is met. We can easily check this.</p> <p>First, we can check the set of edges given by the intersection of unit disks:</p> <pre><code># For a small value no disks intersect, the set is empty\nud_edges = graph.ud_edges(radius = 0.1)\n\n# For a large enough value all disks intersect\nud_edges = graph.ud_edges(radius = 50.0)\n\nassert ud_edges == graph.all_node_pairs\n</code></pre> <pre><code>Radius = 0.1:  set()\nRadius = 50.0:  {(0, 1), (1, 2), (0, 3), (2, 3), (0, 2), (1, 3)}\n</code></pre> <p>Now, we can randomly pick a value or \\(R\\) matching the unit-disk condition and verify that the set of unit-disk edges exactly match the set of edges in the graph. The possible range of values is directly available with the <code>ud_radius_range()</code> method.</p> <pre><code>import numpy as np\n\nlow, high = graph.ud_radius_range()\n\nR = np.random.uniform(low, high)\n\nprint(graph.ud_edges(radius = R) == graph.sorted_edges)\n</code></pre> <pre><code>True\n</code></pre> <p>We can also reset the set of edges on a graph to be equal to the set of unit-disk edges for a given radius with <code>graph.set_ud_edges(radius = R)</code>. For this example we will not run this line, but we show it later when constructing a graph from a set of coordinates.</p>"},{"location":"contents/graphs/#node-and-edge-weights","title":"Node and edge weights","text":"<p>Another two important attributes are node weights and edge weights:</p> <pre><code>import random\n\ngraph.node_weights = {i: random.random() for i in graph.nodes}\ngraph.edge_weights = {edge: random.random() for edge in graph.sorted_edges}\n</code></pre> <p>If the graph does not have these attributes, the dictionaries will still be returned with <code>None</code> in place of the value. A set of boolean properties allows quickly checking if the graph has coordinates or weights. It only returns <code>True</code> if there is a value set for every node / edge in the graph.</p> <p>Note</p> <p>Accessing weights as NumPy arrays or Torch tensors will be designed later.</p> <pre><code>assert graph.has_coords\nassert graph.has_node_weights\nassert graph.has_edge_weights\n</code></pre> <p></p>"},{"location":"contents/graphs/#graph-constructors","title":"Graph constructors","text":"<p>Class constructors can help you create a variety of graphs. A useful constructor is starting from a set of coordinates. By default, it will create an empty set of edges, but we can use the <code>set_ud_edges</code> method to specify the edges as the unit-disk intersections.</p> <pre><code>from qoolqit import DataGraph\n\ncoords = [(-1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (0.0, -1.0)]\n\ngraph = DataGraph.from_coordinates(coords)\n\nassert len(graph.edges) == 0\n\ngraph.set_ud_edges(radius = 1.0)\n\nassert len(graph.edges) &gt; 0\n\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.136293 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>Some geometric graph constructors will already have coordinates by default.</p>"},{"location":"contents/graphs/#line","title":"Line","text":"<p>A line graph on n nodes.</p> <pre><code>graph = DataGraph.line(n = 10, spacing = 1.0)\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.240174 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/graphs/#circle","title":"Circle","text":"<p>A circle graph on n nodes.</p> <pre><code>graph = DataGraph.circle(n = 10, spacing = 1.0, center = (0.0, 0.0))\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.354146 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/graphs/#triangular","title":"Triangular","text":"<p>A triangular lattice graph with m rows and n columns of triangles.</p> <pre><code>graph = DataGraph.triangular(m = 2, n = 2, spacing = 1.0)\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.483074 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/graphs/#square","title":"Square","text":"<p>A square lattice graph with m rows and n columns of square.</p> <pre><code>graph = DataGraph.square(m = 2, n = 2, spacing = 1.0)\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.602756 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/graphs/#hexagonal","title":"Hexagonal","text":"<p>A Hexagonal lattice graph with m rows and n columns of hexagons.</p> <pre><code>graph = DataGraph.hexagonal(m = 2, n = 2, spacing = 1.0)\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.720163 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/graphs/#heavy-hexagonal","title":"Heavy-hexagonal","text":"<p>An Heavy-Hexagonal lattice graph with m rows and n columns of hexagons where each edge is decorated with an additional lattice site.</p> <pre><code>graph = DataGraph.heavy_hexagonal(m = 2, n = 2, spacing = 1.0)\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.847940 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/graphs/#random-unit-disk","title":"Random unit-disk","text":"<p>A random unit-disk graph by uniformly sampling points in area of side L.</p> <pre><code>graph = DataGraph.random_ud(n = 10, radius = 1.0, L = 2.0)\ngraph.draw()\n</code></pre> 2026-02-10T12:58:58.980734 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>Other generic constructors are also available which have no information on node coordinates.</p>"},{"location":"contents/graphs/#erdosrenyi","title":"Erd\u0151s\u2013R\u00e9nyi","text":"<p>A random Erd\u0151s\u2013R\u00e9nyi graph of n nodes.</p> <pre><code>graph = DataGraph.random_er(n = 10, p = 0.5, seed = 1)\ngraph.draw()\n</code></pre> 2026-02-10T12:58:59.041328 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/graphs/#loading-from-a-matrix","title":"Loading from a matrix","text":"<p>Loading an adjacency matrix into a graph is also possible.</p> <ul> <li>Given that graphs in QoolQit are undirected, the matrix must be symmetric.</li> <li>As in the standard adjacency matrix interpretation, off-diagonal elements are loaded as edge-weights as long as they are non-zero.</li> <li>Given that QoolQit does not consider graphs with self-loops, diagonal elements are loaded as node-weights.</li> </ul> <pre><code>import numpy as np\n\nn_nodes = 5\ndata = np.random.rand(n_nodes, n_nodes)\n\n# Matrix must be symmetric\ndata = data + data.T\n\ngraph = DataGraph.from_matrix(data)\n\nassert graph.has_node_weights\nassert graph.has_edge_weights\n</code></pre> <p>If all values in the diagonal are 0, then no node-weights will be set. Furthermore, edges and edge-weights will only be set for non-zero off-diagonal elements.</p> <pre><code># Setting the diagonal to zero\nnp.fill_diagonal(data, 0.0)\n\n# Removing the value for the pair (1, 2)\ndata[1, 2] = 0.0\ndata[2, 1] = 0.0\n\ngraph = DataGraph.from_matrix(data)\n\n# Checking there are no node weights and the edge (1, 2) was not added\nassert not graph.has_node_weights\nassert (1, 2) not in graph.edges\n</code></pre>"},{"location":"contents/programs/","title":"Creating a quantum program","text":"<p>A <code>QuantumProgram</code> combines a <code>Register</code> and a <code>Drive</code> and serves as the main interface for compilation and execution.</p> <pre><code>from qoolqit import PiecewiseLinear\nfrom qoolqit import Register, Drive, QuantumProgram\n\n# Defining the Drive\nwf0 = PiecewiseLinear([1.0, 2.0, 1.0], [0.0, 0.5, 0.5, 0.0])\nwf1 = PiecewiseLinear([1.0, 2.0, 1.0], [-1.0, -1.0, 1.0, 1.0])\ndrive = Drive(amplitude = wf0, detuning = wf1)\n\n# Defining the Register\ncoords = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]\nregister = Register.from_coordinates(coords)\n\n# Creating the Program\nprogram = QuantumProgram(register, drive)\n</code></pre> <pre><code>Quantum Program:\n| Register(n_qubits = 4)\n| Drive(duration = 4.000)\n| Compiled: False\n</code></pre> <p>At this point, the program has not been compiled to any device. As shown above, this is conveniently displayed when printing the program. It can also be checked through the <code>is_compiled</code> property.</p> <pre><code>program.is_compiled\n</code></pre> <pre><code>False\n</code></pre> <p>Now we instantiate a device and compile the program to that device. Compiling in QoolQit means to translate the adimensional values of time, energy, and distance used when defining the program in the Rydberg analog model to a specific set of values that implement the same set of instructions in a Pulser device, taking into account the Pulser units and the specific parameters of that device. More detailed information on this conversion is provided in the Rydberg analog model page.</p> <pre><code>from qoolqit import AnalogDevice\n\ndevice = AnalogDevice()\nprogram.compile_to(device)\n</code></pre> <pre><code>Quantum Program:\n| Register(n_qubits = 4)\n| Drive(duration = 4.000)\n| Compiled: True\n| Device: AnalogDevice\n</code></pre> <p>Now that the program has been compiled, we can inspect the compiled sequence, which is an instance of a Pulser <code>Sequence</code>.</p> <pre><code>pulser_sequence = program.compiled_sequence\n</code></pre> <p>Finally, we can draw both the original program and the compiled sequence.</p> <pre><code>program.draw()\n</code></pre> 2026-02-10T12:58:59.413003 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <pre><code>program.draw(compiled = True)\n</code></pre> 2026-02-10T12:58:59.537559 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/programs/#compiler-profiles","title":"Compiler profiles","text":"<p>In the example above the <code>AnalogDevice</code> was used, and no changes were made to the unit converter. As such, the default was used, which sets the reference energy unit as the maximum amplitude, as described in the Devices page.</p> <p>When a QoolQit program is compiled to Pulser, several compiler profiles can be used. You can check them in the following enumeration:</p> <pre><code>from qoolqit import CompilerProfile\n\nprint(CompilerProfile)\n</code></pre> <pre><code>&lt;Enum 'CompilerProfile':\n| DEFAULT = 'Default'\n| MAX_AMPLITUDE = 'MaxAmplitude'\n| MAX_DURATION = 'MaxDuration'\n| MIN_DISTANCE = 'MinDistance'&gt;\n</code></pre> <p>By default <code>CompilerProfile.DEFAULT</code> is used, which directly takes the unit converter present in the device and uses it when converting the values.</p> <p>Other compiler profiles will ignore the unit converter present in the device and utilize their own logic to determine the best possible conversion to achieve a desired compilation directive.</p> <p>The <code>CompilerProfile.MAX_AMPLITUDE</code> maps whatever is the maximum amplitude in the drive of your QoolQit program to the device's maximum allowed amplitude: <pre><code>program.compile_to(device, profile = CompilerProfile.MAX_AMPLITUDE)\nprogram.draw(compiled = True)\n</code></pre> 2026-02-10T12:58:59.736440 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ </p> <p>The <code>CompilerProfile.MAX_DURATION</code> maps whatever is the duration of your QoolQit program to the device's maximum allowed sequence duration: <pre><code>program.compile_to(device, profile = CompilerProfile.MAX_DURATION)\nprogram.draw(compiled = True)\n</code></pre> 2026-02-10T12:58:59.903254 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ </p> <p>The <code>CompilerProfile.MIN_DISTANCE</code> maps whatever is the minimum distance in the register of your QoolQit program to the device's minimum allowed atom separation: <pre><code>try:\n    program.compile_to(device, profile = CompilerProfile.MIN_DISTANCE)\nexcept Exception as error:\n    print(error)\n</code></pre> <pre><code>\n</code></pre> </p> <p>In this case, you can see the compilation failed because putting the atoms that close together for this program would require setting an amplitude that is larger than what the device allows.</p>"},{"location":"contents/registers/","title":"Creating qubit registers","text":"<p>A <code>Register</code> defines the qubit resources to be used by a quantum program.</p> <pre><code>from qoolqit import Register\n\nqubits = {\n    0: (-0.5, -0.5),\n    1: (-0.5, 0.5),\n    2: (0.5, -0.5),\n    3: (0.5, 0.5),\n}\n\nregister = Register(qubits)\n</code></pre> <pre><code>Register(n_qubits = 4)\n</code></pre> <p>It can be instantiated from a list of coordinates.</p> <pre><code>coords = [(-0.5, -0.5), (-0.5, 0.5), (0.5, -0.5), (0.5, 0.5)]\n\nregister = Register.from_coordinates(coords)\n\nregister.draw()\n</code></pre> 2026-02-10T12:59:00.064055 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>The distances between all qubits can be directly accessed.</p> <pre><code>register.distances()\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 1.4142135623730951, (0, 3): 1.4142135623730951, (2, 3): 1.0, (0, 2): 1.0, (1, 3): 1.0}\n</code></pre> <p>The minimum distance can be directly accessed.</p> <pre><code>register.min_distance()\n</code></pre> <pre><code>1.0\n</code></pre> <p>The interaction coefficients \\(1/r_{ij}^6\\) can be directly accessed.</p> <pre><code>register.interactions()\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 0.12499999999999994, (0, 3): 0.12499999999999994, (2, 3): 1.0, (0, 2): 1.0, (1, 3): 1.0}\n</code></pre>"},{"location":"contents/waveforms/","title":"Writing time-dependent functions","text":"<p>An essential part of writing programs in the Rydberg analog model is to write the time-dependent functions representing the amplitude and detuning terms in the drive Hamiltonian. For that, QoolQit implements a set of waveforms that can be used directly and/or composed together.</p>"},{"location":"contents/waveforms/#base-waveforms","title":"Base waveforms","text":"<p>A full list of the available waveforms can be found in the API reference.</p> <pre><code>from qoolqit import Constant, Ramp, Delay\n\n# An empty waveform\nwf1 = Delay(1.0)\n\n# A waveform with a constant value\nwf2 = Constant(1.0, 2.0)\n\n# A waveform that ramps linearly between two values\nwf3 = Ramp(1.0, -1.0, 1.0)\n</code></pre> <pre><code>0.00 \u2264 t \u2264 1.00: Delay(t)\n0.00 \u2264 t \u2264 1.00: Constant(t, 2.00)\n0.00 \u2264 t \u2264 1.00: Ramp(t, -1.00, 1.00)\n</code></pre> <p>As shown above, printing a waveform shows the duration interval over which it applies followed by the description of the waveform.</p> <p>The first argument is always the <code>duration</code> of the waveform, and the remaining arguments depend on the information required by each waveform. The resulting object is a callable that can be evaluated at any time \\(t\\).</p> <pre><code>wf1(t = 0.0)\nwf2(t = 0.5)\nwf3(t = 1.0)\n</code></pre> <pre><code>wf1(t = 0.0) = 0.0\nwf2(t = 0.5) = 2.0\nwf3(t = 1.0) = 1.0\n</code></pre> <p>Each waveform also supports evaluation at multiple time steps by calling it on an array of times. <pre><code>import numpy as np\n\nt_array = np.linspace(0.0, 2.0, 9)\n\nwf3(t_array)\n</code></pre> <pre><code>t =      [0.   0.25 0.5  0.75 1.   1.25 1.5  1.75 2.  ]\nwf(t) =  [-1.  -0.5  0.   0.5  1.   0.   0.   0.   0. ]\n</code></pre> </p> <p>In the waveform above, we defined it with a duration of \\(1.0\\), and then evaluated it over nine points from \\(t = 0.0\\) to \\(t=2.0\\). As you can see, all points after \\(t = 1.0\\) evaluated to \\(0.0\\). By default, any waveform evaluated at a time \\(t\\) that falls outside the specified <code>duration</code> gives \\(0.0\\).</p> <p>Waveforms can be quickly drawn with the <code>draw()</code> method.</p> <pre><code>wf3.draw()\n</code></pre> 2026-02-10T12:59:00.146111 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/waveforms/#interpolated-waveform","title":"Interpolated waveform","text":"<p>Special waveform to easily fit a set given values with a smooth function. For the full set of available options please refer to the API reference.</p> <pre><code>from qoolqit import Interpolated\n\nvalues = np.sin(np.linspace(0,2*np.pi, 10))\nwf_interpolated = Interpolated(100, values)\nwf_interpolated.draw()\n</code></pre> 2026-02-10T12:59:00.216207 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/waveforms/#composite-waveforms","title":"Composite waveforms","text":"<p>The most straightforward way to arbitrarily compose waveforms is to use the <code>&gt;&gt;</code> operator. This will create a <code>CompositeWaveform</code> representing the waveforms in the order provided.</p> <pre><code>wf_comp = wf1 &gt;&gt; wf2 &gt;&gt; wf3\n</code></pre> <pre><code>Composite waveform:\n| 0.00 \u2264 t &lt; 1.00: Delay(t)\n| 1.00 \u2264 t &lt; 2.00: Constant(t, 2.00)\n| 2.00 \u2264 t \u2264 3.00: Ramp(t, -1.00, 1.00)\n</code></pre> <p>The code above is equivalent to calling <code>CompositeWaveform(wf1, wf2, wf3)</code>. As shown, printing the composite waveform will automatically show the individual waveforms in the composition and the times at which they are active. These are automatically calculated from the individual waveforms. A <code>CompositeWaveform</code> is by itself a subclass of <code>Waveform</code>, and thus the previous logic on calling it at arbitrary time values also applies.</p> <p>A few convenient properties are directly available in a composite waveform:</p> <pre><code># Total duration\nwf_comp.duration\n\n# List of durations of the individual waveforms\nwf_comp.durations\n\n# List of times where each individual waveform starts / ends\nwf_comp.times\n</code></pre> <pre><code>Total duration : 3.0\nList of durations : [1.0, 1.0, 1.0]\nList of times : [0.0, 1.0, 2.0, 3.0]\n</code></pre> <p>A custom waveform can directly be a <code>CompositeWaveform</code>. That is the case with the <code>PiecewiseLinear</code> waveform, which takes a list of durations (of size \\(N\\)) and a list of values (of size \\(N+1\\)) and creates a linear interpolation between all values using individual waveforms of type <code>Ramp</code>.</p> <pre><code>from qoolqit import PiecewiseLinear\n\ndurations = [1.0, 1.0, 2.0]\nvalues = [0.0, 1.0, 0.5, 0.5]\n\nwf_pwl = PiecewiseLinear(durations, values)\n\nwf_pwl.draw()\n</code></pre> 2026-02-10T12:59:00.312311 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"contents/waveforms/#defining-custom-waveforms","title":"Defining custom waveforms","text":"<p>The waveform system of QoolQit can be easily extended by subclassing the <code>Waveform</code> class and defining some key properties and methods. To exemplify this we will create a waveform representing a simple shifted sine function,</p> \\[     \\text{Sin}(t)_{\\omega, C} \\equiv \\sin(\\omega t) + C \\] <pre><code>from qoolqit.waveforms import Waveform\n\nimport math\n\nclass Sin(Waveform):\n    \"\"\"A simple sine over a given duration.\n\n    Arguments:\n        duration: the total duration.\n        omega: the frequency of the sine wave.\n        shift: the vertical shift of the sine wave.\n    \"\"\"\n\n    def __init__(\n        self,\n        duration: float,\n        omega: float = 2.0 * math.pi,\n        shift: float = 0.0,\n    ) -&gt; None:\n        super().__init__(duration, omega = omega, shift = shift)\n\n    def function(self, t: float) -&gt; float:\n        return math.sin(self.omega * t) + self.shift\n</code></pre> <p>A few things are crucial in the snippet above:</p> <ul> <li>Keeping the <code>duration</code> argument as the first one in the <code>__init__</code>, and initializing the parent class with that value, to be consistent with other waveforms.</li> <li>Passing every other parameter needed for the waveform in the <code>__init__</code> and passing it as a keyword argument to the parent class. This will automatically create a <code>params</code> dictionary of extra parameters, and set them as attributes to be used later.</li> <li>Overriding the <code>function</code> abstract method, which represents the evaluation of the waveform at some time <code>t</code>.</li> <li>Optional: overriding the <code>max</code> and <code>min</code> methods. The intended result of <code>wf.max()</code> and <code>wf.min()</code> is to get the maximum/minimum value the waveform takes over its duration. By default, the base <code>Waveform</code> class implements a brute-force sampling method that approximates the maximum and minimum values. However, if this value is easy to know from the waveform parameters, the method should be overridden.</li> <li>Internally, before being executed by an emulator or a QPU, custom defined waveforms will be converted to an <code>Interpolated</code> waveform with a maximum of 100 points. If you need a finer time resolution, please, consider using directly an <code>Interpolated</code> waveform.</li> </ul> <p>To showcase the usage of the newly defined waveform, let's define a new sine waveform and compose it with a piecewise linear waveform.</p> <pre><code>from qoolqit import PiecewiseLinear\nimport math\n\nwf1 = Sin(\n    duration = 1.0,\n    omega = 2.0 * math.pi,\n    shift = 1.0\n)\n\nwf2 = PiecewiseLinear(\n    durations = [0.5, 0.5],\n    values = [1.0, 1.0, 0.0],\n)\n\nwf_comp = wf1 &gt;&gt; wf2\n</code></pre> <pre><code>Composite waveform:\n| 0.00 \u2264 t &lt; 1.00: Sin(t, 6.28, 1.00)\n| 1.00 \u2264 t &lt; 1.50: Ramp(t, 1.00, 1.00)\n| 1.50 \u2264 t \u2264 2.00: Ramp(t, 1.00, 0.00)\n</code></pre> <pre><code>wf_comp.draw()\n</code></pre> 2026-02-10T12:59:00.409301 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/ <p>Following this example, more complete <code>Sin</code> waveform is directly available in QoolQit implementing</p> \\[     \\text{Sin}(t)_{A, \\omega, \\phi, C} \\equiv A * \\sin(\\omega t + \\phi) + C \\] <pre><code>from qoolqit import Sin\n\nwf = Sin(\n    duration = 1.0,\n    amplitude = 2.0,\n    omega = 6.0,\n    phi = -5.0,\n    shift = 1.0,\n)\n\nwf.max()\n</code></pre> <pre><code>0.00 \u2264 t \u2264 1.00: Sin(t, 2.00, 6.00, -5.00, 1.00)\nMaximum value:  2.999999066583827\n</code></pre> <pre><code>wf.draw()\n</code></pre> 2026-02-10T12:59:00.476307 image/svg+xml Matplotlib v3.10.8, https://matplotlib.org/"},{"location":"theory/rydberg_model/","title":"Quantum computing with Rydberg atoms","text":"<p>This page centralizes the theoretical framework of QoolQit. To start writing programs, go straight to the contents section, or check out the tutorials section.</p> <p>Manipulating Rydberg atomic systems for quantum computing is a complex topic, and in this page we will not cover all aspects of it. The aim of this page is to introduce the underlying computational model when writing analog algorithms with Rydberg atoms, and to abstract away as much as possible the hardware details on how these algorithms are implemented. For a more detailed description on the physics and hardware implementation of quantum computing with Rydberg atoms, check out the Pulser library.</p>"},{"location":"theory/rydberg_model/#the-rydberg-analog-model","title":"The Rydberg Analog Model","text":"<p>The Rydberg Analog Model is a computational model following the Ising-mode operation of Rydberg atoms. Similarly to the circuit-model, it adopts the qubit as the basic unit of information. Two characteristics of the Rydberg analog model make it inherently different from the circuit-model:</p> <ul> <li> <p>It is a continuous-time model, meaning all operations are defined as time-evolving processes that continuously alter the state of the qubits.</p> </li> <li> <p>The spatial arrangement of the qubits has a direct influence on the operations due to the always-on physical interaction of the atoms.</p> </li> </ul>"},{"location":"theory/rydberg_model/#register","title":"Register","text":"<p>The register defines the qubit resources available to perform the computation.</p> <p>Definition: Register</p> <p>A register \\(R\\) is a set of qubits, each identified by an index \\(q_i\\) and a position \\(p_i = (x_i, y_i)\\), \\(R=\\{(q_i, p_i)\\}\\), with size \\(|R|=N\\). A register is assumed to have an initial state \\(|\\psi_R(t=0)\\rangle = |0\\rangle^{\\otimes N}\\)</p>"},{"location":"theory/rydberg_model/#interaction","title":"Interaction","text":"<p>Once a register is initialized, the physics of Rydberg atoms dictate that the state of the qubits evolves with an always-on interaction Hamiltonian. This background interaction is constant in time, and present during the whole program.</p> <p>Definition: Interaction Hamiltonian</p> <p>The interaction Hamiltonian is defined as</p> \\[H^\\text{int}=\\sum_{i=0}^{N-1}\\sum_{j=0}^{i-1}\\frac{1}{r^6_{ij}}\\hat{n}_i\\hat{n}_j,\\] <p>where \\(r_{ij}=\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\\) is the distance between qubits \\(q_i\\) and \\(q_j\\), and \\(\\hat{n}=\\frac12(1-\\hat{\\sigma}^z)\\) is the number operator.</p>"},{"location":"theory/rydberg_model/#drive","title":"Drive","text":"<p>A program in the Rydberg analog model is defined as a time-dependent drive Hamiltonian that is imposed on the qubits (in addition to the interaction Hamiltonian).</p> <p>Definition: Drive Hamiltonian</p> <p>The drive Hamiltonian is defined as</p> \\[ H^\\text{d}(t)=\\sum_{i=0}^{N-1}\\frac{\\Omega_i(t)}{2}\\left(\\cos\\phi_i(t)\\hat{\\sigma}^x_i-\\sin\\phi_i(t)\\hat{\\sigma}^y_i\\right)-\\delta_i(t)\\hat{n}_i \\] <p>where \\(\\Omega_i(t)\\), \\(\\delta_i(t)\\) and \\(\\phi_i(t)\\) are time-dependent functions, or waveforms, that encode the program corresponding, respectively, to the amplitude, detuning and phase of the drive on each qubit.</p> <p>The drive \\(D_i(t)\\) is the set of functions \\(D_i(t) = \\{\\Omega_i(t), \\delta_i(t), \\phi_i(t)\\}\\) defined for \\(t\\geq0\\) that define the time-dependent Hamiltonian \\(H^\\text{d}_i(t)\\) driving qubit \\(q_i\\).</p> <p>The drive is global if it is the same for all qubits in the register, \\(D_i(t)=D(t)~\\forall~q_i\\in R\\).</p>"},{"location":"theory/rydberg_model/#weighted-detuning","title":"Weighted detuning","text":"<p>In the Rydberg analog model drives are global. However, an extra local detuning term can be added when a weight map is passed \\(\\{q_i: \\epsilon_i\\}\\), where \\(\\epsilon_i\\in[0, 1]\\) is the weight for each qubit \\(q_i\\). Then, the detuning term changes to</p> \\[ H^\\text{d}(t)=\\sum_{i=0}^{N-1}\\frac{\\Omega(t)}{2}\\left(\\cos\\phi(t)\\hat{\\sigma}^x_i-\\sin\\phi(t)\\hat{\\sigma}^y_i\\right)-\\delta_\\text{max}(\\delta(t)+\\epsilon_i\\Delta(t))\\hat{n}_i \\] <p>with the condition that the waveform \\(\\Delta(t)\\) must be negative.</p>"},{"location":"theory/rydberg_model/#the-full-model","title":"The full model","text":"<p>Definition: Rydberg Analog Model</p> <p>A register of qubits \\(R\\) is initialized, where each qubit \\(q_i\\) has a position \\(p_i = (x_i, y_i)\\).</p> <p>The local detuning weights are programmed, \\(\\{q_i: \\epsilon_i\\}\\).</p> <p>The drive waveforms are programmed, \\(D(t) = \\{\\Omega(t), \\delta(t), \\Delta(t), \\phi(t)\\}\\).</p> <p>The system evolves with the Hamiltonian:</p> \\[ H(t)=\\sum_{i=0}^{N-1}\\frac{\\Omega(t)}{2}\\left(\\cos\\phi(t)\\hat{\\sigma}^x_i-\\sin\\phi(t)\\hat{\\sigma}^y_i\\right)-(\\delta(t)+\\epsilon_i\\Delta(t))\\hat{n}_i + \\sum_{i=0}^{N-1}\\sum_{j=0}^{i-1}\\frac{1}{r^6_{ij}}\\hat{n}_i\\hat{n}_j \\] <p>The system is measured in the computational basis at some time \\(t^* &gt; 0\\).</p>"},{"location":"theory/rydberg_model/#model-units","title":"Model units","text":"<p>The Rydberg Analog Model as implemented in QoolQit is adimensional, which is not the case in Pulser. Below we go over some details on how this works.</p>"},{"location":"theory/rydberg_model/#pulser-units","title":"Pulser units","text":"<p>Pulser sets \\(\\hbar=1\\) and then uses the following units:</p> \\[\\text{Time:}~[\\text{ns}],\\qquad\\text{Energy:}~[\\text{rad}.\\mu\\text{s}^{-1}],\\qquad\\text{Distance:}~[\\mu\\text{m}]\\] <p>Furthermore, Pulser writes the interaction term using a physical coefficient related to the energy level where the qubit is encoded:</p> \\[H^\\text{int}_\\text{Pulser}=\\sum_{i=0}^{N-1}\\sum_{j=0}^{i-1}\\frac{C_6}{r^6_{ij}}\\hat{n}_i\\hat{n}_j.\\] <p>The interaction coefficient \\(C_6\\) has units of \\([\\text{rad}.\\mu\\text{s}^{-1}.\\mu\\text{m}^{6}].\\)</p> <p>This seemingly small difference has an important implication: a Pulser sequence is fundamentally device-specific. Pulser has a safety-first design, and does extensive validation when each sequence is created to guarantee it is compatible with the device it is created for, which is very important.</p>"},{"location":"theory/rydberg_model/#unit-conversion","title":"Unit conversion","text":"<p>QoolQit handles the unit conversion automatically through a compilation layer, and also includes a number of features for more advanced users to customize it. This is done by defining a set of conversion factors for time, energy and distance, \\(\\{\\Delta_T\\), \\(\\Delta_E\\), \\(\\Delta_D\\}\\), such that:</p> \\[\\text{Time[P]}=\\Delta_T \\times \\text{Time[Q]},\\quad\\text{Energy[P]}=\\Delta_E \\times \\text{Energy[Q]},\\quad\\text{Distance[P]}=\\Delta_D \\times \\text{Distance[Q]},\\] <p>where \\(\\text{P}\\) and \\(\\text{Q}\\) refer to the Pulser and QoolQit units, respectively. Defining a valid set of conversion factors between QoolQit and Pulser can be done arbitrarily, as long as both the time-energy invariant and the energy-distance invariant are respected:</p> \\[\\Delta_T\\,\\times\\,\\Delta_E = 1000,\\qquad \\Delta_D^6\\,\\times\\,\\Delta_E = C_6.\\] <p>This means that it is possible to pick an arbitrary value for one of the conversion factors, and the two remaining ones can be automatically calculated from the invariants. As seen from the dependence of the invariants on the interaction coefficient \\(C_6\\), these are calculated specifically for each device, and this is what guarantees that QoolQit programs can be device agnostic.</p> <p>For details on how to customize the unit conversion in QoolQit check the contents pages on devices and quantum programs. For further examples on understanding the unit conversion check the unit conversion tutorial.</p>"},{"location":"theory/rydberg_model/#advantages-disadvantages","title":"Advantages &amp; disadvantages","text":"<p>Working with an adimensional model has a few advantages:</p> <ul> <li>Programs are more abstract and device agnostic, and the rules to compile to different devices are clearly defined.</li> <li>Algorithm descriptions are more unified and consistent, focusing more on the logic of the algorithm and less on the implementation details.</li> <li>Increases code portability between experimental setups, different hardware configurations, and even different hardware calibrations.</li> <li>Program descriptions are more future-proof, as the same description today can be valid for future hardware generations.</li> </ul> <p>However, while the above conversion is exact in theory, in practice real device execution will have sources of errors and discrepancies that are not accounted for in a simple unit conversion. Abstracting away the finer control over such errors can be seen as a disadvantage, but it is also an opportunity for improvement. The advanced user who understands such discrepancies can work on developing more robust protocols for compilation and noise mitigation and integrating them in the stack.</p>"},{"location":"tutorials/basic_qubo/","title":"Solving a basic QUBO problem","text":"In\u00a0[66]: Copied! <pre>import numpy as np\n\nQ = np.array([\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n])\n</pre> import numpy as np  Q = np.array([         [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],         [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],         [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],         [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],         [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0], ]) <p>QUBO problems are scale-invariant, and so we can work with the normalized matrix $\\tilde{Q}=Q/\\text{max}(Q)$ instead.</p> <p>Before showing how to solve this QUBO instance in the Rydberg analog model, we can compute the optimal solutions classically to compare. For that we do a brute force cost calculation over all possible bitstrings, which scales exponentially with the number of variables. This is only possible because we are dealing with a small QUBO.</p> In\u00a0[67]: Copied! <pre># Normalize QUBO matrix\nQ = Q/Q.max()\n\n# Classical solution\nbitstrings = np.array([np.binary_repr(i, len(Q)) for i in range(2 ** len(Q))])\nbitstring_lists = np.array([np.array(list(b), dtype=int) for b in bitstrings])\ncosts = np.array([z.T @ Q @ z for z in bitstring_lists])\nidx_sort = np.argsort(costs).tolist()\n\nsorted_costs = costs[idx_sort]\nsorted_bitstrings = bitstrings[idx_sort]\n\nprint(\"Two best solutions: \", sorted_bitstrings[:2])\nprint(\"Respective costs: \", sorted_costs[:2])\n\n# We save the two best solutions for plotting\nmarked_bitstrings = sorted_bitstrings[:2]\n</pre> # Normalize QUBO matrix Q = Q/Q.max()  # Classical solution bitstrings = np.array([np.binary_repr(i, len(Q)) for i in range(2 ** len(Q))]) bitstring_lists = np.array([np.array(list(b), dtype=int) for b in bitstrings]) costs = np.array([z.T @ Q @ z for z in bitstring_lists]) idx_sort = np.argsort(costs).tolist()  sorted_costs = costs[idx_sort] sorted_bitstrings = bitstrings[idx_sort]  print(\"Two best solutions: \", sorted_bitstrings[:2]) print(\"Respective costs: \", sorted_costs[:2])  # We save the two best solutions for plotting marked_bitstrings = sorted_bitstrings[:2] <pre>Two best solutions:  ['01011' '00111']\nRespective costs:  [-1.31978679 -1.31978679]\n</pre> In\u00a0[68]: Copied! <pre>from qoolqit import InteractionEmbedder\n\nembedder = InteractionEmbedder()\nembedded_graph = embedder.embed(Q)\nembedded_graph.draw()\n</pre> from qoolqit import InteractionEmbedder  embedder = InteractionEmbedder() embedded_graph = embedder.embed(Q) embedded_graph.draw() In\u00a0[69]: Copied! <pre>from qoolqit import Drive, PiecewiseLinear, QuantumProgram, Ramp, Register\n\n# Create the register\nregister = Register.from_graph(embedded_graph)\n\n# Defining the annealing parameters\nomega = np.median(Q[Q &gt; 0].flatten())\ndelta_i = -2.0 * omega\ndelta_f = 2.0 * omega\nT = 52.0\n\n# Defining the annealing schedule\nwf_amp = PiecewiseLinear([T/4, T/2, T/4], [0.0, omega, omega, 0.0])\nwf_det = Ramp(T, delta_i, delta_f)\ndrive = Drive(amplitude = wf_amp, detuning = wf_det)\n\n# Writing the quantum program\nprogram = QuantumProgram(register, drive)\nprogram.draw()\n</pre> from qoolqit import Drive, PiecewiseLinear, QuantumProgram, Ramp, Register  # Create the register register = Register.from_graph(embedded_graph)  # Defining the annealing parameters omega = np.median(Q[Q &gt; 0].flatten()) delta_i = -2.0 * omega delta_f = 2.0 * omega T = 52.0  # Defining the annealing schedule wf_amp = PiecewiseLinear([T/4, T/2, T/4], [0.0, omega, omega, 0.0]) wf_det = Ramp(T, delta_i, delta_f) drive = Drive(amplitude = wf_amp, detuning = wf_det)  # Writing the quantum program program = QuantumProgram(register, drive) program.draw() In\u00a0[70]: Copied! <pre>from qoolqit import AnalogDevice\n\nprogram.compile_to(device = AnalogDevice())\n</pre> from qoolqit import AnalogDevice  program.compile_to(device = AnalogDevice()) <p>The program can now be executed.</p> In\u00a0[71]: Copied! <pre>from qoolqit.execution import LocalEmulator\n\nemulator = LocalEmulator(runs=500)\n\nresults = emulator.run(program)\n\ncounter = results[0].final_bitstrings\nprint(counter)\n</pre> from qoolqit.execution import LocalEmulator  emulator = LocalEmulator(runs=500)  results = emulator.run(program)  counter = results[0].final_bitstrings print(counter) <pre>Counter({np.str_('01011'): 223, np.str_('00111'): 191, np.str_('00011'): 35, np.str_('10000'): 15, np.str_('10001'): 10, np.str_('00101'): 8, np.str_('00010'): 6, np.str_('10010'): 5, np.str_('01010'): 5, np.str_('00001'): 2})\n</pre> <p>And finally we plot a histogram of the sampled bitstrings.</p> In\u00a0[72]: Copied! <pre>import matplotlib.pyplot as plt\n\n\ndef plot_distribution(counter, solutions, bins=10):\n    counter = dict(counter.most_common(bins))\n    color = [\"tab:green\" if key in solutions.tolist() else \"tab:blue\" for key in counter]\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"Bitstrings\")\n    ax.set_ylabel(\"Counts\")\n    ax.bar(range(len(counter)), counter.values(), color=color, tick_label=counter.keys())\n    return fig\n\nfig = plot_distribution(counter, marked_bitstrings)\n</pre> import matplotlib.pyplot as plt   def plot_distribution(counter, solutions, bins=10):     counter = dict(counter.most_common(bins))     color = [\"tab:green\" if key in solutions.tolist() else \"tab:blue\" for key in counter]     fig, ax = plt.subplots()     ax.set_xlabel(\"Bitstrings\")     ax.set_ylabel(\"Counts\")     ax.bar(range(len(counter)), counter.values(), color=color, tick_label=counter.keys())     return fig  fig = plot_distribution(counter, marked_bitstrings) <p>As we can see, the bitstrings we had marked as the optimal solutions of this QUBO problem were the ones sampled with the highest probability, meaning the the QUBO problem was successfully solved with the quantum program we defined.</p>"},{"location":"tutorials/basic_qubo/#solving-a-basic-qubo-problem","title":"Solving a basic QUBO problem\u00b6","text":"<p>A QUBO instance on $N$ variables consists in a symmetric matrix $Q$ of size $N\\times N$, and solving a QUBO problems means to find the bitstring $z=(z_1,...,z_N)\\in\\{0, 1\\}^N$ that minimizes the quantity</p> <p>$$ f(z) = z^TQz $$</p>"},{"location":"tutorials/basic_qubo/#problem-generation","title":"Problem generation\u00b6","text":"<p>Many real-world problems can be mapped to a QUBO problem, which means to create the matrix $Q$ that encodes the problem to solve. For the purpose of this tutorial we assume this task has already been performed and we are given the matrix $Q$, such as the one below:</p>"},{"location":"tutorials/basic_qubo/#problem-embedding","title":"Problem embedding\u00b6","text":"<p>To embed the QUBO problem in the Rydberg analog model, we can directly use a matrix embedding technique like the <code>InteractionEmbedder</code>. You can read more about it in the available embedders contents page.</p> <p>The <code>InteractionEmbedder</code> maps a matrix to a graph with node coordinates, from which we can directly instantiate a qubit register later.</p>"},{"location":"tutorials/basic_qubo/#writing-a-quantum-program","title":"Writing a quantum program\u00b6","text":"<p>To solve this QUBO instance, we are going to use an annealing schedule where we raise the amplitude to some value $\\Omega$ while sweeping the detuning from $\\delta_i$ to $\\delta_f$. We pick the $\\Omega$ as the median of the values of $Q$, and define $\\delta_i$ and $\\delta_f$ as $\\pm 2 \\Omega$. A long enough duration should allow the annealing schedule to be successful.</p>"},{"location":"tutorials/basic_qubo/#execution-and-visualization","title":"Execution and visualization\u00b6","text":"<p>We pick the <code>AnalogDevice</code>, compile the program, and run it for a set number of samples.</p>"},{"location":"tutorials/custom_quantum_program/","title":"Execute Custom Quantum Program: Tutorial","text":"<p>A QuantumProgram combines a Register and a Drive and serves as the main interface for compilation and execution.</p> <p>Here we will define a register via the DataGraph class of qoolqit and a custom waveform sublassing the Waveform class.</p> In\u00a0[32]: Copied! <pre>from qoolqit import DataGraph, Register\n\n#Define a register from a DataGraph\ngraph=DataGraph.hexagonal(1, 1)\nreg=Register.from_graph(graph)\n\n#Define a register from positions\nreg=Register.from_coordinates(list(graph.coords.values()))\n</pre> from qoolqit import DataGraph, Register  #Define a register from a DataGraph graph=DataGraph.hexagonal(1, 1) reg=Register.from_graph(graph)  #Define a register from positions reg=Register.from_coordinates(list(graph.coords.values())) <p>Remember it is possible to use prefedined embedders from graphs or define custom ones. Refer to the  documentation  for this.</p> <p>Let us define a profile following the function $f(t) = \\Omega_{\\mathrm{max}} \\cdot \\sin^2( \\frac{\u03c0}{2} \\cdot \\sin(\u03c0 t) )$.</p> In\u00a0[33]: Copied! <pre>import math\n\nfrom qoolqit.waveforms import Waveform\n\n\nclass SmoothPulse(Waveform):\n    \"\"\"f(t) = omega_max * sin( (\u03c0/2) * sin(\u03c0 t) )^2, for 0 \u2264 t \u2264 duration\"\"\"\n\n    def __init__(self, duration: float , omega_max: float) -&gt; None:\n        super().__init__(duration, omega_max=omega_max)\n\n    def function(self, t: float) -&gt; float:\n        return self.omega_max * math.sin(0.5 * math.pi * math.sin(math.pi * t/self.duration)) ** 2\n</pre> import math  from qoolqit.waveforms import Waveform   class SmoothPulse(Waveform):     \"\"\"f(t) = omega_max * sin( (\u03c0/2) * sin(\u03c0 t) )^2, for 0 \u2264 t \u2264 duration\"\"\"      def __init__(self, duration: float , omega_max: float) -&gt; None:         super().__init__(duration, omega_max=omega_max)      def function(self, t: float) -&gt; float:         return self.omega_max * math.sin(0.5 * math.pi * math.sin(math.pi * t/self.duration)) ** 2 <p>\u26a0\ufe0f Remember qoolqit always uses dimensionless units ( documentation ):</p> <ul> <li>Energies are normalized by the maximum drive amplitude $\\Omega_\\text{max}=1$.</li> <li>Time is measured in units of $1/\\Omega_\\text{max}$ (Rabi oscillations).</li> <li>Space is measured in units of $r_B=(C_6/\\Omega_\\text{max})^{1/6}$.</li> </ul> In\u00a0[34]: Copied! <pre>from qoolqit import Drive, QuantumProgram, Ramp\n\nT1 = 2*math.pi # Duration\namp_1 = SmoothPulse(T1, omega_max=1) # amplitude drive\ndet_1 = Ramp(T1, -1, 1) # detuning drive\ndrive_1=Drive(amplitude=amp_1, detuning=det_1) # definine the drive\nprogram = QuantumProgram(reg, drive_1) # define the quantum program\nprogram.register.draw() # draw the register\nprogram.draw() # draw the drive\n</pre> from qoolqit import Drive, QuantumProgram, Ramp  T1 = 2*math.pi # Duration amp_1 = SmoothPulse(T1, omega_max=1) # amplitude drive det_1 = Ramp(T1, -1, 1) # detuning drive drive_1=Drive(amplitude=amp_1, detuning=det_1) # definine the drive program = QuantumProgram(reg, drive_1) # define the quantum program program.register.draw() # draw the register program.draw() # draw the drive <p>To run the QuantumProgram we have to compile it to switch back to physical units that are compatible with a given device. The now compiled sequence and the compiled register are measured in Pulser units. In the compilation it is also possible to select CompilerProfiles to force specific compilation constraints [ documentation ]</p> In\u00a0[35]: Copied! <pre>from qoolqit import AnalogDevice\n\ndevice=AnalogDevice() #Call the device \nprogram.compile_to(device) #Compile to a device\nprogram.compiled_sequence.draw()\nprogram.compiled_sequence.register.draw()\n</pre> from qoolqit import AnalogDevice  device=AnalogDevice() #Call the device  program.compile_to(device) #Compile to a device program.compiled_sequence.draw() program.compiled_sequence.register.draw() In\u00a0[\u00a0]: Copied! <pre>from qoolqit.execution import LocalEmulator\n\n# runs specifies the number of bitstrings sample\nemulator = LocalEmulator(runs=1000)\nresults = emulator.run(program)\n\ncounter = results[0].final_bitstrings\n</pre> from qoolqit.execution import LocalEmulator  # runs specifies the number of bitstrings sample emulator = LocalEmulator(runs=1000) results = emulator.run(program)  counter = results[0].final_bitstrings In\u00a0[37]: Copied! <pre>import matplotlib.pyplot as plt\n\n\ndef plot_distribution(counter, bins=15):\n    counter = dict(counter.most_common(bins))\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"Bitstrings\")\n    ax.set_ylabel(\"Counts\")\n    ax.set_xticks(range(len(counter)))\n    ax.set_xticklabels(counter.keys(), rotation=90)\n    ax.bar(range(len(counter.keys())), counter.values(), tick_label=counter.keys())\n    return fig\n\nfig = plot_distribution(counter, bins=15)\n</pre> import matplotlib.pyplot as plt   def plot_distribution(counter, bins=15):     counter = dict(counter.most_common(bins))     fig, ax = plt.subplots()     ax.set_xlabel(\"Bitstrings\")     ax.set_ylabel(\"Counts\")     ax.set_xticks(range(len(counter)))     ax.set_xticklabels(counter.keys(), rotation=90)     ax.bar(range(len(counter.keys())), counter.values(), tick_label=counter.keys())     return fig  fig = plot_distribution(counter, bins=15)"},{"location":"tutorials/custom_quantum_program/#execute-custom-quantum-program-tutorial","title":"Execute Custom Quantum Program: Tutorial\u00b6","text":"<p>This notebook guides you through executing a custom quantum program using qoolqit.</p>"},{"location":"tutorials/custom_quantum_program/#1-create-the-register","title":"1. Create the Register\u00b6","text":""},{"location":"tutorials/custom_quantum_program/#2-create-a-custom-drive","title":"2. Create a custom Drive\u00b6","text":""},{"location":"tutorials/custom_quantum_program/#3-combine-register-and-drive-into-a-quantum-program","title":"3. Combine Register and Drive into a Quantum Program\u00b6","text":""},{"location":"tutorials/custom_quantum_program/#3a-details-about-units-of-measure","title":"3.a Details about units of measure\u00b6","text":""},{"location":"tutorials/custom_quantum_program/#why-normalization","title":"Why normalization?\u00b6","text":"<p>All quantum devices have a hardware limit for the maximum drive strength they can apply $\\Omega_\\text{max}$. To make programs device-independent, we take this maximum value as our unit of energy and measure every amplitude as a function of it:</p> <p>$$ \\bar{\\Omega} = \\frac{\\Omega}{\\Omega_\\text{max}} $$ For example:</p> <ul> <li>If the physical maximum is $\\Omega_\\text{max}=4\\pi \\,\\text{rad/\u00b5s}$, then $\\bar{\\Omega}_\\text{max}=1$.</li> <li>A drive of $\\Omega=2\\pi \\,\\text{rad/\u00b5s}$ becomes $\\bar{\\Omega}=0.5$.</li> <li>A drive of $\\Omega=\\pi \\,\\text{rad/\u00b5s}$ becomes $\\bar{\\Omega}=0.25$.</li> </ul> <p>This makes all quantum programs dimensionless and therefore comparable across devices.</p>"},{"location":"tutorials/custom_quantum_program/#what-happens-to-other-units","title":"What happens to other units?\u00b6","text":"<p>Normalizing the drive amplitude automatically sets the scale for time and space as well:</p> <ul> <li><p>Energy units: $$ \\bar{E} = \\frac{E}{\\Omega_\\text{max}} $$ So also the detuning is measured in units of $\\Omega_\\text{max}$.</p> </li> <li><p>Time units: At zero detuning, the Rabi frequency is equal to the drive, $$ \\Omega_R = \\Omega_{\\text{max}}, $$ so the natural unit of time is $$ t_R = \\frac{1}{\\Omega_\\text{max}}. $$ All times are expressed in multiples of the Rabi period at maximum drive $T=\\frac{2 \\pi}{\\Omega_{\\text{max}}}=2 \\pi t_R$. $$ \\bar{t} = \\frac{t}{t_R}= \\frac{2 \\pi t}{T} $$ So, in a time $\\bar{t}=2 \\pi$ one gets a full Rabi period.</p> </li> <li><p>Space units: Interactions follow $E(r)=C_6/r^6$. The characteristic length is defined by setting $E(r_B)=\\Omega_\\text{max}$: $$ r_B = \\left(\\frac{C_6}{\\Omega_\\text{max}}\\right)^{1/6}. $$ Distances are expressed relative to $r_B$, i.e. the Rydberg blockade radius at maximum drive. $$ \\bar{r} = \\frac{r}{r_B}. $$</p> </li> </ul>"},{"location":"tutorials/custom_quantum_program/#summary","title":"Summary\u00b6","text":"<ul> <li>Energy \u2192 normalized by $\\Omega_\\text{max}$</li> <li>Time \u2192 measured in $1/\\Omega_\\text{max}$ (Rabi oscillations)</li> <li>Space \u2192 measured in $r_B=(C_6 / \\Omega_\\text{max})^{1/6}$ (interaction length)</li> </ul>"},{"location":"tutorials/custom_quantum_program/#3b-definition-of-drive-and-program","title":"3.b Definition of drive and program\u00b6","text":""},{"location":"tutorials/custom_quantum_program/#4-compile-to-a-device","title":"4. Compile to a device\u00b6","text":""},{"location":"tutorials/custom_quantum_program/#5-execute-the-compiled-quantum-program","title":"5. Execute the compiled quantum program\u00b6","text":""},{"location":"tutorials/custom_quantum_program/#6-plot-bitstring-distribution","title":"6. Plot bitstring distribution\u00b6","text":""},{"location":"tutorials/unit_conversion/","title":"Understanding unit conversions","text":"<p>Let's now write a simple program in QoolQit to demonstrate the behavior described. We will create a program for the $r &lt; 1$ regime (qubits are close), and one for the $r &gt; 1$ (qubits are far), and start by defining the drive of the program with two different durations.</p> In\u00a0[18]: Copied! <pre>import numpy as np\n\nfrom qoolqit import Constant, Drive\n\nomega = 1.0\n\n# Defining the Drive for the close / far system\nduration_close = np.pi * np.sqrt(2.0)\nduration_far = np.pi\n\ndrive_close = Drive(amplitude=Constant(duration_close, omega))\ndrive_far = Drive(amplitude=Constant(duration_far, omega))\n</pre> import numpy as np  from qoolqit import Constant, Drive  omega = 1.0  # Defining the Drive for the close / far system duration_close = np.pi * np.sqrt(2.0) duration_far = np.pi  drive_close = Drive(amplitude=Constant(duration_close, omega)) drive_far = Drive(amplitude=Constant(duration_far, omega)) <p>Now we create the two registers, and then instantiate the programs. We arbitrarily pick $r_\\text{close} = 0.7$ and $r_\\text{far} = 1.5$.</p> In\u00a0[19]: Copied! <pre>from qoolqit import QuantumProgram, Register\n\nr_close = 0.7\nr_far = 1.5\n\nreg_close = Register.from_coordinates([(0.0, 0.0), (r_close, 0.0)])\nreg_far = Register.from_coordinates([(0.0, 0.0), (r_far, 0.0)])\n\nprogram_close = QuantumProgram(reg_close, drive_close)\nprogram_far = QuantumProgram(reg_far, drive_far)\n</pre> from qoolqit import QuantumProgram, Register  r_close = 0.7 r_far = 1.5  reg_close = Register.from_coordinates([(0.0, 0.0), (r_close, 0.0)]) reg_far = Register.from_coordinates([(0.0, 0.0), (r_far, 0.0)])  program_close = QuantumProgram(reg_close, drive_close) program_far = QuantumProgram(reg_far, drive_far) In\u00a0[20]: Copied! <pre>from qoolqit import MockDevice\n\ndevice = MockDevice()\n\nprogram_close.compile_to(device)\nprogram_far.compile_to(device)\n</pre> from qoolqit import MockDevice  device = MockDevice()  program_close.compile_to(device) program_far.compile_to(device) <p>For executing the programs, we will do a statevector simulation of the dynamics and save 100 states during the duration of the program.</p> In\u00a0[\u00a0]: Copied! <pre>from pulser.backend import StateResult\n\nfrom qoolqit.execution import EmulationConfig, LocalEmulator\n\nevaluation_times = np.linspace(0.0, 1.0, 100).tolist()\nobservables = (StateResult(evaluation_times=evaluation_times),)\nemulation_config = EmulationConfig(observables=observables)\nemulator = LocalEmulator(emulation_config=emulation_config)\n\nresults_close = emulator.run(program_close)\nresults_far = emulator.run(program_far)\n\n# states in the qutip backend are qutip objects\nstates_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state]\nstates_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state]\n</pre> from pulser.backend import StateResult  from qoolqit.execution import EmulationConfig, LocalEmulator  evaluation_times = np.linspace(0.0, 1.0, 100).tolist() observables = (StateResult(evaluation_times=evaluation_times),) emulation_config = EmulationConfig(observables=observables) emulator = LocalEmulator(emulation_config=emulation_config)  results_close = emulator.run(program_close) results_far = emulator.run(program_far)  # states in the qutip backend are qutip objects states_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state] states_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state] <p>With the states saved, we can plot the results. We do this by defining a plotting function so that we can reuse it later.</p> In\u00a0[22]: Copied! <pre>import matplotlib.pyplot as plt\n\n\ndef get_figure(states_close: list[np.ndarray], states_far: list[np.ndarray], t_vals) -&gt; plt.Figure:\n    # Compute populations\n    pop_close = abs(np.stack(states_close).T) ** 2\n    pop_far = abs(np.stack(states_far).T) ** 2\n\n    fig, ax = plt.subplots(1, 2)\n\n    ax[0].grid(True, linestyle=\"--\", linewidth=0.7)\n    ax[0].plot(t_vals, pop_close[0], label=\"00\")\n    ax[0].plot(t_vals, pop_close[1], label=\"01\")\n    ax[0].plot(t_vals, pop_close[2], label=\"10\", linestyle=\"dashed\")\n    ax[0].plot(t_vals, pop_close[3], label=\"11\")\n    ax[0].set_ylabel(\"Population\")\n    ax[0].set_xlabel(\"Time t\")\n    ax[0].set_title(\"Blockade regime\")\n    ax[0].legend()\n\n    ax[1].grid(True, linestyle=\"--\", linewidth=0.7)\n    ax[1].plot(t_vals, pop_far[0], label=\"00\")\n    ax[1].plot(t_vals, pop_far[1], label=\"01\")\n    ax[1].plot(t_vals, pop_far[2], label=\"10\", linestyle=\"dashed\")\n    ax[1].plot(t_vals, pop_far[3], label=\"11\")\n    ax[1].set_xlabel(\"Time t\")\n    ax[1].set_title(\"Non-blockade regime\")\n    ax[1].legend()\n\n    return fig\n\n\nfig = get_figure(states_close, states_far, evaluation_times)\nplt.show()\n</pre> import matplotlib.pyplot as plt   def get_figure(states_close: list[np.ndarray], states_far: list[np.ndarray], t_vals) -&gt; plt.Figure:     # Compute populations     pop_close = abs(np.stack(states_close).T) ** 2     pop_far = abs(np.stack(states_far).T) ** 2      fig, ax = plt.subplots(1, 2)      ax[0].grid(True, linestyle=\"--\", linewidth=0.7)     ax[0].plot(t_vals, pop_close[0], label=\"00\")     ax[0].plot(t_vals, pop_close[1], label=\"01\")     ax[0].plot(t_vals, pop_close[2], label=\"10\", linestyle=\"dashed\")     ax[0].plot(t_vals, pop_close[3], label=\"11\")     ax[0].set_ylabel(\"Population\")     ax[0].set_xlabel(\"Time t\")     ax[0].set_title(\"Blockade regime\")     ax[0].legend()      ax[1].grid(True, linestyle=\"--\", linewidth=0.7)     ax[1].plot(t_vals, pop_far[0], label=\"00\")     ax[1].plot(t_vals, pop_far[1], label=\"01\")     ax[1].plot(t_vals, pop_far[2], label=\"10\", linestyle=\"dashed\")     ax[1].plot(t_vals, pop_far[3], label=\"11\")     ax[1].set_xlabel(\"Time t\")     ax[1].set_title(\"Non-blockade regime\")     ax[1].legend()      return fig   fig = get_figure(states_close, states_far, evaluation_times) plt.show() <p>As you can see above, the results obtained are exactly what we expected from the model. Now we may check what was the Pulser sequence that was used under the hood, for example, for the blockaded regime.</p> In\u00a0[23]: Copied! <pre>program_close.draw(compiled = True)\n</pre> program_close.draw(compiled = True) <p>This was the sequence created by the device's default unit converter.</p> In\u00a0[24]: Copied! <pre>print(\"Converter:\", device.converter)\n</pre> print(\"Converter:\", device.converter) <pre>Converter: UnitConverter(time = 79.577, energy = 12.566, distance = 8.692)\n</pre> <p>As described in the model page, unit conversion is done by multiplying the values in QoolQit by the conversion factors. You can double-check yourself that the values of $\\Omega$ and duration for this sequence match the ones set in QoolQit multiplied by the factors in the converter.</p> <p>What if we wanted to set some custom conversion factors? Would it make a difference? Below we set the energy unit to $10.0$, and check that the converter is updated.</p> In\u00a0[25]: Copied! <pre>device.set_energy_unit(10.0)\nprint(\"Updated converter:\", device.converter)\n</pre> device.set_energy_unit(10.0) print(\"Updated converter:\", device.converter) <pre>Updated converter: UnitConverter(time = 100.000, energy = 10.000, distance = 9.030)\n</pre> <p>We can now recompile our programs to the updated device, run, and plot the results.</p> In\u00a0[26]: Copied! <pre>program_close.compile_to(device)\nprogram_far.compile_to(device)\n\nresults_close = emulator.run(program_close)\nresults_far = emulator.run(program_far)\n\n# states in the qutip backend are qutip objects\nstates_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state]\nstates_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state]\n\nfig = get_figure(states_close, states_far, evaluation_times)\nplt.show()\n</pre> program_close.compile_to(device) program_far.compile_to(device)  results_close = emulator.run(program_close) results_far = emulator.run(program_far)  # states in the qutip backend are qutip objects states_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state] states_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state]  fig = get_figure(states_close, states_far, evaluation_times) plt.show() <p>As expected, the results are exactly the same. Our program did not change, and since we are running on a perfect device the conversion is exact, independently of the conversion factors used. Only the physical implementation of our program has changed.</p> In\u00a0[\u00a0]: Copied! <pre>from qoolqit import AnalogDevice\n\ndevice = AnalogDevice()\n\ntry:\n    program_close.compile_to(device)\nexcept Exception as error:\n    print(\"Compilation (close) failed:\", error)\n\nprogram_far.compile_to(device)\nprint(\"Far program compiled.\")\n</pre> from qoolqit import AnalogDevice  device = AnalogDevice()  try:     program_close.compile_to(device) except Exception as error:     print(\"Compilation (close) failed:\", error)  program_far.compile_to(device) print(\"Far program compiled.\") <pre>Compilation (close) failed: Failed to compile the sequence due to:\n\nThe minimal distance between atoms in this device (5 \u00b5m) is not respected (up to a precision of 1e-6 \u00b5m) for the pairs: [('0', '1')]\nFar program compiled.\n</pre> <p>While the program setting the qubits far apart compiled without problems, the one with the qubits closer together did not, because the compiler tried to put atoms closer than the minimum physical distance allowed on this device. Such limitations can be checked at the level of QoolQit in the <code>specs</code> property of the devices:</p> In\u00a0[28]: Copied! <pre>print(\"Device specs:\", device.specs)\n</pre> print(\"Device specs:\", device.specs) <pre>Device specs: {'max_duration': 75.39822368615503, 'max_amplitude': 1.0, 'max_detuning': 10.0, 'min_distance': 0.7809234915702248}\n</pre> <p>Note that the values shown are adimensional, meaning that they depend on the current unit converter that is set on the device. Since we tried setting the qubits at $r_\\text{close} = 0.7$, this is lower than the minimum distance allowed on this device given the default converter.</p> <p>Changing the program would be an option to achieve the compilation. For example, instead of using $\\Omega = 1$, we could set $\\Omega = 0.3$, which in turn would increase the blockade radius. Then we could set $r_\\text{close} = 0.7r_b\\approx0.856$ and $r_\\text{far} = 1.5r_b\\approx1.833$, which would now match the device constraints, and we would observe the same blockade behavior (albeit with the dynamics on a different time-scale, scaled as $t/\\Omega$).</p> <p>However, that would be a fundamentally different program, and the goal in this tutorial is to exemplify how a fixed program can be translated differently through unit conversions. So, instead, we are just going to compile our original program differently. Below we check the unit converter used, then make a small arbitrary increase to the distance unit, and check the updated converter.</p> In\u00a0[29]: Copied! <pre>print(\"Converter (before):\", device.converter)\ndevice.set_distance_unit(7.5)\nprint(\"Converter (after):\", device.converter)\n</pre> print(\"Converter (before):\", device.converter) device.set_distance_unit(7.5) print(\"Converter (after):\", device.converter) <pre>Converter (before): UnitConverter(time = 79.577, energy = 12.566, distance = 6.403)\nConverter (after): UnitConverter(time = 205.584, energy = 4.864, distance = 7.500)\n</pre> <p>Let's check the device specs again:</p> In\u00a0[30]: Copied! <pre>print(\"Device specs (updated):\", device.specs)\n</pre> print(\"Device specs (updated):\", device.specs) <pre>Device specs (updated): {'max_duration': 29.185197447901235, 'max_amplitude': 2.583440589043439, 'max_detuning': 25.83440589043439, 'min_distance': 0.6666666666666666}\n</pre> <p>With the updated converter the allowed minimum distance is smaller, and both programs should now compile. We can again plot the results:</p> In\u00a0[31]: Copied! <pre>program_close.compile_to(device)\nprogram_far.compile_to(device)\n\nemulation_config = EmulationConfig(observables=observables, with_modulation=True)\nemulator = LocalEmulator(emulation_config=emulation_config)\n\nresults_close = emulator.run(program_close)\nresults_far = emulator.run(program_far)\n\n# states in the qutip backend are qutip objects\nstates_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state]\nstates_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state]\n\nfig = get_figure(states_close, states_far, evaluation_times)\n</pre> program_close.compile_to(device) program_far.compile_to(device)  emulation_config = EmulationConfig(observables=observables, with_modulation=True) emulator = LocalEmulator(emulation_config=emulation_config)  results_close = emulator.run(program_close) results_far = emulator.run(program_far)  # states in the qutip backend are qutip objects states_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state] states_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state]  fig = get_figure(states_close, states_far, evaluation_times) <p>Once again, we get the expected results. However, notice that there is slight difference in the dynamics compared to the ideal case shown earlier, as both the start and end of the plots are more horizontal. Let's inspect the compiled sequence for one of the programs.</p> In\u00a0[32]: Copied! <pre>program_close.draw(compiled = True)\n</pre> program_close.draw(compiled = True) <p>As you can see, in a realistic device you cannot implement a perfectly square waveform, as the system requires some time to raise and lower the amplitude of the laser that implements it. This is called the waveform modulation and in this case it introduces a discrepancy between the expected results in the ideal scenario and the actual results from the physical implementation.</p> In\u00a0[33]: Copied! <pre>from qoolqit import AnalogDevice, CompilerProfile\n\ndevice = AnalogDevice()\n\nprogram_close.compile_to(device, profile=CompilerProfile.MAX_DURATION)\nprogram_far.compile_to(device, profile=CompilerProfile.MAX_DURATION)\n\nresults_close = emulator.run(program_close)\nresults_far = emulator.run(program_far)\n\n# states in the qutip backend are qutip objects\nstates_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state]\nstates_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state]\n\nfig = get_figure(states_close, states_far, evaluation_times)\n</pre> from qoolqit import AnalogDevice, CompilerProfile  device = AnalogDevice()  program_close.compile_to(device, profile=CompilerProfile.MAX_DURATION) program_far.compile_to(device, profile=CompilerProfile.MAX_DURATION)  results_close = emulator.run(program_close) results_far = emulator.run(program_far)  # states in the qutip backend are qutip objects states_close = [np.flip(state.to_qobj().full().flatten()) for state in results_close[0].state] states_far = [np.flip(state.to_qobj().full().flatten()) for state in results_far[0].state]  fig = get_figure(states_close, states_far, evaluation_times) <p>The results are now much closer to the ideal case. Let's inspect the compiled sequence:</p> In\u00a0[34]: Copied! <pre>program_close.draw(compiled = True)\n</pre> program_close.draw(compiled = True) <p>By using the <code>CompilerProfile.MAX_DURATION</code>, the compiler automatically mapped whatever was the program duration to be equal to the device's maximum duration. This was done by calculating the ideal conversions factors that match this condition, and using those. This not only allowed for a successful compilation of both programs, but it also mitigated the modulation errors by stretching the program over a longer time.</p> <p>Note: In the future we can add a <code>safe_mode = True</code> to the compiler, where a profile is dynamically adjusted until it achieves a successful compilation.</p>"},{"location":"tutorials/unit_conversion/#understanding-unit-conversions","title":"Understanding unit conversions\u00b6","text":"<p>In this tutorial we exemplify how unit conversions play a role in the underlying QoolQit program compilation and execution. We will analyze the dynamics of one of the most fundamental algorithmic behaviors in the Rydberg analog model: the Rydberg blockade.</p>"},{"location":"tutorials/unit_conversion/#rydberg-blockade","title":"Rydberg blockade\u00b6","text":"<p>Consider a system of two qubits in state $|00\\rangle$, placed in two sites at a distance $r$ at $t=0$. For simplicity, we set the program drive as a constant amplitude waveform of value $\\Omega$ for $t\\geq0$. Following the  Rydberg model page , the two-qubit system evolves with the Hamiltonian</p> <p>$$ H_{01}=\\frac{\\Omega}{2}(\\hat{\\sigma}^x_0+\\hat{\\sigma}^x_1)+\\frac{1}{r^6}\\hat{n}_0\\hat{n}_1 $$</p> <p>The interaction term imposes an energy of $1/r^6$ on state $|11\\rangle$, and thus this state is only accessible if $\\Omega&gt;1/r^6$. As such, the radius</p> <p>$$ r_b=\\Omega^{-\\frac{1}{6}} $$</p> <p>is called the Rydberg blockade radius, such that if two qubits are at a distance $r &lt; r_b$, the state $|11\\rangle$ is blocked, while if they are at a distance $r &gt; r_b$, the state $|11\\rangle$ is accessible.</p> <p>For simplicity, we we now set $\\Omega = 1$, and thus $r_b = 1$. If you solve the system analytically you will find that in the blockade regime the initial population of $|00\\rangle$ transitions to $\\frac{1}{\\sqrt{2}}|01\\rangle+|10\\rangle$ at $t=\\pi/\\sqrt{2}$, while in the non-blockade regime the transition $|00\\rangle \\rightarrow |11\\rangle$ is complete at $t=\\pi$.</p>"},{"location":"tutorials/unit_conversion/#running-on-a-mock-device","title":"Running on a mock device\u00b6","text":"<p>First, let's run the programs on a mock device and see what we get. We instantiate the device, compile both programs, and call the <code>run()</code> method.</p>"},{"location":"tutorials/unit_conversion/#running-on-a-realistic-device","title":"Running on a realistic device\u00b6","text":"<p>Now, let's replicate this experiment for a more realistic device. Note that the workflow we will show now is for demonstration purposes, and is not the recommended one for the average QoolQit user.</p> <p>We can use the <code>AnalogDevice</code>, which unlike the <code>MockDevice</code>, has limitations on certain values that can be set. This is immediately clear if we try to compile the program as it is to the default settings of the <code>AnalogDevice</code>:</p>"},{"location":"tutorials/unit_conversion/#using-compiler-profiles","title":"Using compiler profiles\u00b6","text":"<p>At the start of the previous section it was noted that the workflow of manually changing the unit converter is not necessarily the recommended one, and should be reserved for more advanced users. At the same time, at the end of the section we saw that in this case the compilation was not ideal, because the program was slightly affected by waveform modulation errors.</p> <p>To address both of these issues, we can use compiler profiles. These are directives for the compiler to follow while trying to compile the sequence, which can be designed with various specific purposes in mind. Going in detail on compiler profiles in QoolQit is not the purpose of this tutorial, but here we can exemplify the usage of one:</p>"},{"location":"tutorials/user_journey/","title":"QooQit user journey tutorial","text":"In\u00a0[16]: Copied! <pre>from qoolqit import SpringLayoutEmbedder\n\nsl_embedder = SpringLayoutEmbedder()\nprint(sl_embedder)\n</pre> from qoolqit import SpringLayoutEmbedder  sl_embedder = SpringLayoutEmbedder() print(sl_embedder) <pre>SpringLayoutEmbedder:\n| Algorithm: spring_layout_embedding\n| Config: SpringLayoutConfig(k=None, iterations=50, threshold=0.0001, seed=None)\n</pre> In\u00a0[17]: Copied! <pre>from qoolqit import DataGraph\n\n# start with a graph with no coordinates\ngraph_1 = DataGraph.random_er(n = 7, p = 0.3, seed = 3)\n\n# embed with spring-layout, assigning coordinates\nembedded_graph_1 = sl_embedder.embed(graph_1)\n\ngraph_1.draw()\nembedded_graph_1.draw()\n</pre> from qoolqit import DataGraph  # start with a graph with no coordinates graph_1 = DataGraph.random_er(n = 7, p = 0.3, seed = 3)  # embed with spring-layout, assigning coordinates embedded_graph_1 = sl_embedder.embed(graph_1)  graph_1.draw() embedded_graph_1.draw() In\u00a0[18]: Copied! <pre>import numpy as np\n\nQ = np.array([\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n])\nQ = Q/Q.max()\n</pre> import numpy as np  Q = np.array([         [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],         [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],         [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],         [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],         [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0], ]) Q = Q/Q.max() In\u00a0[19]: Copied! <pre>from qoolqit import InteractionEmbedder\n\nembedder = InteractionEmbedder()\nprint(embedder)\n\nembedded_graph = embedder.embed(Q)\nembedded_graph.draw()\n</pre> from qoolqit import InteractionEmbedder  embedder = InteractionEmbedder() print(embedder)  embedded_graph = embedder.embed(Q) embedded_graph.draw() <pre>InteractionEmbedder:\n| Algorithm: interaction_embedding\n| Config: InteractionEmbeddingConfig(method='Nelder-Mead', maxiter=200000, tol=1e-08)\n</pre> In\u00a0[20]: Copied! <pre>from qoolqit import Drive, PiecewiseLinear, QuantumProgram, Ramp, Register\n\n# Create the register\nregister = Register.from_graph(embedded_graph)\n\n# Defining the drive\nomega = np.median(Q[Q &gt; 0].flatten())\ndelta_i = -2.0 * omega\ndelta_f = 2.0 * omega\nT = 40.0\n\namplitude = PiecewiseLinear([T/4, T/2, T/4], [0.0, omega, omega, 0.0])\ndetuning = Ramp(T, delta_i, delta_f)\ndrive = Drive(amplitude = amplitude, detuning = detuning)\n\n# Writing the quantum program\nprogram = QuantumProgram(register, drive)\nprogram.draw()\n</pre> from qoolqit import Drive, PiecewiseLinear, QuantumProgram, Ramp, Register  # Create the register register = Register.from_graph(embedded_graph)  # Defining the drive omega = np.median(Q[Q &gt; 0].flatten()) delta_i = -2.0 * omega delta_f = 2.0 * omega T = 40.0  amplitude = PiecewiseLinear([T/4, T/2, T/4], [0.0, omega, omega, 0.0]) detuning = Ramp(T, delta_i, delta_f) drive = Drive(amplitude = amplitude, detuning = detuning)  # Writing the quantum program program = QuantumProgram(register, drive) program.draw() In\u00a0[21]: Copied! <pre>from qoolqit import AnalogDevice\n\ndevice = AnalogDevice() # pick a device\nprogram.compile_to(device=device) # basic compilation\n</pre> from qoolqit import AnalogDevice  device = AnalogDevice() # pick a device program.compile_to(device=device) # basic compilation In\u00a0[22]: Copied! <pre># view the compiled Pulser sequence\nprogram.compiled_sequence.draw()\n</pre> # view the compiled Pulser sequence program.compiled_sequence.draw() <p>The max duration strategy, compile the same quantum program, but prioritize making the sequence longer, lowering the maximum amplitude and increasing interatomic distance between atoms.</p> In\u00a0[23]: Copied! <pre>from qoolqit.execution import CompilerProfile\n\nprogram.compile_to(device=device, profile=CompilerProfile.MAX_DURATION)\nprogram.compiled_sequence.draw()\n</pre> from qoolqit.execution import CompilerProfile  program.compile_to(device=device, profile=CompilerProfile.MAX_DURATION) program.compiled_sequence.draw() In\u00a0[24]: Copied! <pre>from qoolqit.execution import LocalEmulator\n\nemulator = LocalEmulator()\nresults = emulator.run(program)[0]\n# final bitstrings from results\ncounter = results.final_bitstrings\nprint(counter)\n</pre> from qoolqit.execution import LocalEmulator  emulator = LocalEmulator() results = emulator.run(program)[0] # final bitstrings from results counter = results.final_bitstrings print(counter) <pre>Counter({'01011': 39, '00111': 37, '00011': 10, '00110': 4, '10000': 3, '01001': 3, '01010': 2, '00101': 1, '10011': 1})\n</pre> In\u00a0[25]: Copied! <pre># Classical solution\nbitstrings = np.array([np.binary_repr(i, len(Q)) for i in range(2 ** len(Q))])\nbitstring_lists = np.array([np.array(list(b), dtype=int) for b in bitstrings])\ncosts = np.array([z.T @ Q @ z for z in bitstring_lists])\nidx_sort = np.argsort(costs).tolist()\n\nsorted_costs = costs[idx_sort]\nsorted_bitstrings = bitstrings[idx_sort]\n\nprint(\"Two best solutions: \", sorted_bitstrings[:2])\nprint(\"Respective costs: \", sorted_costs[:2])\n\n# We save the two best solutions for plotting\nmarked_bitstrings = sorted_bitstrings[:2]\n</pre> # Classical solution bitstrings = np.array([np.binary_repr(i, len(Q)) for i in range(2 ** len(Q))]) bitstring_lists = np.array([np.array(list(b), dtype=int) for b in bitstrings]) costs = np.array([z.T @ Q @ z for z in bitstring_lists]) idx_sort = np.argsort(costs).tolist()  sorted_costs = costs[idx_sort] sorted_bitstrings = bitstrings[idx_sort]  print(\"Two best solutions: \", sorted_bitstrings[:2]) print(\"Respective costs: \", sorted_costs[:2])  # We save the two best solutions for plotting marked_bitstrings = sorted_bitstrings[:2] <pre>Two best solutions:  ['01011' '00111']\nRespective costs:  [-1.31978679 -1.31978679]\n</pre> In\u00a0[26]: Copied! <pre>import matplotlib.pyplot as plt\n\n\ndef plot_distribution(counter, solutions, bins=10):\n    counter = dict(counter.most_common(bins))\n    color = [\"tab:green\" if key in solutions.tolist() else \"tab:blue\" for key in counter]\n    fig, ax = plt.subplots()\n    ax.set_xlabel(\"Bitstrings\")\n    ax.set_ylabel(\"Counts\")\n    ax.bar(range(len(counter)), counter.values(), color=color, tick_label=counter.keys())\n    return fig\n\nfig = plot_distribution(counter, marked_bitstrings)\n</pre> import matplotlib.pyplot as plt   def plot_distribution(counter, solutions, bins=10):     counter = dict(counter.most_common(bins))     color = [\"tab:green\" if key in solutions.tolist() else \"tab:blue\" for key in counter]     fig, ax = plt.subplots()     ax.set_xlabel(\"Bitstrings\")     ax.set_ylabel(\"Counts\")     ax.bar(range(len(counter)), counter.values(), color=color, tick_label=counter.keys())     return fig  fig = plot_distribution(counter, marked_bitstrings) <p>As we can see, the bitstrings we had marked as the optimal solutions of this QUBO problem were the ones sampled with the highest probability, meaning the the QUBO problem was successfully solved with the quantum program we defined.</p> <p>Remote execution requires a connection object to connect to Pasqal Cloud services:</p> In\u00a0[27]: Copied! <pre>import os\n\nfrom pulser_pasqal import PasqalCloud\n\n# store credentials as env variables\nconnection = PasqalCloud(\n        username=os.getenv(\"PCP_USER\"), \n        password=os.getenv(\"PCP_PASSWORD\"), \n        project_id=os.getenv(\"PCP_PROJECT_ID\")\n        )\n</pre> import os  from pulser_pasqal import PasqalCloud  # store credentials as env variables connection = PasqalCloud(         username=os.getenv(\"PCP_USER\"),          password=os.getenv(\"PCP_PASSWORD\"),          project_id=os.getenv(\"PCP_PROJECT_ID\")         ) <p>Advanced users might want to fully configure an emulator backend to exploit all its possibilities:</p> <ul> <li>defining observables to measure</li> <li>emulate real hardware-modulation effects</li> </ul> In\u00a0[\u00a0]: Copied! <pre>from qoolqit.execution import BackendType, EmulationConfig, Occupation, RemoteEmulator\n\nobservables = (Occupation(),)\nemulation_config = EmulationConfig(observables=observables, with_modulation=True)\n\nemulator = RemoteEmulator(\n    backend_type=BackendType.EmuMPSBackend,\n    connection=connection,\n    emulation_config=emulation_config,\n    runs=1000\n    )\n</pre> from qoolqit.execution import BackendType, EmulationConfig, Occupation, RemoteEmulator  observables = (Occupation(),) emulation_config = EmulationConfig(observables=observables, with_modulation=True)  emulator = RemoteEmulator(     backend_type=BackendType.EmuMPSBackend,     connection=connection,     emulation_config=emulation_config,     runs=1000     ) In\u00a0[29]: Copied! <pre># results = emulator.run(program)\n</pre> # results = emulator.run(program)"},{"location":"tutorials/user_journey/#qooqit-user-journey-tutorial","title":"QooQit user journey tutorial\u00b6","text":"<ol> <li>Embedders</li> <li>Creating a QuantumProgram</li> <li>Compiling to a device</li> <li>Executing a QuantumProgram</li> </ol> <p>GitHub: https://github.com/pasqal-io/qoolqit</p> <p>Docs: https://pasqal-io.github.io/qoolqit or https://docs.pasqal.com/qoolqit</p>"},{"location":"tutorials/user_journey/#1-embedders","title":"1. Embedders\u00b6","text":"<p>Anything that help us to map an abstract problem into something that can be implemented in Pasqal's hardware</p> <p></p> <p>Two available graph embedders:</p> <ul> <li>graph to graph embedder</li> <li>matrix to graph embedder</li> </ul> <p>More to come in collaboration with application developers.</p> <p>Info at https://pasqal-io.github.io/qoolqit/latest/contents/available_embedders/</p>"},{"location":"tutorials/user_journey/#a-graph-graph-springlayout-embedder","title":"a. Graph-&gt;Graph: SpringLayout Embedder\u00b6","text":"<p>Embed a generic graph into one with well-defined coordinates positions.</p>"},{"location":"tutorials/user_journey/#b-matrix-graph-interaction-embedder","title":"b. Matrix-&gt;Graph: Interaction embedder\u00b6","text":"<p>Matrix to graph embedders try to embed the off-diagonal elements of a matrix (representing an instance of a QUBO problem for example), into interactions between qubits in the Rydberg Analog Model.</p>"},{"location":"tutorials/user_journey/#2-creating-a-quantumprogram","title":"2. Creating a QuantumProgram\u00b6","text":"<p>After the embedding stage, creating a QuantumProgram requires the user to specify a register and a drive, to completely specify the Rydberg Analog Model.</p> <p>Here we target a specific application. Let's solve the QUBO instance defined above.</p>"},{"location":"tutorials/user_journey/#3-compiling-to-a-device","title":"3. Compiling to a device\u00b6","text":"<p>The <code>QuantumProgram</code> is hardware-agnostic so far. At this stage the user need to:</p> <ul> <li>Pick a device. Could be a real QPU or a digital-twin.</li> <li>Pick a compilation strategy. Here, we show the basic one and MAX_DURATION.</li> </ul> <p>Importantly, a program must be compiled before being executed (see later in this notebook).</p>"},{"location":"tutorials/user_journey/#4-execution","title":"4. Execution\u00b6","text":"<p>Execution has to cover use-cases from beginner to advanced.</p> <ul> <li>Local/remote emulators, QPU</li> <li>More info at https://pasqal-io.github.io/qoolqit/latest/contents/execution/</li> </ul> <p>The easiest way to run a program is to use an emulator.</p> <ul> <li>Same Results object as in Pulser</li> <li>TODO: convenient post-processing methods</li> </ul>"},{"location":"tutorials/user_journey/#show-results","title":"Show results\u00b6","text":"<p>This QUBO instance is small so we can also easily check for its classical solutions.</p>"},{"location":"tutorials/user_journey/#a-configure-your-emulator-advanced","title":"a. Configure your emulator [Advanced]\u00b6","text":"<p>A more complex use-case is, for example, configuring a remote backend. More info at https://pasqal-io.github.io/qoolqit/latest/contents/execution/</p>"},{"location":"api/qoolqit/","title":"API Reference","text":"qoolqit<p> source package qoolqit </p> <p>A Python library for algorithm development in the Rydberg Analog Model.</p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> <li> <p>InteractionEmbedder \u2014 A matrix to graph embedder using the interaction embedding algorithm.</p> </li> <li> <p>InteractionEmbeddingConfig \u2014 Configuration parameters for the interaction embedding.</p> </li> <li> <p>SpringLayoutConfig \u2014 Configuration parameters for the spring-layout embedding.</p> </li> <li> <p>SpringLayoutEmbedder \u2014 A graph to graph embedder using the spring layout algorithm.</p> </li> <li> <p>BladeConfig \u2014 Configuration parameters to embed with BLaDE.</p> </li> <li> <p>Blade \u2014 A matrix to graph embedder using the BLaDE algorithm.</p> </li> <li> <p>Blackman \u2014 A Blackman window of a specified duration and area under the curve.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Interpolated \u2014 A waveform created from interpolation of a set of data points.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> <li> <p>Drive \u2014 The drive Hamiltonian acting over a duration.</p> </li> <li> <p>Register \u2014 The Register in QoolQit, representing a set of qubits with coordinates.</p> </li> <li> <p>QuantumProgram \u2014 A program representing a Sequence acting on a Register of qubits.</p> </li> <li> <p>CompilerProfile</p> </li> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device for analog sequence execution.</p> </li> <li> <p>DigitalAnalogDevice \u2014 A device with digital and analog capabilities.</p> </li> <li> <p>MockDevice \u2014 A virtual device for unconstrained prototyping.</p> </li> <li> <p>Device \u2014 QoolQit Device wrapper around a Pulser BaseDevice.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>available_default_devices \u2014 Show the default available devices in QooQit.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>triangular \u2014 Constructs a triangular lattice graph, with respective coordinates.</p> </li> <li> <p>hexagonal \u2014 Constructs a hexagonal lattice graph, with respective coordinates.</p> </li> <li> <p>heavy_hexagonal \u2014 Constructs a heavy-hexagonal lattice graph, with respective coordinates.</p> </li> <li> <p>square \u2014 Constructs a square lattice graph, with respective coordinates.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float, seed: int | None = None) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul> <p> source classmethod DataGraph.triangular(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a triangular lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of triangles.</p> </li> <li> <p>n :  int \u2014 Number of columns of triangles.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.hexagonal(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a hexagonal lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of hexagons.</p> </li> <li> <p>n :  int \u2014 Number of columns of hexagons.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.heavy_hexagonal(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a heavy-hexagonal lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of hexagons.</p> </li> <li> <p>n :  int \u2014 Number of columns of hexagons.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p>Notes</p> <p>The heavy-hexagonal lattice is a regular hexagonal lattice where each edge is decorated with an additional lattice site.</p> <p> source classmethod DataGraph.square(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a square lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of square.</p> </li> <li> <p>n :  int \u2014 Number of columns of square.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> source class InteractionEmbedder() </p> <p>Bases : MatrixToGraphEmbedder[InteractionEmbeddingConfig]</p> <p>A matrix to graph embedder using the interaction embedding algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source dataclass InteractionEmbeddingConfig(method: str = 'Nelder-Mead', maxiter: int = 200000, tol: float = 1e-08) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the interaction embedding.</p> <p> source dataclass SpringLayoutConfig(k: float | None = None, iterations: int = 50, threshold: float = 0.0001, seed: int | None = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the spring-layout embedding.</p> <p> source class SpringLayoutEmbedder() </p> <p>Bases : GraphToGraphEmbedder[SpringLayoutConfig]</p> <p>A graph to graph embedder using the spring layout algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source dataclass BladeConfig(max_min_dist_ratio: float | None = None, dimensions: tuple[int, ...] = (5, 4, 3, 2, 2, 2), starting_positions: np.ndarray | None = None, pca: bool = False, steps_per_round: int = 200, compute_weight_relative_threshold: Callable[[float], float] = lambda _: 0.1, compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]] = lambda x, max_radial_dist: np.inf, starting_ratio_factor: int = 2, draw_steps: bool | list[int] = False, device: InitVar[Device | None] = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters to embed with BLaDE.</p> <p> source class Blade(config: BladeConfig = BladeConfig()) </p> <p>Bases : MatrixToGraphEmbedder[BladeConfig]</p> <p>A matrix to graph embedder using the BLaDE algorithm.</p> <p>Inits Blade.</p> <p> Parameters </p> <ul> <li> <p>config :  BladeConfig \u2014 configuration object for the BLaDE algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>embed \u2014 Return a DataGraph with coordinates that embeds the input matrix.</p> </li> </ul> <p> source method Blade.embed(data: np.ndarray) \u2192 DataGraph </p> <p>Return a DataGraph with coordinates that embeds the input matrix.</p> <p>Validates the input, runs the embedding algorithm, and validates the output.</p> <p> Parameters </p> <ul> <li> <p>data :  np.ndarray \u2014 the matrix to embed into a DataGraph with coordinates.</p> </li> </ul> <p> source class Blackman(duration: float, area: float) </p> <p>Bases : Waveform</p> <p>A Blackman window of a specified duration and area under the curve.</p> <p>Implements the Blackman window shaped waveform     blackman(t) = A(0.42 - 0.5cos(\u03b1t) + 0.08cos(2\u03b1t))               A = area/(0.42duration)               \u03b1 = 2\u03c0/duration</p> <p>Initializes a new Blackman waveform.</p> <p> See </p> <p>https://en.wikipedia.org/wiki/Window_function#:~:text=Blackman%20window</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 The waveform duration.</p> </li> <li> <p>area :  float \u2014 The integral of the waveform.</p> </li> </ul> <p> Example </p> <pre><code>blackman_wf = Blackman(100.0, area=3.14)\n</code></pre> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Blackman.function(t: float) \u2192 float </p> <p> source method Blackman.max() \u2192 float </p> <p> source method Blackman.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class Delay(duration: float, *args: float, **kwargs: float | np.ndarray) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Interpolated(duration: float, values: ArrayLike, times: Optional[ArrayLike] = None, interpolator: str = 'PchipInterpolator', **interpolator_kwargs: Any) </p> <p>Bases : Waveform</p> <p>A waveform created from interpolation of a set of data points.</p> <p>Initializes a new Interpolated waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  int \u2014 The waveform duration (in ns).</p> </li> <li> <p>values :  ArrayLike \u2014 Values of the interpolation points. Must be a list of castable to float or a parametrized object.</p> </li> <li> <p>times :  ArrayLike \u2014 Fractions of the total duration (between 0 and 1), indicating where to place each value on the time axis. Must be a list of castable to float or a parametrized object. If not given, the values are spread evenly throughout the full duration of the waveform.</p> </li> <li> <p>interpolator :  str \u2014 The SciPy interpolation class to use. Supports \"PchipInterpolator\" and \"interp1d\".</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>min</p> </li> <li> <p>max</p> </li> </ul> <p> source method Interpolated.function(t: float) \u2192 float </p> <p> source method Interpolated.min() \u2192 float </p> <p> source method Interpolated.max() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p> <p> source class Drive(*args: Any, amplitude: Waveform | None = None, detuning: Waveform | None = None, weighted_detunings: list[WeightedDetuning] | None = None, phase: float = 0.0) </p> <p>The drive Hamiltonian acting over a duration.</p> <p>Default constructor for the Drive.</p> <p>Must be instantiated with keyword arguments. Accepts either an amplitude waveform, a detuning waveform, or both. A phase value can also be passed.</p> <p> Parameters </p> <ul> <li> <p>amplitude :  Waveform | None \u2014 waveform representing \u03a9(t) in the drive Hamiltonian.</p> </li> <li> <p>detuning :  Waveform | None \u2014 waveform representing \u03b4(t) in the drive Hamiltonian.</p> </li> <li> <p>phase :  float \u2014 phase value \u0278 for the amplitude term.</p> </li> <li> <p>weighted_detunings :  list[WeightedDetuning] | None \u2014 additional waveforms and weights applied to individual qubits. Note that these detunings are not supported on all devices.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>amplitude :  Waveform \u2014 The amplitude waveform in the drive.</p> </li> <li> <p>detuning :  Waveform \u2014 The detuning waveform in the drive.</p> </li> <li> <p>weighted_detunings :  Sequence[WeightedDetuning] \u2014 Detunings applied to individual qubits.</p> </li> <li> <p>phase :  float \u2014 The phase value in the drive.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw</p> </li> </ul> <p> source property Drive.amplitude: Waveform </p> <p>The amplitude waveform in the drive.</p> <p> source property Drive.detuning: Waveform </p> <p>The detuning waveform in the drive.</p> <p> source property Drive.weighted_detunings: Sequence[WeightedDetuning] </p> <p>Detunings applied to individual qubits.</p> <p> source property Drive.phase: float </p> <p>The phase value in the drive.</p> <p> source property Drive.duration: float </p> <p> source method Drive.draw(n_points: int = 500, return_fig: bool = False) \u2192 Figure | None </p> <p> source class Register(qubits: dict) </p> <p>The Register in QoolQit, representing a set of qubits with coordinates.</p> <p>Default constructor for the Register.</p> <p> Parameters </p> <ul> <li> <p>qubits :  dict \u2014 a dictionary of qubits and respective coordinates {q: (x, y), ...}.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>qubits :  dict \u2014 Returns the dictionary of qubits and respective coordinates.</p> </li> <li> <p>qubits_ids :  list \u2014 Returns the qubit keys.</p> </li> <li> <p>n_qubits :  int \u2014 Number of qubits in the Register.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_graph \u2014 Initializes a Register from a graph that has coordinates.</p> </li> <li> <p>from_coordinates \u2014 Initializes a Register from a list of coordinates.</p> </li> <li> <p>distances \u2014 Distance between each qubit pair.</p> </li> <li> <p>min_distance \u2014 Minimum distance between all qubit pairs.</p> </li> <li> <p>radial_distances \u2014 Radial distance of each qubit from the origin.</p> </li> <li> <p>max_radial_distance \u2014 Maximum radial distance between all qubits.</p> </li> <li> <p>interactions \u2014 Interaction 1/r^6 between each qubit pair.</p> </li> <li> <p>draw \u2014 Draw the register.</p> </li> </ul> <p> source classmethod Register.from_graph(graph: DataGraph) \u2192 Register </p> <p>Initializes a Register from a graph that has coordinates.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 a DataGraph instance.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod Register.from_coordinates(coords: list) \u2192 Register </p> <p>Initializes a Register from a list of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list \u2014 a list of coordinates [(x, y), ...]</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source property Register.qubits: dict </p> <p>Returns the dictionary of qubits and respective coordinates.</p> <p> source property Register.qubits_ids: list </p> <p>Returns the qubit keys.</p> <p> source property Register.n_qubits: int </p> <p>Number of qubits in the Register.</p> <p> source method Register.distances() \u2192 dict </p> <p>Distance between each qubit pair.</p> <p> source method Register.min_distance() \u2192 float </p> <p>Minimum distance between all qubit pairs.</p> <p> source method Register.radial_distances() \u2192 dict </p> <p>Radial distance of each qubit from the origin.</p> <p> source method Register.max_radial_distance() \u2192 float </p> <p>Maximum radial distance between all qubits.</p> <p> source method Register.interactions() \u2192 dict </p> <p>Interaction 1/r^6 between each qubit pair.</p> <p> source method Register.draw(return_fig: bool = False) \u2192 plt.Figure | None </p> <p>Draw the register.</p> <p> Parameters </p> <ul> <li> <p>return_fig :  bool \u2014 boolean argument to return the plt.Figure instance.</p> </li> </ul> <p> source class QuantumProgram(register: Register, drive: Drive) </p> <p>A program representing a Sequence acting on a Register of qubits.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the register of qubits, defining their positions.</p> </li> <li> <p>drive :  Drive \u2014 the drive acting on qubits, defining amplitude, detuning and phase.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>register :  Register \u2014 The register of qubits.</p> </li> <li> <p>drive :  Drive \u2014 The driving waveforms.</p> </li> <li> <p>is_compiled :  bool \u2014 Check if the program has been compiled.</p> </li> <li> <p>compiled_sequence :  PulserSequence \u2014 The Pulser sequence compiled to a specific device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_to \u2014 Compiles the given program to a device.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property QuantumProgram.register: Register </p> <p>The register of qubits.</p> <p> source property QuantumProgram.drive: Drive </p> <p>The driving waveforms.</p> <p> source property QuantumProgram.is_compiled: bool </p> <p>Check if the program has been compiled.</p> <p> source property QuantumProgram.compiled_sequence: PulserSequence </p> <p>The Pulser sequence compiled to a specific device.</p> <p> source method QuantumProgram.compile_to(device: Device, profile: CompilerProfile = CompilerProfile.DEFAULT) \u2192 None </p> <p>Compiles the given program to a device.</p> <p> Parameters </p> <ul> <li> <p>device :  Device \u2014 the Device to compile to.</p> </li> <li> <p>profile :  CompilerProfile \u2014 the compiler profile to use during compilation.</p> </li> </ul> <p> source method QuantumProgram.draw(n_points: int = 500, compiled: bool = False, return_fig: bool = False) \u2192 Figure | None </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source enum CompilerProfile(*args, **kwds) </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>error</p> </li> <li> <p>CompilationError</p> </li> </ul> <p> source available_default_devices() \u2192 None </p> <p>Show the default available devices in QooQit.</p> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device for analog sequence execution.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class DigitalAnalogDevice() </p> <p>Bases : Device</p> <p>A device with digital and analog capabilities.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>A virtual device for unconstrained prototyping.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class Device(pulser_device: BaseDevice, default_converter: Optional[UnitConverter] = None) </p> <p>QoolQit Device wrapper around a Pulser BaseDevice.</p> <p> Parameters </p> <ul> <li> <p>pulser_device :  BaseDevice \u2014 a <code>BaseDevice</code> to build the QoolQit device from.</p> </li> <li> <p>default_converter :  Optional[UnitConverter] \u2014 optional unit converter to handle unit conversion. Defaults to the unit converter that rescales energies by the maximum allowed amplitude by the device.</p> </li> </ul> <p> Examples </p> <p>From Pulser device: <pre><code>qoolqit_device = Device(pulser_device=pulser_device)\n</code></pre></p> <p>From remote Pulser device: <pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit import Device\n\n# Fetch the remote device from the connection\nconnection = PasqalCloud()\npulser_fresnel_device = connection.fetch_available_devices()[\"FRESNEL\"]\n\n# Wrap a Pulser device object into a QoolQit Device\nfresnel_device = Device(pulser_device=PulserFresnelDevice)\n</code></pre></p> <p>From custom Pulser device: <pre><code>from dataclasses import replace\nfrom pulser import AnalogDevice\nfrom qoolqit import Device\n\n# Converting the pulser Device object in a VirtualDevice object\nVirtualAnalog = AnalogDevice.to_virtual()\n# Replacing desired values\nModdedAnalogDevice = replace(\n    VirtualAnalog,\n    max_radial_distance=100,\n    max_sequence_duration=7000\n    )\n\n# Wrap a Pulser device object into a QoolQit Device\nmod_analog_device = Device(pulser_device=ModdedAnalogDevice)\n</code></pre></p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>reset_converter \u2014 Resets the unit converter to the default one.</p> </li> <li> <p>set_time_unit \u2014 Changes the unit converter according to a reference time unit.</p> </li> <li> <p>set_energy_unit \u2014 Changes the unit converter according to a reference energy unit.</p> </li> <li> <p>set_distance_unit \u2014 Changes the unit converter according to a reference distance unit.</p> </li> <li> <p>info \u2014 Show the device short description and constrains.</p> </li> <li> <p>from_connection \u2014 Return the specified device from the selected device from a connection.</p> </li> </ul> <p> source property Device.converter: UnitConverter </p> <p> source method Device.reset_converter() \u2192 None </p> <p>Resets the unit converter to the default one.</p> <p> source method Device.set_time_unit(time: float) \u2192 None </p> <p>Changes the unit converter according to a reference time unit.</p> <p> source method Device.set_energy_unit(energy: float) \u2192 None </p> <p>Changes the unit converter according to a reference energy unit.</p> <p> source method Device.set_distance_unit(distance: float) \u2192 None </p> <p>Changes the unit converter according to a reference distance unit.</p> <p> source property Device.specs: dict[str, float | None] </p> <p>Return the device specification constrains.</p> <p> source property Device.energy_ratio: float | None </p> <p>Return the ratio between the max amplitude and max interaction energy on this device.</p> <p> source property Device.name: str </p> <p> source method Device.info() \u2192 None </p> <p>Show the device short description and constrains.</p> <p> source classmethod Device.from_connection(connection: RemoteConnection, name: str) \u2192 Device </p> <p>Return the specified device from the selected device from a connection.</p> <p>Available devices through the provided connection are can be seen with the <code>connection.fetch_available_devices()</code> method.</p> <p> Parameters </p> <ul> <li> <p>connection :  RemoteConnection \u2014 connection object to fetch the available devices.</p> </li> <li> <p>name :  str \u2014 The name of the desired device.</p> </li> </ul> <p> Example </p> <pre><code>fresnel_device = Device.from_connection(connection=PasqalCloud(), name=\"FRESNEL\")\n</code></pre> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/qoolqit/devices/","title":"qoolqit.devices","text":"qoolqit.devices<p> source package qoolqit.devices </p> <p> Classes </p> <ul> <li> <p>MockDevice \u2014 A virtual device for unconstrained prototyping.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device for analog sequence execution.</p> </li> <li> <p>DigitalAnalogDevice \u2014 A device with digital and analog capabilities.</p> </li> <li> <p>Device \u2014 QoolQit Device wrapper around a Pulser BaseDevice.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>available_default_devices \u2014 Show the default available devices in QooQit.</p> </li> </ul> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>A virtual device for unconstrained prototyping.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device for analog sequence execution.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class DigitalAnalogDevice() </p> <p>Bases : Device</p> <p>A device with digital and analog capabilities.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class Device(pulser_device: BaseDevice, default_converter: Optional[UnitConverter] = None) </p> <p>QoolQit Device wrapper around a Pulser BaseDevice.</p> <p> Parameters </p> <ul> <li> <p>pulser_device :  BaseDevice \u2014 a <code>BaseDevice</code> to build the QoolQit device from.</p> </li> <li> <p>default_converter :  Optional[UnitConverter] \u2014 optional unit converter to handle unit conversion. Defaults to the unit converter that rescales energies by the maximum allowed amplitude by the device.</p> </li> </ul> <p> Examples </p> <p>From Pulser device: <pre><code>qoolqit_device = Device(pulser_device=pulser_device)\n</code></pre></p> <p>From remote Pulser device: <pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit import Device\n\n# Fetch the remote device from the connection\nconnection = PasqalCloud()\npulser_fresnel_device = connection.fetch_available_devices()[\"FRESNEL\"]\n\n# Wrap a Pulser device object into a QoolQit Device\nfresnel_device = Device(pulser_device=PulserFresnelDevice)\n</code></pre></p> <p>From custom Pulser device: <pre><code>from dataclasses import replace\nfrom pulser import AnalogDevice\nfrom qoolqit import Device\n\n# Converting the pulser Device object in a VirtualDevice object\nVirtualAnalog = AnalogDevice.to_virtual()\n# Replacing desired values\nModdedAnalogDevice = replace(\n    VirtualAnalog,\n    max_radial_distance=100,\n    max_sequence_duration=7000\n    )\n\n# Wrap a Pulser device object into a QoolQit Device\nmod_analog_device = Device(pulser_device=ModdedAnalogDevice)\n</code></pre></p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>reset_converter \u2014 Resets the unit converter to the default one.</p> </li> <li> <p>set_time_unit \u2014 Changes the unit converter according to a reference time unit.</p> </li> <li> <p>set_energy_unit \u2014 Changes the unit converter according to a reference energy unit.</p> </li> <li> <p>set_distance_unit \u2014 Changes the unit converter according to a reference distance unit.</p> </li> <li> <p>info \u2014 Show the device short description and constrains.</p> </li> <li> <p>from_connection \u2014 Return the specified device from the selected device from a connection.</p> </li> </ul> <p> source property Device.converter: UnitConverter </p> <p> source method Device.reset_converter() \u2192 None </p> <p>Resets the unit converter to the default one.</p> <p> source method Device.set_time_unit(time: float) \u2192 None </p> <p>Changes the unit converter according to a reference time unit.</p> <p> source method Device.set_energy_unit(energy: float) \u2192 None </p> <p>Changes the unit converter according to a reference energy unit.</p> <p> source method Device.set_distance_unit(distance: float) \u2192 None </p> <p>Changes the unit converter according to a reference distance unit.</p> <p> source property Device.specs: dict[str, float | None] </p> <p>Return the device specification constrains.</p> <p> source property Device.energy_ratio: float | None </p> <p>Return the ratio between the max amplitude and max interaction energy on this device.</p> <p> source property Device.name: str </p> <p> source method Device.info() \u2192 None </p> <p>Show the device short description and constrains.</p> <p> source classmethod Device.from_connection(connection: RemoteConnection, name: str) \u2192 Device </p> <p>Return the specified device from the selected device from a connection.</p> <p>Available devices through the provided connection are can be seen with the <code>connection.fetch_available_devices()</code> method.</p> <p> Parameters </p> <ul> <li> <p>connection :  RemoteConnection \u2014 connection object to fetch the available devices.</p> </li> <li> <p>name :  str \u2014 The name of the desired device.</p> </li> </ul> <p> Example </p> <pre><code>fresnel_device = Device.from_connection(connection=PasqalCloud(), name=\"FRESNEL\")\n</code></pre> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source available_default_devices() \u2192 None </p> <p>Show the default available devices in QooQit.</p>"},{"location":"api/qoolqit/devices/device/","title":"qoolqit.devices.device","text":"qoolqit.devices.device<p> source module qoolqit.devices.device </p> <p> Classes </p> <ul> <li> <p>Device \u2014 QoolQit Device wrapper around a Pulser BaseDevice.</p> </li> <li> <p>MockDevice \u2014 A virtual device for unconstrained prototyping.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device for analog sequence execution.</p> </li> <li> <p>DigitalAnalogDevice \u2014 A device with digital and analog capabilities.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>available_default_devices \u2014 Show the default available devices in QooQit.</p> </li> </ul> <p> source class Device(pulser_device: BaseDevice, default_converter: Optional[UnitConverter] = None) </p> <p>QoolQit Device wrapper around a Pulser BaseDevice.</p> <p> Parameters </p> <ul> <li> <p>pulser_device :  BaseDevice \u2014 a <code>BaseDevice</code> to build the QoolQit device from.</p> </li> <li> <p>default_converter :  Optional[UnitConverter] \u2014 optional unit converter to handle unit conversion. Defaults to the unit converter that rescales energies by the maximum allowed amplitude by the device.</p> </li> </ul> <p> Examples </p> <p>From Pulser device: <pre><code>qoolqit_device = Device(pulser_device=pulser_device)\n</code></pre></p> <p>From remote Pulser device: <pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit import Device\n\n# Fetch the remote device from the connection\nconnection = PasqalCloud()\npulser_fresnel_device = connection.fetch_available_devices()[\"FRESNEL\"]\n\n# Wrap a Pulser device object into a QoolQit Device\nfresnel_device = Device(pulser_device=PulserFresnelDevice)\n</code></pre></p> <p>From custom Pulser device: <pre><code>from dataclasses import replace\nfrom pulser import AnalogDevice\nfrom qoolqit import Device\n\n# Converting the pulser Device object in a VirtualDevice object\nVirtualAnalog = AnalogDevice.to_virtual()\n# Replacing desired values\nModdedAnalogDevice = replace(\n    VirtualAnalog,\n    max_radial_distance=100,\n    max_sequence_duration=7000\n    )\n\n# Wrap a Pulser device object into a QoolQit Device\nmod_analog_device = Device(pulser_device=ModdedAnalogDevice)\n</code></pre></p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>reset_converter \u2014 Resets the unit converter to the default one.</p> </li> <li> <p>set_time_unit \u2014 Changes the unit converter according to a reference time unit.</p> </li> <li> <p>set_energy_unit \u2014 Changes the unit converter according to a reference energy unit.</p> </li> <li> <p>set_distance_unit \u2014 Changes the unit converter according to a reference distance unit.</p> </li> <li> <p>info \u2014 Show the device short description and constrains.</p> </li> <li> <p>from_connection \u2014 Return the specified device from the selected device from a connection.</p> </li> </ul> <p> source property Device.converter: UnitConverter </p> <p> source method Device.reset_converter() \u2192 None </p> <p>Resets the unit converter to the default one.</p> <p> source method Device.set_time_unit(time: float) \u2192 None </p> <p>Changes the unit converter according to a reference time unit.</p> <p> source method Device.set_energy_unit(energy: float) \u2192 None </p> <p>Changes the unit converter according to a reference energy unit.</p> <p> source method Device.set_distance_unit(distance: float) \u2192 None </p> <p>Changes the unit converter according to a reference distance unit.</p> <p> source property Device.specs: dict[str, float | None] </p> <p>Return the device specification constrains.</p> <p> source property Device.energy_ratio: float | None </p> <p>Return the ratio between the max amplitude and max interaction energy on this device.</p> <p> source property Device.name: str </p> <p> source method Device.info() \u2192 None </p> <p>Show the device short description and constrains.</p> <p> source classmethod Device.from_connection(connection: RemoteConnection, name: str) \u2192 Device </p> <p>Return the specified device from the selected device from a connection.</p> <p>Available devices through the provided connection are can be seen with the <code>connection.fetch_available_devices()</code> method.</p> <p> Parameters </p> <ul> <li> <p>connection :  RemoteConnection \u2014 connection object to fetch the available devices.</p> </li> <li> <p>name :  str \u2014 The name of the desired device.</p> </li> </ul> <p> Example </p> <pre><code>fresnel_device = Device.from_connection(connection=PasqalCloud(), name=\"FRESNEL\")\n</code></pre> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>A virtual device for unconstrained prototyping.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device for analog sequence execution.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source class DigitalAnalogDevice() </p> <p>Bases : Device</p> <p>A device with digital and analog capabilities.</p> <p> Attributes </p> <ul> <li> <p>specs :  dict[str, float | None] \u2014 Return the device specification constrains.</p> </li> <li> <p>energy_ratio :  float | None \u2014 Return the ratio between the max amplitude and max interaction energy on this device.</p> </li> </ul> <p> source available_default_devices() \u2192 None </p> <p>Show the default available devices in QooQit.</p>"},{"location":"api/qoolqit/devices/unit_converter/","title":"qoolqit.devices.unit_converter","text":"qoolqit.devices.unit_converter<p> source module qoolqit.devices.unit_converter </p> <p> Classes </p> <ul> <li> <p>UnitConverter \u2014 A dataclass representing a unit converter in the Rydberg-Analog model.</p> </li> </ul> <p> source dataclass UnitConverter(C6: float = field(repr=False), time: float, energy: float, distance: float) </p> <p>A dataclass representing a unit converter in the Rydberg-Analog model.</p> <p>Includes three inter-dependent factors for TIME, ENERGY and DISTANCE conversion, also depending on the interaction coefficient C6. The converter checks the following invariants, based on the units used by Pulser:</p> <p> Conversion invariants </p> <ol> <li>TIME * ENERGY = 1000 ( &lt;=&gt; TIME = 1000 / ENERGY )</li> <li>DISTANCE^6 * ENERGY = C6 ( &lt;=&gt; ENERGY = C6 / (DISTANCE ^ 6) )</li> </ol> <p> Attributes </p> <ul> <li> <p>C6 :  float \u2014 Time conversion factor.</p> </li> <li> <p>time :  float \u2014 Energy conversion factor.</p> </li> <li> <p>energy :  float \u2014 Distance conversion factor.</p> </li> <li> <p>factors :  tuple[float, ...] \u2014 Return the current conversion factors set.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_factors \u2014 Returns True if the conversion invariants are respected.</p> </li> <li> <p>from_time \u2014 Instantiate from a reference C6 value and a reference time unit.</p> </li> <li> <p>from_energy \u2014 Instantiate from a reference C6 value and a reference energy unit.</p> </li> <li> <p>from_distance \u2014 Instantiate from a reference C6 value and a reference distance unit.</p> </li> <li> <p>factors_from_time \u2014 Get factors from a different reference time than the one set.</p> </li> <li> <p>factors_from_energy \u2014 Get factors from a different reference energy than the one set.</p> </li> <li> <p>factors_from_distance \u2014 Get factors from a different reference distance than the one set.</p> </li> </ul> <p> source method UnitConverter.validate_factors(time: float, energy: float, distance: float) \u2192 bool </p> <p>Returns True if the conversion invariants are respected.</p> <p> source classmethod UnitConverter.from_time(C6: float, time: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference time unit.</p> <p> source classmethod UnitConverter.from_energy(C6: float, energy: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference energy unit.</p> <p> source classmethod UnitConverter.from_distance(C6: float, distance: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference distance unit.</p> <p> source property UnitConverter.factors: tuple[float, ...] </p> <p>Return the current conversion factors set.</p> <p> source method UnitConverter.factors_from_time(time: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference time than the one set.</p> <p> source method UnitConverter.factors_from_energy(energy: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference energy than the one set.</p> <p> source method UnitConverter.factors_from_distance(distance: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference distance than the one set.</p>"},{"location":"api/qoolqit/embedding/","title":"qoolqit.embedding","text":"qoolqit.embedding<p> source package qoolqit.embedding </p> <p> Classes </p> <ul> <li> <p>BaseEmbedder \u2014 Abstract base class for all embedders.</p> </li> <li> <p>EmbeddingConfig \u2014 Base abstract dataclass for all embedding algorithm configurations.</p> </li> <li> <p>GraphToGraphEmbedder \u2014 A family of embedders that map a graph to a graph.</p> </li> <li> <p>MatrixToGraphEmbedder \u2014 A family of embedders that map a matrix to a graph.</p> </li> <li> <p>InteractionEmbeddingConfig \u2014 Configuration parameters for the interaction embedding.</p> </li> <li> <p>InteractionEmbedder \u2014 A matrix to graph embedder using the interaction embedding algorithm.</p> </li> <li> <p>SpringLayoutConfig \u2014 Configuration parameters for the spring-layout embedding.</p> </li> <li> <p>SpringLayoutEmbedder \u2014 A graph to graph embedder using the spring layout algorithm.</p> </li> <li> <p>BladeConfig \u2014 Configuration parameters to embed with BLaDE.</p> </li> <li> <p>Blade \u2014 A matrix to graph embedder using the BLaDE algorithm.</p> </li> </ul> <p> source class BaseEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : ABC, Generic[InDataType, OutDataType, ConfigType]</p> <p>Abstract base class for all embedders.</p> <p>An embedder is a function that maps a InDataType to an OutDataType through an embedding algorithm. Parameters of the embedding algorithm can be customized through the EmbeddingConfig.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input \u2014 Checks if the given data is compatible with the embedder.</p> </li> <li> <p>validate_output \u2014 Checks if the resulting output is expected by the embedder.</p> </li> <li> <p>embed \u2014 Validates the input, runs the embedding algorithm, and validates the output.</p> </li> </ul> <p> source property BaseEmbedder.config: ConfigType </p> <p>Returns the config for the embedding algorithm.</p> <p> source property BaseEmbedder.algorithm: Callable </p> <p>Returns the callable to the embedding algorithm.</p> <p> source property BaseEmbedder.info: str </p> <p>Prints info about the embedding algorithm.</p> <p> source method BaseEmbedder.validate_input(data: InDataType) \u2192 None </p> <p>Checks if the given data is compatible with the embedder.</p> <p>Each embedder should write its own data validator. If the data is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the data is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.validate_output(result: OutDataType) \u2192 None </p> <p>Checks if the resulting output is expected by the embedder.</p> <p>Each embedder should write its own output validator. If the result is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>result :  OutDataType \u2014 the output to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the output is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.embed(data: InDataType) \u2192 OutDataType </p> <p>Validates the input, runs the embedding algorithm, and validates the output.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to embed.</p> </li> </ul> <p> source dataclass EmbeddingConfig() </p> <p>Bases : ABC</p> <p>Base abstract dataclass for all embedding algorithm configurations.</p> <p>Subclasses define parameters specific to their algorithms. Each config should define fields that directly translate to arguments in the respective embedding function it configures.</p> <p> Methods </p> <ul> <li> <p>dict \u2014 Returns the dataclass as a dictionary.</p> </li> </ul> <p> source method EmbeddingConfig.dict() \u2192 dict </p> <p>Returns the dataclass as a dictionary.</p> <p> source class GraphToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[DataGraph, DataGraph, ConfigType]</p> <p>A family of embedders that map a graph to a graph.</p> <p>Focused on unit-disk graph embedding, where the goal is to find a set of coordinates for a graph that has no coordinates, such that the final unit-disk edges matches the set of edges in the original graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_input(data: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source class MatrixToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[np.ndarray, DataGraph, ConfigType]</p> <p>A family of embedders that map a matrix to a graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_input(data: np.ndarray) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source dataclass InteractionEmbeddingConfig(method: str = 'Nelder-Mead', maxiter: int = 200000, tol: float = 1e-08) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the interaction embedding.</p> <p> source class InteractionEmbedder() </p> <p>Bases : MatrixToGraphEmbedder[InteractionEmbeddingConfig]</p> <p>A matrix to graph embedder using the interaction embedding algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source dataclass SpringLayoutConfig(k: float | None = None, iterations: int = 50, threshold: float = 0.0001, seed: int | None = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the spring-layout embedding.</p> <p> source class SpringLayoutEmbedder() </p> <p>Bases : GraphToGraphEmbedder[SpringLayoutConfig]</p> <p>A graph to graph embedder using the spring layout algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source dataclass BladeConfig(max_min_dist_ratio: float | None = None, dimensions: tuple[int, ...] = (5, 4, 3, 2, 2, 2), starting_positions: np.ndarray | None = None, pca: bool = False, steps_per_round: int = 200, compute_weight_relative_threshold: Callable[[float], float] = lambda _: 0.1, compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]] = lambda x, max_radial_dist: np.inf, starting_ratio_factor: int = 2, draw_steps: bool | list[int] = False, device: InitVar[Device | None] = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters to embed with BLaDE.</p> <p> source class Blade(config: BladeConfig = BladeConfig()) </p> <p>Bases : MatrixToGraphEmbedder[BladeConfig]</p> <p>A matrix to graph embedder using the BLaDE algorithm.</p> <p>Inits Blade.</p> <p> Parameters </p> <ul> <li> <p>config :  BladeConfig \u2014 configuration object for the BLaDE algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>embed \u2014 Return a DataGraph with coordinates that embeds the input matrix.</p> </li> </ul> <p> source method Blade.embed(data: np.ndarray) \u2192 DataGraph </p> <p>Return a DataGraph with coordinates that embeds the input matrix.</p> <p>Validates the input, runs the embedding algorithm, and validates the output.</p> <p> Parameters </p> <ul> <li> <p>data :  np.ndarray \u2014 the matrix to embed into a DataGraph with coordinates.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/algorithms/","title":"qoolqit.embedding.algorithms","text":"qoolqit.embedding.algorithms<p> source package qoolqit.embedding.algorithms </p> <p> Classes </p> <ul> <li> <p>BladeConfig \u2014 Configuration parameters to embed with BLaDE.</p> </li> <li> <p>InteractionEmbeddingConfig \u2014 Configuration parameters for the interaction embedding.</p> </li> <li> <p>SpringLayoutConfig \u2014 Configuration parameters for the spring-layout embedding.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>interaction_embedding \u2014 Matrix embedding into the interaction term of the Rydberg Analog Model.</p> </li> <li> <p>spring_layout_embedding \u2014 Force-directed embedding, wrapping nx.spring_layout.</p> </li> </ul> <p> Modules </p> <ul> <li> <p>blade</p> </li> </ul> <p> source dataclass BladeConfig(max_min_dist_ratio: float | None = None, dimensions: tuple[int, ...] = (5, 4, 3, 2, 2, 2), starting_positions: np.ndarray | None = None, pca: bool = False, steps_per_round: int = 200, compute_weight_relative_threshold: Callable[[float], float] = lambda _: 0.1, compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]] = lambda x, max_radial_dist: np.inf, starting_ratio_factor: int = 2, draw_steps: bool | list[int] = False, device: InitVar[Device | None] = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters to embed with BLaDE.</p> <p> source module blade </p> <p> source dataclass InteractionEmbeddingConfig(method: str = 'Nelder-Mead', maxiter: int = 200000, tol: float = 1e-08) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the interaction embedding.</p> <p> source interaction_embedding(matrix: np.ndarray, method: str, maxiter: int, tol: float) \u2192 np.ndarray </p> <p>Matrix embedding into the interaction term of the Rydberg Analog Model.</p> <p>Uses scipy.minimize to find the optimal set of node coordinates such that the matrix of values 1/(r_ij)^6 approximate the off-diagonal terms of the input matrix.</p> <p> Check the documentation for scipy.minimize for more information about each parameter </p> <p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</p> <p> Parameters </p> <ul> <li> <p>matrix :  np.ndarray \u2014 the matrix to embed.</p> </li> <li> <p>method :  str \u2014 the method used by scipy.minimize.</p> </li> <li> <p>maxiter :  int \u2014 maximum number of iterations.</p> </li> <li> <p>tol :  float \u2014 tolerance for termination.</p> </li> </ul> <p> source dataclass SpringLayoutConfig(k: float | None = None, iterations: int = 50, threshold: float = 0.0001, seed: int | None = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the spring-layout embedding.</p> <p> source spring_layout_embedding(graph: DataGraph, k: float | None, iterations: int, threshold: float, seed: int | None) \u2192 DataGraph </p> <p>Force-directed embedding, wrapping nx.spring_layout.</p> <p>Generates a graph with the same nodes and edges as the original graph, but with node coordinates set to be the positions given by nx.spring_layout.</p> <p> Check the documentation for nx.spring_layout for more information about each parameter </p> <p>https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 the graph to embed.</p> </li> <li> <p>k :  float | None \u2014 optimal distance between nodes.</p> </li> <li> <p>iterations :  int \u2014 maximum number of iterations to take.</p> </li> <li> <p>threshold :  float \u2014 threshold value for relative error in node position changes.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/algorithms/blade/","title":"qoolqit.embedding.algorithms.blade","text":"qoolqit.embedding.algorithms.blade<p> source package qoolqit.embedding.algorithms.blade </p> <p> Classes </p> <ul> <li> <p>BladeConfig \u2014 Configuration parameters to embed with BLaDE.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>blade \u2014 Embed an interaction matrix or QUBO with the BLaDE algorithm.</p> </li> </ul> <p> source dataclass BladeConfig(max_min_dist_ratio: float | None = None, dimensions: tuple[int, ...] = (5, 4, 3, 2, 2, 2), starting_positions: np.ndarray | None = None, pca: bool = False, steps_per_round: int = 200, compute_weight_relative_threshold: Callable[[float], float] = lambda _: 0.1, compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]] = lambda x, max_radial_dist: np.inf, starting_ratio_factor: int = 2, draw_steps: bool | list[int] = False, device: InitVar[Device | None] = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters to embed with BLaDE.</p> <p> source blade(matrix: np.ndarray, *, max_min_dist_ratio: float | None = None, dimensions: tuple[int, ...] = (5, 4, 3, 2, 2, 2), starting_positions: np.ndarray | None = None, pca: bool = False, steps_per_round: int = 200, compute_weight_relative_threshold: Callable[[float], float] = lambda _: 0.1, compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]] = lambda x, max_radial_dist: np.inf, starting_ratio_factor: int = 2, draw_steps: bool | list[int] = False) \u2192 np.ndarray </p> <p>Embed an interaction matrix or QUBO with the BLaDE algorithm.</p> <p>BLaDE stands for Balanced Latently Dimensional Embedder. It compute positions for nodes so that their interactions approach the desired values. The interactions assume that the interaction coefficient of the device is set to 1. Its prior target is on interaction matrices or QUBOs, but it can also be used for MIS with limitations if the adjacency matrix is converted into a QUBO. The general principle is based on the Fruchterman-Reingold algorithm.</p> <p>matrix: an objective interaction matrix or QUBO. max_min_dist_ratio: If present, set the maximum ratio between     the maximum radial distance and the minimum pairwise distances. dimensions: List of numbers of dimensions to explore one     after the other. A list with one value is equivalent to a list containing     twice the same value. For a 2D embedding, the last value should be 2.     Increasing the number of intermediate dimensions can help to escape     from local minima. starting_positions: If provided, initial positions to start from. Otherwise,     random positions will be generated. pca: Whether to apply Principal Component Analysis to prioritize dimensions     to keep when transitioning from a space to a space with fewer dimensions.     It is disabled by default because it can raise an error when there are     too many dimensions compared to the number of nodes. steps_per_round: Number of elementary steps to perform for each dimension     transition, where at each step move vectors are computed and applied     on the nodes. compute_weight_relative_threshold: Function that is called at each step.     It takes a float number between 0 and 1 that represents the progress     on the steps. It must return a float number between 0 and 1 that gives     a threshold determining which weights are significant (see     <code>update_positions</code> to learn more). compute_max_distance_to_walk: Function that is called at each step.     It takes a float number between 0 and 1 that represents the progress     on the steps, and takes another argument that is set to <code>None</code> when     <code>max_min_dist_ratio</code> is not enabled, otherwise, it is set to     the maximum radial distance for the current step.     It must return a float number that limits the distances     nodes can move at one step  (see <code>update_positions</code> to learn more). starting_ratio_factor: When <code>max_min_dist_ratio</code> is enabled,     defines a multiplying factor on the target ratio to start the evolution     on a larger ratio, to let more flexibility in the beginning. draw_steps: Whether to draw the nodes and the forces.     Requires installing the seaborn library.</p>"},{"location":"api/qoolqit/embedding/algorithms/blade/blade/","title":"qoolqit.embedding.algorithms.blade.blade","text":"qoolqit.embedding.algorithms.blade.blade<p> source module qoolqit.embedding.algorithms.blade.blade </p> <p> Classes </p> <ul> <li> <p>BladeConfig \u2014 Configuration parameters to embed with BLaDE.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>update_positions \u2014 Compute vector moves to adjust node positions toward target interactions.</p> </li> <li> <p>evolve_with_forces_through_dim_change</p> </li> <li> <p>generate_random_positions</p> </li> <li> <p>evolve_with_dimension_transition</p> </li> <li> <p>blade \u2014 Embed an interaction matrix or QUBO with the BLaDE algorithm.</p> </li> </ul> <p> source update_positions(*, positions: np.ndarray, qubo_graph: nx.Graph, weight_relative_threshold: float = 0.0, min_dist: float | None = None, max_dist: float | None = None, max_distance_to_walk: float | tuple[float, float, float] = np.inf, draw_step: bool = False) \u2192 np.ndarray </p> <p>Compute vector moves to adjust node positions toward target interactions.</p> <p>positions: Starting positions of the nodes. qubo_graph: Desired QUBO. weight_relative_threshold: It is used to compute a weight difference     threshold defining which weights differences are significant and should     be considered. For this purpose, it is multiplied by the higher weight difference.     It is also used to reduce the precision when targeting     the objective weights. min_dist: If set, defined the minimum distance that should be met, and     creates forces to enforce the constraint. max_dist: If set, defined the maximum distance that should be met, and     creates forces to enforce the constraint. max_distance_to_walk: It set, limits the distance that nodes can walk     when the forces are applied. It impacts the priorities     of the forces because they only consider the slope of the differences     in weights that can be targeting with this ceiling. draw_steps: Whether to draw the nodes and the forces.</p> <p> source evolve_with_forces_through_dim_change(*, qubo_graph: nx.Graph, draw_steps: bool = False, starting_dimensions: int, final_dimensions: int, nb_steps: int, positions: np.ndarray, starting_min: float | None = None, start_ratio: float | None = None, final_ratio: float | None = None, compute_weight_relative_threshold_by_step: Callable[[int], float], compute_max_distance_to_walk_by_step: Callable[[int, float | None], float | tuple[float, float, float]]) \u2192 tuple[np.ndarray, float | None] </p> <p> source generate_random_positions(qubo: np.ndarray, dimension: int) \u2192 np.ndarray </p> <p> source evolve_with_dimension_transition(qubo: np.ndarray, *, dimensions: tuple[int, ...], starting_min: float | None, pca: bool, steps_per_round: int, compute_weight_relative_threshold: Callable[[float], float], compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]], qubo_graph: nx.Graph, positions: np.ndarray, final_ratio: float | None, total_steps: int, dim_idx: int, start_ratio: float | None, draw_steps: bool | list[int]) \u2192 tuple[np.ndarray, float | None] </p> <p> Raises </p> <ul> <li> <p>ModuleNotFoundError</p> </li> </ul> <p> source blade(matrix: np.ndarray, *, max_min_dist_ratio: float | None = None, dimensions: tuple[int, ...] = (5, 4, 3, 2, 2, 2), starting_positions: np.ndarray | None = None, pca: bool = False, steps_per_round: int = 200, compute_weight_relative_threshold: Callable[[float], float] = lambda _: 0.1, compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]] = lambda x, max_radial_dist: np.inf, starting_ratio_factor: int = 2, draw_steps: bool | list[int] = False) \u2192 np.ndarray </p> <p>Embed an interaction matrix or QUBO with the BLaDE algorithm.</p> <p>BLaDE stands for Balanced Latently Dimensional Embedder. It compute positions for nodes so that their interactions approach the desired values. The interactions assume that the interaction coefficient of the device is set to 1. Its prior target is on interaction matrices or QUBOs, but it can also be used for MIS with limitations if the adjacency matrix is converted into a QUBO. The general principle is based on the Fruchterman-Reingold algorithm.</p> <p>matrix: an objective interaction matrix or QUBO. max_min_dist_ratio: If present, set the maximum ratio between     the maximum radial distance and the minimum pairwise distances. dimensions: List of numbers of dimensions to explore one     after the other. A list with one value is equivalent to a list containing     twice the same value. For a 2D embedding, the last value should be 2.     Increasing the number of intermediate dimensions can help to escape     from local minima. starting_positions: If provided, initial positions to start from. Otherwise,     random positions will be generated. pca: Whether to apply Principal Component Analysis to prioritize dimensions     to keep when transitioning from a space to a space with fewer dimensions.     It is disabled by default because it can raise an error when there are     too many dimensions compared to the number of nodes. steps_per_round: Number of elementary steps to perform for each dimension     transition, where at each step move vectors are computed and applied     on the nodes. compute_weight_relative_threshold: Function that is called at each step.     It takes a float number between 0 and 1 that represents the progress     on the steps. It must return a float number between 0 and 1 that gives     a threshold determining which weights are significant (see     <code>update_positions</code> to learn more). compute_max_distance_to_walk: Function that is called at each step.     It takes a float number between 0 and 1 that represents the progress     on the steps, and takes another argument that is set to <code>None</code> when     <code>max_min_dist_ratio</code> is not enabled, otherwise, it is set to     the maximum radial distance for the current step.     It must return a float number that limits the distances     nodes can move at one step  (see <code>update_positions</code> to learn more). starting_ratio_factor: When <code>max_min_dist_ratio</code> is enabled,     defines a multiplying factor on the target ratio to start the evolution     on a larger ratio, to let more flexibility in the beginning. draw_steps: Whether to draw the nodes and the forces.     Requires installing the seaborn library.</p> <p> source dataclass BladeConfig(max_min_dist_ratio: float | None = None, dimensions: tuple[int, ...] = (5, 4, 3, 2, 2, 2), starting_positions: np.ndarray | None = None, pca: bool = False, steps_per_round: int = 200, compute_weight_relative_threshold: Callable[[float], float] = lambda _: 0.1, compute_max_distance_to_walk: Callable[[float, float | None], float | tuple[float, float, float]] = lambda x, max_radial_dist: np.inf, starting_ratio_factor: int = 2, draw_steps: bool | list[int] = False, device: InitVar[Device | None] = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters to embed with BLaDE.</p>"},{"location":"api/qoolqit/embedding/algorithms/blade/drawing/","title":"qoolqit.embedding.algorithms.blade.drawing","text":"qoolqit.embedding.algorithms.blade.drawing<p> source module qoolqit.embedding.algorithms.blade.drawing </p> <p> Functions </p> <ul> <li> <p>eformat</p> </li> <li> <p>draw_weighted_graph</p> </li> <li> <p>draw_set_graph_coords \u2014 Coords are positions in numerical order of the nodes.</p> </li> <li> <p>draw_graph_including_actual_weights</p> </li> <li> <p>plot_differences</p> </li> <li> <p>draw_update_positions_step</p> </li> </ul> <p> source eformat(f: Any) \u2192 str </p> <p> source draw_weighted_graph(graph: nx.Graph, thresholds: tuple[float, float, float] = (0.0, 0.3, 0.6), edge_labels: dict | None = None, ax: Axes | None = None) \u2192 None </p> <p> source draw_set_graph_coords(graph: nx.Graph, coords: np.ndarray, edge_labels: dict | None = None) \u2192 None </p> <p>Coords are positions in numerical order of the nodes.</p> <p> source draw_graph_including_actual_weights(qubo_graph: nx.Graph, positions: np.ndarray) \u2192 None </p> <p> Raises </p> <ul> <li> <p>ModuleNotFoundError</p> </li> </ul> <p> source plot_differences(target_qubo: np.ndarray, differences: np.ndarray) \u2192 None </p> <p> Raises </p> <ul> <li> <p>ModuleNotFoundError</p> </li> </ul> <p> source draw_update_positions_step(positions: np.ndarray, interaction_resulting_forces: np.ndarray, min_constr_resulting_forces: np.ndarray, max_constr_resulting_forces: np.ndarray, resulting_forces_vectors: np.ndarray, max_dist: float | None) \u2192 None </p>"},{"location":"api/qoolqit/embedding/algorithms/interaction_embedding/","title":"qoolqit.embedding.algorithms.interaction_embedding","text":"qoolqit.embedding.algorithms.interaction_embedding<p> source module qoolqit.embedding.algorithms.interaction_embedding </p> <p> Classes </p> <ul> <li> <p>InteractionEmbeddingConfig \u2014 Configuration parameters for the interaction embedding.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>interaction_embedding \u2014 Matrix embedding into the interaction term of the Rydberg Analog Model.</p> </li> </ul> <p> source dataclass InteractionEmbeddingConfig(method: str = 'Nelder-Mead', maxiter: int = 200000, tol: float = 1e-08) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the interaction embedding.</p> <p> source interaction_embedding(matrix: np.ndarray, method: str, maxiter: int, tol: float) \u2192 np.ndarray </p> <p>Matrix embedding into the interaction term of the Rydberg Analog Model.</p> <p>Uses scipy.minimize to find the optimal set of node coordinates such that the matrix of values 1/(r_ij)^6 approximate the off-diagonal terms of the input matrix.</p> <p> Check the documentation for scipy.minimize for more information about each parameter </p> <p>https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html</p> <p> Parameters </p> <ul> <li> <p>matrix :  np.ndarray \u2014 the matrix to embed.</p> </li> <li> <p>method :  str \u2014 the method used by scipy.minimize.</p> </li> <li> <p>maxiter :  int \u2014 maximum number of iterations.</p> </li> <li> <p>tol :  float \u2014 tolerance for termination.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/algorithms/spring_layout_embedding/","title":"qoolqit.embedding.algorithms.spring_layout_embedding","text":"qoolqit.embedding.algorithms.spring_layout_embedding<p> source module qoolqit.embedding.algorithms.spring_layout_embedding </p> <p> Classes </p> <ul> <li> <p>SpringLayoutConfig \u2014 Configuration parameters for the spring-layout embedding.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>spring_layout_embedding \u2014 Force-directed embedding, wrapping nx.spring_layout.</p> </li> </ul> <p> source dataclass SpringLayoutConfig(k: float | None = None, iterations: int = 50, threshold: float = 0.0001, seed: int | None = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the spring-layout embedding.</p> <p> source spring_layout_embedding(graph: DataGraph, k: float | None, iterations: int, threshold: float, seed: int | None) \u2192 DataGraph </p> <p>Force-directed embedding, wrapping nx.spring_layout.</p> <p>Generates a graph with the same nodes and edges as the original graph, but with node coordinates set to be the positions given by nx.spring_layout.</p> <p> Check the documentation for nx.spring_layout for more information about each parameter </p> <p>https://networkx.org/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 the graph to embed.</p> </li> <li> <p>k :  float | None \u2014 optimal distance between nodes.</p> </li> <li> <p>iterations :  int \u2014 maximum number of iterations to take.</p> </li> <li> <p>threshold :  float \u2014 threshold value for relative error in node position changes.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/base_embedder/","title":"qoolqit.embedding.base_embedder","text":"qoolqit.embedding.base_embedder<p> source module qoolqit.embedding.base_embedder </p> <p> Classes </p> <ul> <li> <p>EmbeddingConfig \u2014 Base abstract dataclass for all embedding algorithm configurations.</p> </li> <li> <p>BaseEmbedder \u2014 Abstract base class for all embedders.</p> </li> </ul> <p> source dataclass EmbeddingConfig() </p> <p>Bases : ABC</p> <p>Base abstract dataclass for all embedding algorithm configurations.</p> <p>Subclasses define parameters specific to their algorithms. Each config should define fields that directly translate to arguments in the respective embedding function it configures.</p> <p> Methods </p> <ul> <li> <p>dict \u2014 Returns the dataclass as a dictionary.</p> </li> </ul> <p> source method EmbeddingConfig.dict() \u2192 dict </p> <p>Returns the dataclass as a dictionary.</p> <p> source class BaseEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : ABC, Generic[InDataType, OutDataType, ConfigType]</p> <p>Abstract base class for all embedders.</p> <p>An embedder is a function that maps a InDataType to an OutDataType through an embedding algorithm. Parameters of the embedding algorithm can be customized through the EmbeddingConfig.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input \u2014 Checks if the given data is compatible with the embedder.</p> </li> <li> <p>validate_output \u2014 Checks if the resulting output is expected by the embedder.</p> </li> <li> <p>embed \u2014 Validates the input, runs the embedding algorithm, and validates the output.</p> </li> </ul> <p> source property BaseEmbedder.config: ConfigType </p> <p>Returns the config for the embedding algorithm.</p> <p> source property BaseEmbedder.algorithm: Callable </p> <p>Returns the callable to the embedding algorithm.</p> <p> source property BaseEmbedder.info: str </p> <p>Prints info about the embedding algorithm.</p> <p> source method BaseEmbedder.validate_input(data: InDataType) \u2192 None </p> <p>Checks if the given data is compatible with the embedder.</p> <p>Each embedder should write its own data validator. If the data is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the data is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.validate_output(result: OutDataType) \u2192 None </p> <p>Checks if the resulting output is expected by the embedder.</p> <p>Each embedder should write its own output validator. If the result is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>result :  OutDataType \u2014 the output to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the output is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.embed(data: InDataType) \u2192 OutDataType </p> <p>Validates the input, runs the embedding algorithm, and validates the output.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to embed.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/graph_embedder/","title":"qoolqit.embedding.graph_embedder","text":"qoolqit.embedding.graph_embedder<p> source module qoolqit.embedding.graph_embedder </p> <p> Classes </p> <ul> <li> <p>GraphToGraphEmbedder \u2014 A family of embedders that map a graph to a graph.</p> </li> <li> <p>SpringLayoutEmbedder \u2014 A graph to graph embedder using the spring layout algorithm.</p> </li> </ul> <p> source class GraphToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[DataGraph, DataGraph, ConfigType]</p> <p>A family of embedders that map a graph to a graph.</p> <p>Focused on unit-disk graph embedding, where the goal is to find a set of coordinates for a graph that has no coordinates, such that the final unit-disk edges matches the set of edges in the original graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_input(data: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source class SpringLayoutEmbedder() </p> <p>Bases : GraphToGraphEmbedder[SpringLayoutConfig]</p> <p>A graph to graph embedder using the spring layout algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/matrix_embedder/","title":"qoolqit.embedding.matrix_embedder","text":"qoolqit.embedding.matrix_embedder<p> source module qoolqit.embedding.matrix_embedder </p> <p> Classes </p> <ul> <li> <p>MatrixToGraphEmbedder \u2014 A family of embedders that map a matrix to a graph.</p> </li> <li> <p>InteractionEmbedder \u2014 A matrix to graph embedder using the interaction embedding algorithm.</p> </li> <li> <p>Blade \u2014 A matrix to graph embedder using the BLaDE algorithm.</p> </li> </ul> <p> source class MatrixToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[np.ndarray, DataGraph, ConfigType]</p> <p>A family of embedders that map a matrix to a graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_input(data: np.ndarray) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source class InteractionEmbedder() </p> <p>Bases : MatrixToGraphEmbedder[InteractionEmbeddingConfig]</p> <p>A matrix to graph embedder using the interaction embedding algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source class Blade(config: BladeConfig = BladeConfig()) </p> <p>Bases : MatrixToGraphEmbedder[BladeConfig]</p> <p>A matrix to graph embedder using the BLaDE algorithm.</p> <p>Inits Blade.</p> <p> Parameters </p> <ul> <li> <p>config :  BladeConfig \u2014 configuration object for the BLaDE algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>embed \u2014 Return a DataGraph with coordinates that embeds the input matrix.</p> </li> </ul> <p> source method Blade.embed(data: np.ndarray) \u2192 DataGraph </p> <p>Return a DataGraph with coordinates that embeds the input matrix.</p> <p>Validates the input, runs the embedding algorithm, and validates the output.</p> <p> Parameters </p> <ul> <li> <p>data :  np.ndarray \u2014 the matrix to embed into a DataGraph with coordinates.</p> </li> </ul>"},{"location":"api/qoolqit/execution/","title":"qoolqit.execution","text":"qoolqit.execution<p> source package qoolqit.execution </p> <p> Classes </p> <ul> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> <li> <p>CompilerProfile</p> </li> <li> <p>LocalEmulator \u2014 Run QoolQit <code>QuantumProgram</code>s on a Pasqal local emulator backends.</p> </li> <li> <p>RemoteEmulator \u2014 Run QoolQit <code>QuantumProgram</code>s on a Pasqal remote emulator backends.</p> </li> <li> <p>QPU \u2014 Run QoolQit <code>QuantumProgram</code>s on a Pasqal QPU.</p> </li> <li> <p>EmulationConfig \u2014 Configures an emulation on a backend.</p> </li> <li> <p>BitStrings \u2014 Stores bitstrings sampled from the state at the evaluation times.</p> </li> <li> <p>CorrelationMatrix \u2014 Stores the correlation matrix for the current state.</p> </li> <li> <p>Energy \u2014 Stores the energy of the system at the evaluation times.</p> </li> <li> <p>EnergySecondMoment \u2014 Stores the expectation value of <code>H(t)^2</code> at the evaluation times.</p> </li> <li> <p>EnergyVariance \u2014 Stores the variance of the Hamiltonian at the evaluation times.</p> </li> <li> <p>Expectation \u2014 Stores the expectation of the given operator on the current state.</p> </li> <li> <p>Fidelity \u2014 Stores the fidelity with a pure state at the evaluation times.</p> </li> <li> <p>Occupation \u2014 Stores the occupation number of an eigenstate on each qudit.</p> </li> <li> <p>StateResult \u2014 Stores the quantum state at the evaluation times.</p> </li> <li> <p>Results \u2014 A collection of results.</p> </li> <li> <p>RemoteResults \u2014 A collection of results obtained through a remote connection.</p> </li> </ul> <p> Modules </p> <ul> <li> <p>BackendType \u2014 A module gathering all available backends.</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>error</p> </li> <li> <p>CompilationError</p> </li> </ul> <p> source enum CompilerProfile(*args, **kwds) </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul> <p> source class LocalEmulator(*, backend_type: type[EmulatorBackend] = QutipBackendV2, emulation_config: Optional[EmulationConfig] = None, runs: int = 100) </p> <p>Bases : PulserEmulatorBackend</p> <p>Run QoolQit <code>QuantumProgram</code>s on a Pasqal local emulator backends.</p> <p>This class serves as a primary interface between tools written using QoolQit (including solvers) and local emulator backends.</p> <p> Parameters </p> <ul> <li> <p>backend_type :  type \u2014 backend type. Must be a subtype of <code>pulser.backend.EmulatorBackend</code>.</p> </li> <li> <p>emulation_config :  EmulationConfig \u2014 optional configuration object emulators.</p> </li> <li> <p>runs :  int \u2014 number of bitstring samples to collect from the final quantum state. It emulates running the program <code>runs</code> times to collect bitstrings statistics.</p> </li> </ul> <p> Examples </p> <pre><code>from qoolqit.execution import LocalEmulator, BackendType\nbackend = LocalEmulator(backend_type=BackendType.QutipBackendV2)\nresult = backend.run(program)\n</code></pre> <p> Methods </p> <ul> <li> <p>run \u2014 Run a compiled QuantumProgram and return the results.</p> </li> </ul> <p> source method LocalEmulator.run(program: QuantumProgram) \u2192 Sequence[Results] </p> <p>Run a compiled QuantumProgram and return the results.</p> <p> source class RemoteEmulator(*, backend_type: type[RemoteEmulatorBackend] = EmuFreeBackendV2, connection: RemoteConnection, emulation_config: Optional[EmulationConfig] = None, runs: int = 100) </p> <p>Bases : PulserEmulatorBackend, PulserRemoteBackend</p> <p>Run QoolQit <code>QuantumProgram</code>s on a Pasqal remote emulator backends.</p> <p>This class serves as a primary interface between tools written using QoolQit (including solvers) and remote emulator backends. The behavior is similar to <code>LocalEmulator</code>, but here, requires credentials through a <code>connection</code> to submit/run a program. To get your credentials and to create a connection object, please refer to the Pasqal Cloud interface documentation.</p> <p> Parameters </p> <ul> <li> <p>backend_type :  type \u2014 backend type. Must be a subtype of <code>pulser_pasqal.backends.RemoteEmulatorBackend</code>.</p> </li> <li> <p>connection :  RemoteConnection \u2014 connection to execute the program on remote backends.</p> </li> <li> <p>emulation_config :  EmulationConfig \u2014 optional configuration object emulators.</p> </li> <li> <p>runs :  int \u2014 number of bitstring samples to collect from the final quantum state. It emulates running the program <code>runs</code> times to collect bitstrings statistics.</p> </li> </ul> <p> Examples </p> <p><pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit.execution import RemoteEmulator, BackendType\nconnection = PasqalCloud(username=..., password=..., project_id=...)\nbackend = RemoteEmulator(backend_type=BackendType.EmuFreeBackendV2, connection=connection)\n</code></pre> then <pre><code>remote_results = backend.submit(program)\n</code></pre> or <pre><code>results = backend.run(program)\n</code></pre></p> <p> Methods </p> <ul> <li> <p>submit \u2014 Submit a compiled QuantumProgram and return a remote handler of the results.</p> </li> <li> <p>run \u2014 Run a compiled QuantumProgram remotely and return the results.</p> </li> </ul> <p> source method RemoteEmulator.submit(program: QuantumProgram, wait: bool = False) \u2192 RemoteResults </p> <p>Submit a compiled QuantumProgram and return a remote handler of the results.</p> <p> The returned handler `RemoteResults` can be used to </p> <ul> <li>query the job status with <code>remote_results.get_batch_status()</code></li> <li>when DONE, retrieve results with <code>remote_results.results</code></li> </ul> <p> Parameters </p> <ul> <li> <p>program :  QuantumProgram \u2014 the compiled quantum program to run.</p> </li> <li> <p>wait :  bool \u2014 Wait for remote backend to complete the job.</p> </li> </ul> <p> source method RemoteEmulator.run(program: QuantumProgram) \u2192 Sequence[Results] </p> <p>Run a compiled QuantumProgram remotely and return the results.</p> <p> source class QPU(*, connection: RemoteConnection, runs: int = 100) </p> <p>Bases : PulserRemoteBackend</p> <p>Run QoolQit <code>QuantumProgram</code>s on a Pasqal QPU.</p> <p>This class serves as a primary interface between tools written using QoolQit (including solvers) and QPU backend. It requires credentials through a <code>connection</code> to submit/run a program. Please, contact your provider to get your credentials and get help on how create a connection object: - Pasqal Cloud interface documentation - Atos MyQML framework</p> <p> Parameters </p> <ul> <li> <p>connection :  RemoteConnection \u2014 connection to execute the program on remote backends.</p> </li> <li> <p>runs :  int \u2014 run the program <code>runs</code> times to collect bitstrings statistics.</p> </li> </ul> <p> Examples </p> <pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit.execution import QPU\nconnection = PasqalCloud(username=..., password=..., project_id=...)\nbackend = QPU(connection=connection)\nremote_results = backend.submit(program)\n</code></pre> <p> Methods </p> <ul> <li> <p>submit \u2014 Submit a compiled QuantumProgram and return a remote handler of the results.</p> </li> <li> <p>run \u2014 Run a compiled QuantumProgram remotely and return the results.</p> </li> </ul> <p> source method QPU.submit(program: QuantumProgram, wait: bool = False) \u2192 RemoteResults </p> <p>Submit a compiled QuantumProgram and return a remote handler of the results.</p> <p> The returned handler `RemoteResults` can be used to </p> <ul> <li>query the job status with <code>remote_results.get_batch_status()</code></li> <li>when DONE, retrieve results with <code>remote_results.results</code></li> </ul> <p> Parameters </p> <ul> <li> <p>program :  QuantumProgram \u2014 the compiled quantum program to run.</p> </li> <li> <p>wait :  bool \u2014 Wait for remote backend to complete the job.</p> </li> </ul> <p> source method QPU.run(program: QuantumProgram) \u2192 Sequence[Results] </p> <p>Run a compiled QuantumProgram remotely and return the results.</p> <p> class EmulationConfig(*, callbacks: Sequence[Callback] = (), observables: Sequence[Observable] = (), default_evaluation_times: Sequence[SupportsFloat] | Literal['Full'] = (1.0,), initial_state: StateType | None = None, with_modulation: bool = False, interaction_matrix: ArrayLike | None = None, prefer_device_noise_model: bool = False, noise_model: NoiseModel = NoiseModel(), **backend_options: Any) </p> <p>Bases : BackendConfig, Generic[StateType]</p> <p>Configures an emulation on a backend.</p> <p>Initializes the EmulationConfig.</p> <p> Parameters </p> <ul> <li> <p>observables :  Sequence[Observable] \u2014 A sequence of observables to compute at specific evaluation times. The observables without specified evaluation times will use this configuration's 'default_evaluation_times'.</p> </li> <li> <p>callbacks :  Sequence[Callback] \u2014 A general callback that is not an observable. Observables must be fed into the observables arg, since they all interact with the Results, and are subject to additional validation. Unlike observables, these are called at every emulation step.</p> </li> <li> <p>default_evaluation_times :  Sequence[SupportsFloat] | Literal['Full'] \u2014 The default times at which observables are computed. Can be a sequence of unique relative times between 0 (the start of the sequence) and 1 (the end of the sequence), in ascending order. Can also be specified as \"Full\", in which case every step in the emulation will also be an evaluation time.</p> </li> <li> <p>initial_state :  StateType | None \u2014 The initial state from which emulation starts. If specified, the state type needs to be compatible with the emulator backend. If left undefined, defaults to starting with all qudits in the ground state.</p> </li> <li> <p>with_modulation :  bool \u2014 Whether to emulate the sequence with the programmed input or the expected output.</p> </li> <li> <p>interaction_matrix :  ArrayLike | None \u2014 An optional interaction matrix to replace the interaction terms in the Hamiltonian. For an N-qudit system, must be an NxN symmetric matrix where entry (i, j) dictates the interaction coefficient between qudits i and j, ie it replaces the C_n/r_{ij}^n term.</p> </li> <li> <p>prefer_device_noise_model :  bool \u2014 If True, uses the noise model of the sequence's device (if the sequence's device has one), regardless of the noise model given with this configuration.</p> </li> <li> <p>noise_model :  NoiseModel \u2014 An optional noise model to emulate the sequence with. Ignored if the sequence's device has default noise model and <code>prefer_device_noise_model=True</code>.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>is_evaluation_time \u2014 Assesses whether a relative time is an evaluation time.</p> </li> <li> <p>is_time_in_evaluation_times \u2014 Checks if a time is within a collection of evaluation times.</p> </li> <li> <p>to_abstract_repr \u2014 Serialize <code>EmulationConfig</code> to a JSON formatted str.</p> </li> <li> <p>from_abstract_repr \u2014 Deserialize an EmulationConfig from an abstract JSON object.</p> </li> </ul> <p> method EmulationConfig.is_evaluation_time(t: float, tol: float = 1e-06) \u2192 bool </p> <p>Assesses whether a relative time is an evaluation time.</p> <p> staticmethod EmulationConfig.is_time_in_evaluation_times(t: float, evaluation_times: ArrayLike, tol: float = 1e-06) \u2192 bool </p> <p>Checks if a time is within a collection of evaluation times.</p> <p> method EmulationConfig.to_abstract_repr(skip_validation: bool = False) \u2192 str </p> <p>Serialize <code>EmulationConfig</code> to a JSON formatted str.</p> <p> classmethod EmulationConfig.from_abstract_repr(obj_str: str) \u2192 EmulationConfig </p> <p>Deserialize an EmulationConfig from an abstract JSON object.</p> <p> Parameters </p> <ul> <li> <p>obj_str :  str \u2014 the JSON string representing the sequence encoded in the abstract JSON format.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>EmulationConfig \u2014 The EmulationConfig instance.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> class BitStrings(*, evaluation_times: Sequence[float] | None = None, num_shots: int = 1000, one_state: Eigenstate | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores bitstrings sampled from the state at the evaluation times.</p> <p>Error rates are taken from the NoiseModel passed to the backend via the EmulationConfig. The bitstrings are stored as a Counter[str].</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to sample bitstrings. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>num_shots :  int \u2014 How many bitstrings to sample each time this observable is computed.</p> </li> <li> <p>one_state :  Eigenstate | None \u2014 The eigenstate that measures to 1. Can be left undefined if the state's eigenstates form a known eigenbasis with a defined \"one state\".</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method BitStrings.apply(*, config: EmulationConfig, state: State, **kwargs: Any) \u2192 Counter[str] </p> <p>Calculates the observable to store in the Results.</p> <p> class CorrelationMatrix(*, evaluation_times: Sequence[float] | None = None, one_state: Eigenstate | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the correlation matrix for the current state.</p> <p>The correlation matrix is calculated as <code>[[&lt;\u03c6(t)|n_i n_j|\u03c6(t)&gt; for j in qubits] for i in qubits]</code> where <code>n_k = |one_state&gt;&lt;one_state|</code>.</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to compute the correlation matrix. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>one_state :  Eigenstate | None \u2014 The eigenstate to measure the population of in the correlation matrix. Can be left undefined if the state's eigenstates form a known eigenbasis with a defined \"one state\".</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method CorrelationMatrix.apply(*, state: State, hamiltonian: Operator, **kwargs: Any) \u2192 list[list] </p> <p>Calculates the observable to store in the Results.</p> <p> class Energy(*, evaluation_times: Sequence[float] | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the energy of the system at the evaluation times.</p> <p>The energy is calculated as the expectation value of the Hamiltonian, i.e. <code>&lt;\u03c6(t)|H(t)|\u03c6(t)&gt;</code>.</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to compute the energy. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method Energy.apply(*, state: State, hamiltonian: Operator, **kwargs: Any) \u2192 Any </p> <p>Calculates the observable to store in the Results.</p> <p> class EnergySecondMoment(*, evaluation_times: Sequence[float] | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the expectation value of <code>H(t)^2</code> at the evaluation times.</p> <p>Useful for computing the variance when averaging over many executions of the program.</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to compute the variance. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method EnergySecondMoment.apply(*, state: State, hamiltonian: Operator, **kwargs: Any) \u2192 Any </p> <p>Calculates the observable to store in the Results.</p> <p> class EnergyVariance(*, evaluation_times: Sequence[float] | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the variance of the Hamiltonian at the evaluation times.</p> <p>The variance of the Hamiltonian at time <code>t</code> is calculated by <code>&lt;\u03c6(t)|H(t)^2|\u03c6(t)&gt; - &lt;\u03c6(t)|H(t)|\u03c6(t)&gt;^2</code></p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to compute the variance. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method EnergyVariance.apply(*, state: State, hamiltonian: Operator, **kwargs: Any) \u2192 Any </p> <p>Calculates the observable to store in the Results.</p> <p> class Expectation(operator: Operator, *, evaluation_times: Sequence[float] | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the expectation of the given operator on the current state.</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to compute the expectation value. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>operator :  Operator \u2014 The operator to measure. Must be of the appropriate type for the backend.</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method Expectation.apply(*, state: State, **kwargs: Any) \u2192 Any </p> <p>Calculates the observable to store in the Results.</p> <p> class Fidelity(state: State, *, evaluation_times: Sequence[float] | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the fidelity with a pure state at the evaluation times.</p> <p>The fidelity uses the overlap between the given state and the state of the system at each evaluation time. For pure states, this corresponds to <code>|&lt;\u03c8|\u03c6(t)&gt;|^2</code> for the given state <code>|\u03c8&gt;</code> and the state <code>|\u03c6(t)&gt;</code> obtained by time evolution.</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>state :  State \u2014 The state <code>|\u03c8&gt;</code>. Note that this must be of an appropriate type for the backend.</p> </li> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to compute the fidelity. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method Fidelity.apply(*, state: State, **kwargs: Any) \u2192 Any </p> <p>Calculates the observable to store in the Results.</p> <p> class Occupation(*, evaluation_times: Sequence[float] | None = None, one_state: Eigenstate | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the occupation number of an eigenstate on each qudit.</p> <p>For every qudit i, calculates <code>&lt;\u03c6(t)|n_i|\u03c6(t)&gt;</code>, where <code>n_i = |one_state&gt;&lt;one_state|</code>.</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to compute the correlation matrix. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>one_state :  Eigenstate | None \u2014 The eigenstate to measure the population of. Can be left undefined if the state's eigenstates form a known eigenbasis with a defined \"one state\".</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method Occupation.apply(*, state: State, hamiltonian: Operator, **kwargs: Any) \u2192 list </p> <p>Calculates the observable to store in the Results.</p> <p> class StateResult(*, evaluation_times: Sequence[float] | None = None, tag_suffix: str | None = None) </p> <p>Bases : Observable</p> <p>Stores the quantum state at the evaluation times.</p> <p>Initializes the observable.</p> <p> Parameters </p> <ul> <li> <p>evaluation_times :  Sequence[float] | None \u2014 The relative times at which to store the state. If left as <code>None</code>, uses the <code>default_evaluation_times</code> of the backend's <code>EmulationConfig</code>.</p> </li> <li> <p>tag_suffix :  str | None \u2014 An optional suffix to append to the tag. Needed if multiple instances of the same observable are given to the same EmulationConfig.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>uuid :  uuid.UUID \u2014 A universal unique identifier for this instance.</p> </li> <li> <p>tag :  str \u2014 Label for the observable, used to index the Results object.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>apply \u2014 Calculates the observable to store in the Results.</p> </li> </ul> <p> method StateResult.apply(*, state: StateType, **kwargs: Any) \u2192 StateType </p> <p>Calculates the observable to store in the Results.</p> <p> dataclass Results(atom_order: tuple[str, ...], total_duration: int) </p> <p>A collection of results.</p> <p> Parameters </p> <ul> <li> <p>atom_order :  tuple[str, ...] \u2014 The order of the atoms/qudits in the results.</p> </li> <li> <p>total_duration :  int \u2014 The total duration of the sequence, in ns.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>final_bitstrings :  dict[str, int] \u2014 Returns the bitstrings at the end of the sequence, if available.</p> </li> <li> <p>final_state :  State \u2014 Returns the state at the end of the sequence, if available.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>get_result_tags \u2014 Get a list of results tags present in this object.</p> </li> <li> <p>get_result_times \u2014 Get a list of times for which the given result has been stored.</p> </li> <li> <p>get_result \u2014 Get the a specific result at a given time.</p> </li> <li> <p>get_tagged_results \u2014 Gets the results for every tag.</p> </li> <li> <p>to_abstract_repr \u2014 Serializes this object into a json string.</p> </li> <li> <p>from_abstract_repr \u2014 Deserializes a Results object from json.</p> </li> <li> <p>aggregate \u2014 Aggregate a Sequence of Results objects into a single Results.</p> </li> </ul> <p> property Results.final_bitstrings: dict[str, int] </p> <p>Returns the bitstrings at the end of the sequence, if available.</p> <p> property Results.final_state: State </p> <p>Returns the state at the end of the sequence, if available.</p> <p> method Results.get_result_tags() \u2192 list[str] </p> <p>Get a list of results tags present in this object.</p> <p> method Results.get_result_times(observable: Observable | str) \u2192 list[float] </p> <p>Get a list of times for which the given result has been stored.</p> <p> Parameters </p> <ul> <li> <p>observable :  Observable | str \u2014 The observable instance used to calculate the result or its tag.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>list[float] \u2014 List of relative times.</p> </li> </ul> <p> method Results.get_result(observable: Observable | str, time: float) \u2192 Any </p> <p>Get the a specific result at a given time.</p> <p> Parameters </p> <ul> <li> <p>observable :  Observable | str \u2014 The observable instance used to calculate the result or its tag.</p> </li> <li> <p>time :  float \u2014 Relative time at which to get the result.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>Any \u2014 The result.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> method Results.get_tagged_results() \u2192 dict[str, list[Any]] </p> <p>Gets the results for every tag.</p> <p> Returns </p> <ul> <li> <p>dict[str, list[Any]] \u2014 A mapping between a tag and the results associated to it, at every evaluation time.</p> </li> </ul> <p> method Results.to_abstract_repr(skip_validation: bool = False) \u2192 str </p> <p>Serializes this object into a json string.</p> <p>Numpy arrays and torch Tensors are converted into lists, and their original class is lost forever.</p> <p> Parameters </p> <ul> <li> <p>skip_validation :  bool \u2014 Whether to skip validating the json against the schema used for deserialization.</p> </li> </ul> <p> Returns </p> <ul> <li> <p>str \u2014 The json string</p> </li> </ul> <p> classmethod Results.from_abstract_repr(repr: str) \u2192 Results </p> <p>Deserializes a Results object from json.</p> <p> Returns </p> <ul> <li> <p>Results \u2014 The deserialized Results object.</p> </li> </ul> <p> classmethod Results.aggregate(results_to_aggregate: typing.Sequence[Results], **aggregation_functions: Callable[[Any], Any]) \u2192 Results </p> <p>Aggregate a Sequence of Results objects into a single Results.</p> <p>This is meant to accumulate the results of several runs with different noise trajectories into a single averaged Results. By default, results are averaged, with the exception of BitStrings, where the counters are joined. StateResult and EnergyVariance are not supported by default.</p> <p> Parameters </p> <ul> <li> <p>results_to_aggregate :  typing.Sequence[Results] \u2014 The list of Results to aggregate</p> </li> </ul> <p> Keyword Args </p> <p>observable_tag: Overrides the default aggregator.     The argument name should be the tag of the Observable.     The value is a Callable taking a list of the type to aggregate.     Note that this does not override the default aggregation     behaviour of the aggregated results.</p> <p> Returns </p> <ul> <li> <p>Results \u2014 The averaged Results object</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> <li> <p>NotImplementedError</p> </li> </ul> <p> class RemoteResults(batch_id: str, connection: RemoteConnection, job_ids: list[str] | None = None) </p> <p>Bases : ResultsSequence</p> <p>A collection of results obtained through a remote connection.</p> <p>Instantiates a new collection of remote results.</p> <p> Parameters </p> <ul> <li> <p>batch_id :  str \u2014 The ID that identifies the batch linked to the results.</p> </li> <li> <p>connection :  RemoteConnection \u2014 The remote connection over which to get the batch's status and fetch the results.</p> </li> <li> <p>job_ids :  list[str] | None \u2014 If given, specifies which jobs within the batch should be included in the results and in what order. If left undefined, all jobs are included.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>results :  tuple[Results, ...] \u2014 The actual results, obtained after execution is done.</p> </li> <li> <p>batch_id :  str \u2014 The ID of the batch containing these results.</p> </li> <li> <p>job_ids :  list[str] \u2014 The IDs of the jobs within these results' batch.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>get_batch_status \u2014 Gets the status of the batch linked to these results.</p> </li> <li> <p>get_available_results \u2014 Returns the available results.</p> </li> </ul> <p> property RemoteResults.results: tuple[Results, ...] </p> <p>The actual results, obtained after execution is done.</p> <p> property RemoteResults.batch_id: str </p> <p>The ID of the batch containing these results.</p> <p> property RemoteResults.job_ids: list[str] </p> <p>The IDs of the jobs within these results' batch.</p> <p> method RemoteResults.get_batch_status() \u2192 BatchStatus </p> <p>Gets the status of the batch linked to these results.</p> <p> method RemoteResults.get_available_results() \u2192 dict[str, Results] </p> <p>Returns the available results.</p> <p>Unlike the <code>results</code> property, this method does not raise an error if some of the jobs do not have results.</p> <p> Returns </p> <ul> <li> <p>dict[str, Results] \u2014 A dictionary mapping the job ID to its results. Jobs with no result are omitted.</p> </li> </ul> <p> module BackendType </p> <p>A module gathering all available backends.</p> <p>This module is a single-point access to backends spread across different packages. As long as the appropriate package is installed, the <code>Backend</code> instances defined within it should be importable via this module, like so::</p> <pre><code>import pulser.backends as backends\n\nbackends.QPUBackend  # Same as pulser.QPUBackend\nbackends.QutipBackendV2  # Same as pulser_simulation.QutipBackendV2\n</code></pre> <p> Attributes </p> <ul> <li> <p>QPUBackend \u2014 See :py:class:<code>pulser.backend.QPUBackend</code>.</p> </li> <li> <p>QutipBackend \u2014 See :py:class:<code>pulser_simulation.QutipBackend</code>.</p> </li> <li> <p>QutipBackendV2 \u2014 See :py:class:<code>pulser_simulation.QutipBackendV2</code>.</p> </li> <li> <p>EmuFreeBackend \u2014 See :py:class:<code>pulser_pasqal.EmuFreeBackend</code>.</p> </li> <li> <p>EmuFreeBackendV2 \u2014 See :py:class:<code>pulser_pasqal.EmuFreeBackendV2</code>.</p> </li> <li> <p>EmuTNBackend \u2014 See :py:class:<code>pulser_pasqal.EmuTNBackend</code>.</p> </li> <li> <p>EmuMPSBackend \u2014 See :py:class:<code>pulser_pasqal.EmuMPSBackend</code>.</p> </li> <li> <p>MPSBackend \u2014 See <code>emu_mps.MPSBackend &lt;https://pypi.org/project/emu-mps/&gt;</code>_.</p> </li> <li> <p>SVBackend \u2014 See <code>emu_sv.SVBackend &lt;https://pypi.org/project/emu-sv/&gt;</code>_.</p> </li> </ul>"},{"location":"api/qoolqit/execution/backends/","title":"qoolqit.execution.backends","text":"qoolqit.execution.backends<p> source module qoolqit.execution.backends </p> <p> Classes </p> <ul> <li> <p>PulserEmulatorBackend \u2014 Base Emulator class.</p> </li> <li> <p>PulserRemoteBackend</p> </li> <li> <p>LocalEmulator \u2014 Run QoolQit <code>QuantumProgram</code>s on a Pasqal local emulator backends.</p> </li> <li> <p>RemoteEmulator \u2014 Run QoolQit <code>QuantumProgram</code>s on a Pasqal remote emulator backends.</p> </li> <li> <p>QPU \u2014 Run QoolQit <code>QuantumProgram</code>s on a Pasqal QPU.</p> </li> </ul> <p> source class PulserEmulatorBackend(runs: int = 1000) </p> <p>Base Emulator class.</p> <p> Parameters </p> <ul> <li> <p>runs :  int \u2014 run the program <code>runs</code> times to collect bitstrings statistics. On QPU backends this represents the actual number of runs of the program. On emulators, instead the bitstring are sampled from the quantum state <code>runs</code> times.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_emulation_config \u2014 Returns a valid config for emulator backends, if needed.</p> </li> <li> <p>default_emulation_config \u2014 Return a unique emulation config for all emulators.</p> </li> </ul> <p> source method PulserEmulatorBackend.validate_emulation_config(emulation_config: Optional[EmulationConfig]) \u2192 EmulationConfig </p> <p>Returns a valid config for emulator backends, if needed.</p> <p> Parameters </p> <ul> <li> <p>emulation_config :  EmulationConfig \u2014 base configuration class for all emulators backends. If no config is provided to an emulator backend, a default will be provided instead.</p> </li> <li> <p>Note \u2014 Emulators backend (local/remote) can be configured through the generic <code>EmulationConfig</code> object. Early validation makes the error easier to understand.</p> </li> </ul> <p> source method PulserEmulatorBackend.default_emulation_config() \u2192 EmulationConfig </p> <p>Return a unique emulation config for all emulators.</p> <p>Defaults to a configuration that asks for the final bitstring, sampled <code>runs</code> times.</p> <p> source class PulserRemoteBackend() </p> <p> Methods </p> <ul> <li> <p>validate_connection \u2014 Validate the required connection to instantiate a RemoteBackend.</p> </li> </ul> <p> source staticmethod PulserRemoteBackend.validate_connection(connection: RemoteConnection) \u2192 RemoteConnection </p> <p>Validate the required connection to instantiate a RemoteBackend.</p> <p>Remote emulators and QPUs require a <code>pulser.backend.remote.RemoteConnection</code> or derived to send jobs. Validation also happens inside the backend. Early validation just makes the error easier to understand.</p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source class LocalEmulator(*, backend_type: type[EmulatorBackend] = QutipBackendV2, emulation_config: Optional[EmulationConfig] = None, runs: int = 100) </p> <p>Bases : PulserEmulatorBackend</p> <p>Run QoolQit <code>QuantumProgram</code>s on a Pasqal local emulator backends.</p> <p>This class serves as a primary interface between tools written using QoolQit (including solvers) and local emulator backends.</p> <p> Parameters </p> <ul> <li> <p>backend_type :  type \u2014 backend type. Must be a subtype of <code>pulser.backend.EmulatorBackend</code>.</p> </li> <li> <p>emulation_config :  EmulationConfig \u2014 optional configuration object emulators.</p> </li> <li> <p>runs :  int \u2014 number of bitstring samples to collect from the final quantum state. It emulates running the program <code>runs</code> times to collect bitstrings statistics.</p> </li> </ul> <p> Examples </p> <pre><code>from qoolqit.execution import LocalEmulator, BackendType\nbackend = LocalEmulator(backend_type=BackendType.QutipBackendV2)\nresult = backend.run(program)\n</code></pre> <p> Methods </p> <ul> <li> <p>run \u2014 Run a compiled QuantumProgram and return the results.</p> </li> </ul> <p> source method LocalEmulator.run(program: QuantumProgram) \u2192 Sequence[Results] </p> <p>Run a compiled QuantumProgram and return the results.</p> <p> source class RemoteEmulator(*, backend_type: type[RemoteEmulatorBackend] = EmuFreeBackendV2, connection: RemoteConnection, emulation_config: Optional[EmulationConfig] = None, runs: int = 100) </p> <p>Bases : PulserEmulatorBackend, PulserRemoteBackend</p> <p>Run QoolQit <code>QuantumProgram</code>s on a Pasqal remote emulator backends.</p> <p>This class serves as a primary interface between tools written using QoolQit (including solvers) and remote emulator backends. The behavior is similar to <code>LocalEmulator</code>, but here, requires credentials through a <code>connection</code> to submit/run a program. To get your credentials and to create a connection object, please refer to the Pasqal Cloud interface documentation.</p> <p> Parameters </p> <ul> <li> <p>backend_type :  type \u2014 backend type. Must be a subtype of <code>pulser_pasqal.backends.RemoteEmulatorBackend</code>.</p> </li> <li> <p>connection :  RemoteConnection \u2014 connection to execute the program on remote backends.</p> </li> <li> <p>emulation_config :  EmulationConfig \u2014 optional configuration object emulators.</p> </li> <li> <p>runs :  int \u2014 number of bitstring samples to collect from the final quantum state. It emulates running the program <code>runs</code> times to collect bitstrings statistics.</p> </li> </ul> <p> Examples </p> <p><pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit.execution import RemoteEmulator, BackendType\nconnection = PasqalCloud(username=..., password=..., project_id=...)\nbackend = RemoteEmulator(backend_type=BackendType.EmuFreeBackendV2, connection=connection)\n</code></pre> then <pre><code>remote_results = backend.submit(program)\n</code></pre> or <pre><code>results = backend.run(program)\n</code></pre></p> <p> Methods </p> <ul> <li> <p>submit \u2014 Submit a compiled QuantumProgram and return a remote handler of the results.</p> </li> <li> <p>run \u2014 Run a compiled QuantumProgram remotely and return the results.</p> </li> </ul> <p> source method RemoteEmulator.submit(program: QuantumProgram, wait: bool = False) \u2192 RemoteResults </p> <p>Submit a compiled QuantumProgram and return a remote handler of the results.</p> <p> The returned handler `RemoteResults` can be used to </p> <ul> <li>query the job status with <code>remote_results.get_batch_status()</code></li> <li>when DONE, retrieve results with <code>remote_results.results</code></li> </ul> <p> Parameters </p> <ul> <li> <p>program :  QuantumProgram \u2014 the compiled quantum program to run.</p> </li> <li> <p>wait :  bool \u2014 Wait for remote backend to complete the job.</p> </li> </ul> <p> source method RemoteEmulator.run(program: QuantumProgram) \u2192 Sequence[Results] </p> <p>Run a compiled QuantumProgram remotely and return the results.</p> <p> source class QPU(*, connection: RemoteConnection, runs: int = 100) </p> <p>Bases : PulserRemoteBackend</p> <p>Run QoolQit <code>QuantumProgram</code>s on a Pasqal QPU.</p> <p>This class serves as a primary interface between tools written using QoolQit (including solvers) and QPU backend. It requires credentials through a <code>connection</code> to submit/run a program. Please, contact your provider to get your credentials and get help on how create a connection object: - Pasqal Cloud interface documentation - Atos MyQML framework</p> <p> Parameters </p> <ul> <li> <p>connection :  RemoteConnection \u2014 connection to execute the program on remote backends.</p> </li> <li> <p>runs :  int \u2014 run the program <code>runs</code> times to collect bitstrings statistics.</p> </li> </ul> <p> Examples </p> <pre><code>from pulser_pasqal import PasqalCloud\nfrom qoolqit.execution import QPU\nconnection = PasqalCloud(username=..., password=..., project_id=...)\nbackend = QPU(connection=connection)\nremote_results = backend.submit(program)\n</code></pre> <p> Methods </p> <ul> <li> <p>submit \u2014 Submit a compiled QuantumProgram and return a remote handler of the results.</p> </li> <li> <p>run \u2014 Run a compiled QuantumProgram remotely and return the results.</p> </li> </ul> <p> source method QPU.submit(program: QuantumProgram, wait: bool = False) \u2192 RemoteResults </p> <p>Submit a compiled QuantumProgram and return a remote handler of the results.</p> <p> The returned handler `RemoteResults` can be used to </p> <ul> <li>query the job status with <code>remote_results.get_batch_status()</code></li> <li>when DONE, retrieve results with <code>remote_results.results</code></li> </ul> <p> Parameters </p> <ul> <li> <p>program :  QuantumProgram \u2014 the compiled quantum program to run.</p> </li> <li> <p>wait :  bool \u2014 Wait for remote backend to complete the job.</p> </li> </ul> <p> source method QPU.run(program: QuantumProgram) \u2192 Sequence[Results] </p> <p>Run a compiled QuantumProgram remotely and return the results.</p>"},{"location":"api/qoolqit/execution/compilation_functions/","title":"qoolqit.execution.compilation_functions","text":"qoolqit.execution.compilation_functions<p> source module qoolqit.execution.compilation_functions </p> <p> Classes </p> <ul> <li> <p>WaveformConverter \u2014 Convert a QoolQit waveform into a equivalent Pulser waveform.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>basic_compilation</p> </li> </ul> <p> source class WaveformConverter(device: Device, time: float, energy: float) </p> <p>Convert a QoolQit waveform into a equivalent Pulser waveform.</p> <p>Requires the new time and energy scales set by the compilation profile. Additionally, requires the clock period of the device to round the duration.</p> <p> Methods </p> <ul> <li> <p>convert \u2014 Convert a QoolQit waveform into a equivalent Pulser waveform.</p> </li> </ul> <p> source method WaveformConverter.convert(waveform: Waveform) \u2192 ParamObj | PulserWaveform </p> <p>Convert a QoolQit waveform into a equivalent Pulser waveform.</p> <p> source basic_compilation(register: Register, drive: Drive, device: Device, profile: CompilerProfile) \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> <li> <p>TypeError</p> </li> </ul>"},{"location":"api/qoolqit/execution/sequence_compiler/","title":"qoolqit.execution.sequence_compiler","text":"qoolqit.execution.sequence_compiler<p> source module qoolqit.execution.sequence_compiler </p> <p> Classes </p> <ul> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>error</p> </li> <li> <p>CompilationError</p> </li> </ul>"},{"location":"api/qoolqit/execution/utils/","title":"qoolqit.execution.utils","text":"qoolqit.execution.utils<p> source module qoolqit.execution.utils </p> <p> Classes </p> <ul> <li> <p>CompilerProfile</p> </li> </ul> <p> source enum CompilerProfile(*args, **kwds) </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul>"},{"location":"api/qoolqit/graphs/","title":"qoolqit.graphs","text":"qoolqit.graphs<p> source package qoolqit.graphs </p> <p>Graph creation and manipulation in QoolQit.</p> <p> Classes </p> <ul> <li> <p>BaseGraph \u2014 The BaseGraph in QoolQit, directly inheriting from the NetworkX Graph.</p> </li> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>all_node_pairs \u2014 Return all pairs of nodes (u, v) where u &lt; v.</p> </li> <li> <p>distances \u2014 Return a dictionary of edge distances.</p> </li> <li> <p>random_coords \u2014 Generate a random set of node coordinates on a square of side L.</p> </li> <li> <p>random_edge_list \u2014 Generates a random set of k edges linkings items from a set of nodes.</p> </li> <li> <p>scale_coords \u2014 Scale the coordinates by a given value.</p> </li> <li> <p>space_coords \u2014 Spaces the coordinates so the minimum distance is equal to a set spacing.</p> </li> </ul> <p> source class BaseGraph(edges: Iterable = []) </p> <p>Bases : nx.Graph</p> <p>The BaseGraph in QoolQit, directly inheriting from the NetworkX Graph.</p> <p>Defines basic functionalities for graphs within the Rydberg Analog, such as instantiating from a set of node coordinates, directly accessing node distances, and checking if the graph is unit-disk.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_nodes \u2014 Construct a base graph from a set of nodes.</p> </li> <li> <p>from_coordinates \u2014 Construct a base graph from a set of coordinates.</p> </li> <li> <p>from_nx \u2014 Convert a NetworkX Graph object into a QoolQit graph instance.</p> </li> <li> <p>from_pyg \u2014 Convert a PyTorch Geometric Data object into a QoolQit graph instance.</p> </li> <li> <p>distances \u2014 Returns a dictionary of distances for a given set of edges.</p> </li> <li> <p>interactions \u2014 Rydberg model interaction 1/r^6 between pair of nodes.</p> </li> <li> <p>min_distance \u2014 Returns the minimum distance in the graph.</p> </li> <li> <p>max_distance \u2014 Returns the maximum distance in the graph.</p> </li> <li> <p>ud_radius_range \u2014 Return the range (R_min, R_max) where the graph is unit-disk.</p> </li> <li> <p>is_ud_graph \u2014 Check if the graph is unit-disk.</p> </li> <li> <p>ud_edges \u2014 Returns the set of edges given by the intersection of circles of a given radius.</p> </li> <li> <p>rescale_coords \u2014 Rescales the node coordinates by a factor.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> <li> <p>draw \u2014 Draw the graph.</p> </li> </ul> <p> source classmethod BaseGraph.from_nodes(nodes: Iterable) \u2192 BaseGraph </p> <p>Construct a base graph from a set of nodes.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of nodes.</p> </li> </ul> <p> source classmethod BaseGraph.from_coordinates(coords: list | dict) \u2192 BaseGraph </p> <p>Construct a base graph from a set of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list | dict \u2014 list or dictionary of coordinate pairs.</p> </li> </ul> <p> source classmethod BaseGraph.from_nx(g: nx.Graph) \u2192 BaseGraph </p> <p>Convert a NetworkX Graph object into a QoolQit graph instance.</p> <p>The input <code>networkx.Graph</code> graph must be defined only with the following allowed</p> <p> Node attributes </p> <pre><code>pos (tuple): represents the node 2D position. Must be a list/tuple of real numbers.\nweight: represents the node weight. Must be a real number.\n</code></pre> <p>Edge attributes:     weight: represents the edge weight. Must be a real number.</p> <p> Returns an instance of the class with following attributes </p> <ul> <li>_node_weights : dict[node, float or None]</li> <li>_edge_weights : dict[(u,v), float or None]</li> <li>_coords       : dict[node, (float,float) or None]</li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source classmethod BaseGraph.from_pyg(g: torch_geometric.data.Data) \u2192 BaseGraph </p> <p>Convert a PyTorch Geometric Data object into a QoolQit graph instance.</p> <p>This method requires installing the <code>torch_geometric</code> package. The input <code>torch_geometric.data.Data</code> object must be defined only with the following allowed attributes:     x (torch.Tensor): node weights as a matrix with shape (num_nodes, 1).     edge_index (torch.Tensor): graph connectivity as a matrix with shape (2, num_edges).     num_nodes (int): minimum number of nodes. The total number of nodes will be inferred         from this number and from the edges of the graph.     pos (torch.Tensor): node 2D positions as a matrix with shape (num_nodes, 2)     edge_attr (torch.Tensor): edge weights as a matrix with shape (num_edges, 1).</p> <p>If the graph is defined only through the <code>edge_index</code> attribute, <code>num_nodes</code> is required. The input graph will be converted to a unidirectional graph.</p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>AttributeError</p> </li> <li> <p>ImportError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source property BaseGraph.sorted_edges: set </p> <p>Returns the set of edges (u, v) such that (u &lt; v).</p> <p> source property BaseGraph.all_node_pairs: set </p> <p>Return a list of all possible node pairs in the graph.</p> <p> source property BaseGraph.has_coords: bool </p> <p>Check if the graph has coordinates.</p> <p>Requires all nodes to have coordinates.</p> <p> source property BaseGraph.has_edges: bool </p> <p>Check if the graph has edges.</p> <p> source property BaseGraph.coords: dict </p> <p>Return the dictionary of node coordinates.</p> <p> source method BaseGraph.distances(edge_list: Iterable | None = None) \u2192 dict </p> <p>Returns a dictionary of distances for a given set of edges.</p> <p>Distances are calculated directly from the coordinates. Raises an error if there are no coordinates on the graph.</p> <p> Parameters </p> <ul> <li> <p>edge_list :  Iterable | None \u2014 set of edges.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.interactions() \u2192 dict </p> <p>Rydberg model interaction 1/r^6 between pair of nodes.</p> <p> source method BaseGraph.min_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the minimum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.max_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the maximum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.ud_radius_range() \u2192 tuple </p> <p>Return the range (R_min, R_max) where the graph is unit-disk.</p> <p>The graph is unit-disk if the maximum distance between all connected nodes is smaller than the minimum distance between disconnected nodes. This means that for any value R in that interval, the following condition is true:</p> <p>graph.ud_edges(radius = R) == graph.sorted edges</p> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.is_ud_graph() \u2192 bool </p> <p>Check if the graph is unit-disk.</p> <p> source method BaseGraph.ud_edges(radius: float) \u2192 set </p> <p>Returns the set of edges given by the intersection of circles of a given radius.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the value</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> </ul> <p> source method BaseGraph.rescale_coords(*args: Any, scaling: float | None = None, spacing: float | None = None) \u2192 None </p> <p>Rescales the node coordinates by a factor.</p> <p>Accepts either a scaling or a spacing factor.</p> <p> Parameters </p> <ul> <li> <p>scaling :  float | None \u2014 value to scale by.</p> </li> <li> <p>spacing :  float | None \u2014 value to set as the minimum distance in the graph.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>TypeError</p> </li> </ul> <p> source method BaseGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the radius to use in determining the set of unit-disk edges.</p> </li> </ul> <p> source method BaseGraph.draw(return_fig: bool = False, *args: Any, **kwargs: Any) \u2192 Figure | None </p> <p>Draw the graph.</p> <p>Uses the draw_networkx function from NetworkX.</p> <p> Parameters </p> <ul> <li> <p>*args :  Any \u2014 arguments to pass to draw_networkx.</p> </li> <li> <p>**kwargs :  Any \u2014 keyword-arguments to pass to draw_networkx.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>triangular \u2014 Constructs a triangular lattice graph, with respective coordinates.</p> </li> <li> <p>hexagonal \u2014 Constructs a hexagonal lattice graph, with respective coordinates.</p> </li> <li> <p>heavy_hexagonal \u2014 Constructs a heavy-hexagonal lattice graph, with respective coordinates.</p> </li> <li> <p>square \u2014 Constructs a square lattice graph, with respective coordinates.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float, seed: int | None = None) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul> <p> source classmethod DataGraph.triangular(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a triangular lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of triangles.</p> </li> <li> <p>n :  int \u2014 Number of columns of triangles.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.hexagonal(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a hexagonal lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of hexagons.</p> </li> <li> <p>n :  int \u2014 Number of columns of hexagons.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.heavy_hexagonal(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a heavy-hexagonal lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of hexagons.</p> </li> <li> <p>n :  int \u2014 Number of columns of hexagons.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p>Notes</p> <p>The heavy-hexagonal lattice is a regular hexagonal lattice where each edge is decorated with an additional lattice site.</p> <p> source classmethod DataGraph.square(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a square lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of square.</p> </li> <li> <p>n :  int \u2014 Number of columns of square.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> source all_node_pairs(nodes: Iterable) \u2192 set </p> <p>Return all pairs of nodes (u, v) where u &lt; v.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of node indices.</p> </li> </ul> <p> source distances(coords: dict, edge_list: Iterable) \u2192 dict </p> <p>Return a dictionary of edge distances.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>edge_list :  Iterable \u2014 edge list to compute the distances for.</p> </li> </ul> <p> source random_coords(n: int, L: float = 1.0) \u2192 list </p> <p>Generate a random set of node coordinates on a square of side L.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of coordinate pairs to generate.</p> </li> <li> <p>L :  float \u2014 side of the square.</p> </li> </ul> <p> source random_edge_list(nodes: Iterable, k: int) \u2192 list </p> <p>Generates a random set of k edges linkings items from a set of nodes.</p> <p> source scale_coords(coords: dict, scaling: float) \u2192 dict </p> <p>Scale the coordinates by a given value.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>scaling :  float \u2014 value to scale by.</p> </li> </ul> <p> source space_coords(coords: dict, spacing: float) \u2192 dict </p> <p>Spaces the coordinates so the minimum distance is equal to a set spacing.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>spacing :  float \u2014 value to set as minimum distance.</p> </li> </ul>"},{"location":"api/qoolqit/graphs/base_graph/","title":"qoolqit.graphs.base_graph","text":"qoolqit.graphs.base_graph<p> source module qoolqit.graphs.base_graph </p> <p> Classes </p> <ul> <li> <p>BaseGraph \u2014 The BaseGraph in QoolQit, directly inheriting from the NetworkX Graph.</p> </li> </ul> <p> source class BaseGraph(edges: Iterable = []) </p> <p>Bases : nx.Graph</p> <p>The BaseGraph in QoolQit, directly inheriting from the NetworkX Graph.</p> <p>Defines basic functionalities for graphs within the Rydberg Analog, such as instantiating from a set of node coordinates, directly accessing node distances, and checking if the graph is unit-disk.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_nodes \u2014 Construct a base graph from a set of nodes.</p> </li> <li> <p>from_coordinates \u2014 Construct a base graph from a set of coordinates.</p> </li> <li> <p>from_nx \u2014 Convert a NetworkX Graph object into a QoolQit graph instance.</p> </li> <li> <p>from_pyg \u2014 Convert a PyTorch Geometric Data object into a QoolQit graph instance.</p> </li> <li> <p>distances \u2014 Returns a dictionary of distances for a given set of edges.</p> </li> <li> <p>interactions \u2014 Rydberg model interaction 1/r^6 between pair of nodes.</p> </li> <li> <p>min_distance \u2014 Returns the minimum distance in the graph.</p> </li> <li> <p>max_distance \u2014 Returns the maximum distance in the graph.</p> </li> <li> <p>ud_radius_range \u2014 Return the range (R_min, R_max) where the graph is unit-disk.</p> </li> <li> <p>is_ud_graph \u2014 Check if the graph is unit-disk.</p> </li> <li> <p>ud_edges \u2014 Returns the set of edges given by the intersection of circles of a given radius.</p> </li> <li> <p>rescale_coords \u2014 Rescales the node coordinates by a factor.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> <li> <p>draw \u2014 Draw the graph.</p> </li> </ul> <p> source classmethod BaseGraph.from_nodes(nodes: Iterable) \u2192 BaseGraph </p> <p>Construct a base graph from a set of nodes.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of nodes.</p> </li> </ul> <p> source classmethod BaseGraph.from_coordinates(coords: list | dict) \u2192 BaseGraph </p> <p>Construct a base graph from a set of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list | dict \u2014 list or dictionary of coordinate pairs.</p> </li> </ul> <p> source classmethod BaseGraph.from_nx(g: nx.Graph) \u2192 BaseGraph </p> <p>Convert a NetworkX Graph object into a QoolQit graph instance.</p> <p>The input <code>networkx.Graph</code> graph must be defined only with the following allowed</p> <p> Node attributes </p> <pre><code>pos (tuple): represents the node 2D position. Must be a list/tuple of real numbers.\nweight: represents the node weight. Must be a real number.\n</code></pre> <p>Edge attributes:     weight: represents the edge weight. Must be a real number.</p> <p> Returns an instance of the class with following attributes </p> <ul> <li>_node_weights : dict[node, float or None]</li> <li>_edge_weights : dict[(u,v), float or None]</li> <li>_coords       : dict[node, (float,float) or None]</li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source classmethod BaseGraph.from_pyg(g: torch_geometric.data.Data) \u2192 BaseGraph </p> <p>Convert a PyTorch Geometric Data object into a QoolQit graph instance.</p> <p>This method requires installing the <code>torch_geometric</code> package. The input <code>torch_geometric.data.Data</code> object must be defined only with the following allowed attributes:     x (torch.Tensor): node weights as a matrix with shape (num_nodes, 1).     edge_index (torch.Tensor): graph connectivity as a matrix with shape (2, num_edges).     num_nodes (int): minimum number of nodes. The total number of nodes will be inferred         from this number and from the edges of the graph.     pos (torch.Tensor): node 2D positions as a matrix with shape (num_nodes, 2)     edge_attr (torch.Tensor): edge weights as a matrix with shape (num_edges, 1).</p> <p>If the graph is defined only through the <code>edge_index</code> attribute, <code>num_nodes</code> is required. The input graph will be converted to a unidirectional graph.</p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>AttributeError</p> </li> <li> <p>ImportError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source property BaseGraph.sorted_edges: set </p> <p>Returns the set of edges (u, v) such that (u &lt; v).</p> <p> source property BaseGraph.all_node_pairs: set </p> <p>Return a list of all possible node pairs in the graph.</p> <p> source property BaseGraph.has_coords: bool </p> <p>Check if the graph has coordinates.</p> <p>Requires all nodes to have coordinates.</p> <p> source property BaseGraph.has_edges: bool </p> <p>Check if the graph has edges.</p> <p> source property BaseGraph.coords: dict </p> <p>Return the dictionary of node coordinates.</p> <p> source method BaseGraph.distances(edge_list: Iterable | None = None) \u2192 dict </p> <p>Returns a dictionary of distances for a given set of edges.</p> <p>Distances are calculated directly from the coordinates. Raises an error if there are no coordinates on the graph.</p> <p> Parameters </p> <ul> <li> <p>edge_list :  Iterable | None \u2014 set of edges.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.interactions() \u2192 dict </p> <p>Rydberg model interaction 1/r^6 between pair of nodes.</p> <p> source method BaseGraph.min_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the minimum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.max_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the maximum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.ud_radius_range() \u2192 tuple </p> <p>Return the range (R_min, R_max) where the graph is unit-disk.</p> <p>The graph is unit-disk if the maximum distance between all connected nodes is smaller than the minimum distance between disconnected nodes. This means that for any value R in that interval, the following condition is true:</p> <p>graph.ud_edges(radius = R) == graph.sorted edges</p> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.is_ud_graph() \u2192 bool </p> <p>Check if the graph is unit-disk.</p> <p> source method BaseGraph.ud_edges(radius: float) \u2192 set </p> <p>Returns the set of edges given by the intersection of circles of a given radius.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the value</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> </ul> <p> source method BaseGraph.rescale_coords(*args: Any, scaling: float | None = None, spacing: float | None = None) \u2192 None </p> <p>Rescales the node coordinates by a factor.</p> <p>Accepts either a scaling or a spacing factor.</p> <p> Parameters </p> <ul> <li> <p>scaling :  float | None \u2014 value to scale by.</p> </li> <li> <p>spacing :  float | None \u2014 value to set as the minimum distance in the graph.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>TypeError</p> </li> </ul> <p> source method BaseGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the radius to use in determining the set of unit-disk edges.</p> </li> </ul> <p> source method BaseGraph.draw(return_fig: bool = False, *args: Any, **kwargs: Any) \u2192 Figure | None </p> <p>Draw the graph.</p> <p>Uses the draw_networkx function from NetworkX.</p> <p> Parameters </p> <ul> <li> <p>*args :  Any \u2014 arguments to pass to draw_networkx.</p> </li> <li> <p>**kwargs :  Any \u2014 keyword-arguments to pass to draw_networkx.</p> </li> </ul>"},{"location":"api/qoolqit/graphs/data_graph/","title":"qoolqit.graphs.data_graph","text":"qoolqit.graphs.data_graph<p> source module qoolqit.graphs.data_graph </p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>triangular \u2014 Constructs a triangular lattice graph, with respective coordinates.</p> </li> <li> <p>hexagonal \u2014 Constructs a hexagonal lattice graph, with respective coordinates.</p> </li> <li> <p>heavy_hexagonal \u2014 Constructs a heavy-hexagonal lattice graph, with respective coordinates.</p> </li> <li> <p>square \u2014 Constructs a square lattice graph, with respective coordinates.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float, seed: int | None = None) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul> <p> source classmethod DataGraph.triangular(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a triangular lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of triangles.</p> </li> <li> <p>n :  int \u2014 Number of columns of triangles.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.hexagonal(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a hexagonal lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of hexagons.</p> </li> <li> <p>n :  int \u2014 Number of columns of hexagons.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.heavy_hexagonal(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a heavy-hexagonal lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of hexagons.</p> </li> <li> <p>n :  int \u2014 Number of columns of hexagons.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p>Notes</p> <p>The heavy-hexagonal lattice is a regular hexagonal lattice where each edge is decorated with an additional lattice site.</p> <p> source classmethod DataGraph.square(m: int, n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a square lattice graph, with respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>m :  int \u2014 Number of rows of square.</p> </li> <li> <p>n :  int \u2014 Number of columns of square.</p> </li> <li> <p>spacing :  float \u2014 The distance between adjacent nodes on the final lattice.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p>"},{"location":"api/qoolqit/graphs/utils/","title":"qoolqit.graphs.utils","text":"qoolqit.graphs.utils<p> source module qoolqit.graphs.utils </p> <p> Functions </p> <ul> <li> <p>all_node_pairs \u2014 Return all pairs of nodes (u, v) where u &lt; v.</p> </li> <li> <p>distances \u2014 Return a dictionary of edge distances.</p> </li> <li> <p>radial_distances \u2014 Return a dictionary of node distances from the origin.</p> </li> <li> <p>scale_coords \u2014 Scale the coordinates by a given value.</p> </li> <li> <p>space_coords \u2014 Spaces the coordinates so the minimum distance is equal to a set spacing.</p> </li> <li> <p>random_coords \u2014 Generate a random set of node coordinates on a square of side L.</p> </li> <li> <p>random_edge_list \u2014 Generates a random set of k edges linkings items from a set of nodes.</p> </li> <li> <p>less_or_equal \u2014 Less or approximately equal.</p> </li> </ul> <p> source all_node_pairs(nodes: Iterable) \u2192 set </p> <p>Return all pairs of nodes (u, v) where u &lt; v.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of node indices.</p> </li> </ul> <p> source distances(coords: dict, edge_list: Iterable) \u2192 dict </p> <p>Return a dictionary of edge distances.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>edge_list :  Iterable \u2014 edge list to compute the distances for.</p> </li> </ul> <p> source radial_distances(coords: dict) \u2192 dict </p> <p>Return a dictionary of node distances from the origin.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> </ul> <p> source scale_coords(coords: dict, scaling: float) \u2192 dict </p> <p>Scale the coordinates by a given value.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>scaling :  float \u2014 value to scale by.</p> </li> </ul> <p> source space_coords(coords: dict, spacing: float) \u2192 dict </p> <p>Spaces the coordinates so the minimum distance is equal to a set spacing.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>spacing :  float \u2014 value to set as minimum distance.</p> </li> </ul> <p> source random_coords(n: int, L: float = 1.0) \u2192 list </p> <p>Generate a random set of node coordinates on a square of side L.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of coordinate pairs to generate.</p> </li> <li> <p>L :  float \u2014 side of the square.</p> </li> </ul> <p> source random_edge_list(nodes: Iterable, k: int) \u2192 list </p> <p>Generates a random set of k edges linkings items from a set of nodes.</p> <p> source less_or_equal(a: float, b: float, rel_tol: float = 0.0, abs_tol: float = ATOL_32) \u2192 bool </p> <p>Less or approximately equal.</p>"},{"location":"api/qoolqit/waveforms/","title":"qoolqit.waveforms","text":"qoolqit.waveforms<p> source package qoolqit.waveforms </p> <p> Classes </p> <ul> <li> <p>Blackman \u2014 A Blackman window of a specified duration and area under the curve.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Interpolated \u2014 A waveform created from interpolation of a set of data points.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> <li> <p>CompositeWaveform \u2014 Base class for composite waveforms.</p> </li> <li> <p>Waveform \u2014 Base class for waveforms.</p> </li> </ul> <p> source class Blackman(duration: float, area: float) </p> <p>Bases : Waveform</p> <p>A Blackman window of a specified duration and area under the curve.</p> <p>Implements the Blackman window shaped waveform     blackman(t) = A(0.42 - 0.5cos(\u03b1t) + 0.08cos(2\u03b1t))               A = area/(0.42duration)               \u03b1 = 2\u03c0/duration</p> <p>Initializes a new Blackman waveform.</p> <p> See </p> <p>https://en.wikipedia.org/wiki/Window_function#:~:text=Blackman%20window</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 The waveform duration.</p> </li> <li> <p>area :  float \u2014 The integral of the waveform.</p> </li> </ul> <p> Example </p> <pre><code>blackman_wf = Blackman(100.0, area=3.14)\n</code></pre> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Blackman.function(t: float) \u2192 float </p> <p> source method Blackman.max() \u2192 float </p> <p> source method Blackman.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class Delay(duration: float, *args: float, **kwargs: float | np.ndarray) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Interpolated(duration: float, values: ArrayLike, times: Optional[ArrayLike] = None, interpolator: str = 'PchipInterpolator', **interpolator_kwargs: Any) </p> <p>Bases : Waveform</p> <p>A waveform created from interpolation of a set of data points.</p> <p>Initializes a new Interpolated waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  int \u2014 The waveform duration (in ns).</p> </li> <li> <p>values :  ArrayLike \u2014 Values of the interpolation points. Must be a list of castable to float or a parametrized object.</p> </li> <li> <p>times :  ArrayLike \u2014 Fractions of the total duration (between 0 and 1), indicating where to place each value on the time axis. Must be a list of castable to float or a parametrized object. If not given, the values are spread evenly throughout the full duration of the waveform.</p> </li> <li> <p>interpolator :  str \u2014 The SciPy interpolation class to use. Supports \"PchipInterpolator\" and \"interp1d\".</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>min</p> </li> <li> <p>max</p> </li> </ul> <p> source method Interpolated.function(t: float) \u2192 float </p> <p> source method Interpolated.min() \u2192 float </p> <p> source method Interpolated.max() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p> <p> source class CompositeWaveform(*waveforms: Waveform) </p> <p>Bases : Waveform</p> <p>Base class for composite waveforms.</p> <p>A CompositeWaveform stores a sequence of waveforms occurring one after the other by the order given. When it is evaluated at time t, the corresponding waveform from the sequence is identified depending on the duration of each one, and it is then evaluated for a time t' = t minus the duration of all previous waveforms.</p> <p>Initializes the CompositeWaveform.</p> <p> Parameters </p> <ul> <li> <p>waveforms :  Waveform \u2014 an iterator over waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Identifies the right waveform in the composition and evaluates it at time t.</p> </li> <li> <p>max \u2014 Get the maximum value of the waveform.</p> </li> </ul> <p> source property CompositeWaveform.durations: list[float] </p> <p>Returns the list of durations of each individual waveform.</p> <p> source property CompositeWaveform.times: list[float] </p> <p>Returns the list of times when each individual waveform starts.</p> <p> source property CompositeWaveform.waveforms: list[Waveform] </p> <p>Returns a list of the individual waveforms.</p> <p> source property CompositeWaveform.n_waveforms: int </p> <p>Returns the number of waveforms.</p> <p> source method CompositeWaveform.function(t: float) \u2192 float </p> <p>Identifies the right waveform in the composition and evaluates it at time t.</p> <p> source method CompositeWaveform.max() \u2192 float </p> <p>Get the maximum value of the waveform.</p> <p> source class Waveform(duration: float, *args: float, **kwargs: float | np.ndarray) </p> <p>Bases : ABC</p> <p>Base class for waveforms.</p> <p>A Waveform is a function of time for t &gt;= 0. Custom waveforms can be defined by inheriting from the base class and overriding the <code>function</code> method corresponding to the function f(t) that returns the value of the waveform evaluated at time t.</p> <p>A waveform is always a 1D function, so if it includes other parameters, these should be passed and saved at initialization for usage within the <code>function</code> method.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Evaluates the waveform function at a given time t.</p> </li> <li> <p>max \u2014 Get the approximate maximum value of the waveform.</p> </li> <li> <p>min \u2014 Get the approximate minimum value of the waveform.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property Waveform.duration: float </p> <p>Returns the duration of the waveform.</p> <p> source property Waveform.params: dict[str, float | np.ndarray] </p> <p>Dictionary of parameters used by the waveform.</p> <p> source method Waveform.function(t: float) \u2192 float </p> <p>Evaluates the waveform function at a given time t.</p> <p> source method Waveform.max() \u2192 float </p> <p>Get the approximate maximum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the maximum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.min() \u2192 float </p> <p>Get the approximate minimum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the minimum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.draw(n_points: int = N_POINTS, return_fig: bool = False, **kwargs: Any) \u2192 Figure | None </p>"},{"location":"api/qoolqit/waveforms/base_waveforms/","title":"qoolqit.waveforms.base_waveforms","text":"qoolqit.waveforms.base_waveforms<p> source module qoolqit.waveforms.base_waveforms </p> <p> Classes </p> <ul> <li> <p>Waveform \u2014 Base class for waveforms.</p> </li> <li> <p>CompositeWaveform \u2014 Base class for composite waveforms.</p> </li> </ul> <p> source class Waveform(duration: float, *args: float, **kwargs: float | np.ndarray) </p> <p>Bases : ABC</p> <p>Base class for waveforms.</p> <p>A Waveform is a function of time for t &gt;= 0. Custom waveforms can be defined by inheriting from the base class and overriding the <code>function</code> method corresponding to the function f(t) that returns the value of the waveform evaluated at time t.</p> <p>A waveform is always a 1D function, so if it includes other parameters, these should be passed and saved at initialization for usage within the <code>function</code> method.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Evaluates the waveform function at a given time t.</p> </li> <li> <p>max \u2014 Get the approximate maximum value of the waveform.</p> </li> <li> <p>min \u2014 Get the approximate minimum value of the waveform.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property Waveform.duration: float </p> <p>Returns the duration of the waveform.</p> <p> source property Waveform.params: dict[str, float | np.ndarray] </p> <p>Dictionary of parameters used by the waveform.</p> <p> source method Waveform.function(t: float) \u2192 float </p> <p>Evaluates the waveform function at a given time t.</p> <p> source method Waveform.max() \u2192 float </p> <p>Get the approximate maximum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the maximum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.min() \u2192 float </p> <p>Get the approximate minimum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the minimum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.draw(n_points: int = N_POINTS, return_fig: bool = False, **kwargs: Any) \u2192 Figure | None </p> <p> source class CompositeWaveform(*waveforms: Waveform) </p> <p>Bases : Waveform</p> <p>Base class for composite waveforms.</p> <p>A CompositeWaveform stores a sequence of waveforms occurring one after the other by the order given. When it is evaluated at time t, the corresponding waveform from the sequence is identified depending on the duration of each one, and it is then evaluated for a time t' = t minus the duration of all previous waveforms.</p> <p>Initializes the CompositeWaveform.</p> <p> Parameters </p> <ul> <li> <p>waveforms :  Waveform \u2014 an iterator over waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Identifies the right waveform in the composition and evaluates it at time t.</p> </li> <li> <p>max \u2014 Get the maximum value of the waveform.</p> </li> </ul> <p> source property CompositeWaveform.durations: list[float] </p> <p>Returns the list of durations of each individual waveform.</p> <p> source property CompositeWaveform.times: list[float] </p> <p>Returns the list of times when each individual waveform starts.</p> <p> source property CompositeWaveform.waveforms: list[Waveform] </p> <p>Returns a list of the individual waveforms.</p> <p> source property CompositeWaveform.n_waveforms: int </p> <p>Returns the number of waveforms.</p> <p> source method CompositeWaveform.function(t: float) \u2192 float </p> <p>Identifies the right waveform in the composition and evaluates it at time t.</p> <p> source method CompositeWaveform.max() \u2192 float </p> <p>Get the maximum value of the waveform.</p>"},{"location":"api/qoolqit/waveforms/utils/","title":"qoolqit.waveforms.utils","text":"qoolqit.waveforms.utils<p> source module qoolqit.waveforms.utils </p> <p> Functions </p> <ul> <li> <p>round_to_sum \u2014 Round a list of numbers such that their sum is the rounded sum.</p> </li> </ul> <p> source round_to_sum(values: list[float]) \u2192 list[int] </p> <p>Round a list of numbers such that their sum is the rounded sum.</p> <p>\u03a3\u1d62round(a\u1d62) = round(\u03a3\u1d62a\u1d62)</p> <p> Example </p> <pre><code>&gt;&gt;&gt; round_to_sum([100.3, 100.3, 100.4])\n&gt;&gt;&gt; [100, 100, 101]\n</code></pre>"},{"location":"api/qoolqit/waveforms/waveforms/","title":"qoolqit.waveforms.waveforms","text":"qoolqit.waveforms.waveforms<p> source module qoolqit.waveforms.waveforms </p> <p> Classes </p> <ul> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>Blackman \u2014 A Blackman window of a specified duration and area under the curve.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Interpolated \u2014 A waveform created from interpolation of a set of data points.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> </ul> <p> source class Delay(duration: float, *args: float, **kwargs: float | np.ndarray) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class Blackman(duration: float, area: float) </p> <p>Bases : Waveform</p> <p>A Blackman window of a specified duration and area under the curve.</p> <p>Implements the Blackman window shaped waveform     blackman(t) = A(0.42 - 0.5cos(\u03b1t) + 0.08cos(2\u03b1t))               A = area/(0.42duration)               \u03b1 = 2\u03c0/duration</p> <p>Initializes a new Blackman waveform.</p> <p> See </p> <p>https://en.wikipedia.org/wiki/Window_function#:~:text=Blackman%20window</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 The waveform duration.</p> </li> <li> <p>area :  float \u2014 The integral of the waveform.</p> </li> </ul> <p> Example </p> <pre><code>blackman_wf = Blackman(100.0, area=3.14)\n</code></pre> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Blackman.function(t: float) \u2192 float </p> <p> source method Blackman.max() \u2192 float </p> <p> source method Blackman.min() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Interpolated(duration: float, values: ArrayLike, times: Optional[ArrayLike] = None, interpolator: str = 'PchipInterpolator', **interpolator_kwargs: Any) </p> <p>Bases : Waveform</p> <p>A waveform created from interpolation of a set of data points.</p> <p>Initializes a new Interpolated waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  int \u2014 The waveform duration (in ns).</p> </li> <li> <p>values :  ArrayLike \u2014 Values of the interpolation points. Must be a list of castable to float or a parametrized object.</p> </li> <li> <p>times :  ArrayLike \u2014 Fractions of the total duration (between 0 and 1), indicating where to place each value on the time axis. Must be a list of castable to float or a parametrized object. If not given, the values are spread evenly throughout the full duration of the waveform.</p> </li> <li> <p>interpolator :  str \u2014 The SciPy interpolation class to use. Supports \"PchipInterpolator\" and \"interp1d\".</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>min</p> </li> <li> <p>max</p> </li> </ul> <p> source method Interpolated.function(t: float) \u2192 float </p> <p> source method Interpolated.min() \u2192 float </p> <p> source method Interpolated.max() \u2192 float </p> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float | np.ndarray] \u2014 Dictionary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p>"},{"location":"api/qoolqit/drive/","title":"qoolqit.drive","text":"qoolqit.drive<p> source module qoolqit.drive </p> <p> Classes </p> <ul> <li> <p>WeightedDetuning \u2014 A weighted detuning.</p> </li> <li> <p>Drive \u2014 The drive Hamiltonian acting over a duration.</p> </li> </ul> <p> source dataclass WeightedDetuning(weights: dict[Any, float], waveform: Waveform) </p> <p>A weighted detuning.</p> <p>See https://pasqal-io.github.io/qoolqit/latest/theory/rydberg_model/#weighted-detuning for details on weighted detunings.</p> <p>Note: detuning with positive waveforms cannot be instantiated.</p> <p> Attributes </p> <ul> <li> <p>weights :  dict[Any, float] \u2014 Association of weights to qubits.</p> </li> <li> <p>waveform :  Waveform \u2014 The waveform for this detuning.</p> </li> </ul> <p> source class Drive(*args: Any, amplitude: Waveform | None = None, detuning: Waveform | None = None, weighted_detunings: list[WeightedDetuning] | None = None, phase: float = 0.0) </p> <p>The drive Hamiltonian acting over a duration.</p> <p>Default constructor for the Drive.</p> <p>Must be instantiated with keyword arguments. Accepts either an amplitude waveform, a detuning waveform, or both. A phase value can also be passed.</p> <p> Parameters </p> <ul> <li> <p>amplitude :  Waveform | None \u2014 waveform representing \u03a9(t) in the drive Hamiltonian.</p> </li> <li> <p>detuning :  Waveform | None \u2014 waveform representing \u03b4(t) in the drive Hamiltonian.</p> </li> <li> <p>phase :  float \u2014 phase value \u0278 for the amplitude term.</p> </li> <li> <p>weighted_detunings :  list[WeightedDetuning] | None \u2014 additional waveforms and weights applied to individual qubits. Note that these detunings are not supported on all devices.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>amplitude :  Waveform \u2014 The amplitude waveform in the drive.</p> </li> <li> <p>detuning :  Waveform \u2014 The detuning waveform in the drive.</p> </li> <li> <p>weighted_detunings :  Sequence[WeightedDetuning] \u2014 Detunings applied to individual qubits.</p> </li> <li> <p>phase :  float \u2014 The phase value in the drive.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw</p> </li> </ul> <p> source property Drive.amplitude: Waveform </p> <p>The amplitude waveform in the drive.</p> <p> source property Drive.detuning: Waveform </p> <p>The detuning waveform in the drive.</p> <p> source property Drive.weighted_detunings: Sequence[WeightedDetuning] </p> <p>Detunings applied to individual qubits.</p> <p> source property Drive.phase: float </p> <p>The phase value in the drive.</p> <p> source property Drive.duration: float </p> <p> source method Drive.draw(n_points: int = 500, return_fig: bool = False) \u2192 Figure | None </p>"},{"location":"api/qoolqit/exceptions/","title":"qoolqit.exceptions","text":"qoolqit.exceptions<p> source module qoolqit.exceptions </p> <p> Classes </p> <ul> <li> <p>CompilationError \u2014 An error raised when attempting to compile a program into a Pulser Sequence.</p> </li> </ul> <p> source class CompilationError() </p> <p>Bases : Exception</p> <p>An error raised when attempting to compile a program into a Pulser Sequence.</p>"},{"location":"api/qoolqit/program/","title":"qoolqit.program","text":"qoolqit.program<p> source module qoolqit.program </p> <p> Classes </p> <ul> <li> <p>QuantumProgram \u2014 A program representing a Sequence acting on a Register of qubits.</p> </li> </ul> <p> source class QuantumProgram(register: Register, drive: Drive) </p> <p>A program representing a Sequence acting on a Register of qubits.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the register of qubits, defining their positions.</p> </li> <li> <p>drive :  Drive \u2014 the drive acting on qubits, defining amplitude, detuning and phase.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>register :  Register \u2014 The register of qubits.</p> </li> <li> <p>drive :  Drive \u2014 The driving waveforms.</p> </li> <li> <p>is_compiled :  bool \u2014 Check if the program has been compiled.</p> </li> <li> <p>compiled_sequence :  PulserSequence \u2014 The Pulser sequence compiled to a specific device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_to \u2014 Compiles the given program to a device.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property QuantumProgram.register: Register </p> <p>The register of qubits.</p> <p> source property QuantumProgram.drive: Drive </p> <p>The driving waveforms.</p> <p> source property QuantumProgram.is_compiled: bool </p> <p>Check if the program has been compiled.</p> <p> source property QuantumProgram.compiled_sequence: PulserSequence </p> <p>The Pulser sequence compiled to a specific device.</p> <p> source method QuantumProgram.compile_to(device: Device, profile: CompilerProfile = CompilerProfile.DEFAULT) \u2192 None </p> <p>Compiles the given program to a device.</p> <p> Parameters </p> <ul> <li> <p>device :  Device \u2014 the Device to compile to.</p> </li> <li> <p>profile :  CompilerProfile \u2014 the compiler profile to use during compilation.</p> </li> </ul> <p> source method QuantumProgram.draw(n_points: int = 500, compiled: bool = False, return_fig: bool = False) \u2192 Figure | None </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/qoolqit/register/","title":"qoolqit.register","text":"qoolqit.register<p> source module qoolqit.register </p> <p> Classes </p> <ul> <li> <p>Register \u2014 The Register in QoolQit, representing a set of qubits with coordinates.</p> </li> </ul> <p> source class Register(qubits: dict) </p> <p>The Register in QoolQit, representing a set of qubits with coordinates.</p> <p>Default constructor for the Register.</p> <p> Parameters </p> <ul> <li> <p>qubits :  dict \u2014 a dictionary of qubits and respective coordinates {q: (x, y), ...}.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>qubits :  dict \u2014 Returns the dictionary of qubits and respective coordinates.</p> </li> <li> <p>qubits_ids :  list \u2014 Returns the qubit keys.</p> </li> <li> <p>n_qubits :  int \u2014 Number of qubits in the Register.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_graph \u2014 Initializes a Register from a graph that has coordinates.</p> </li> <li> <p>from_coordinates \u2014 Initializes a Register from a list of coordinates.</p> </li> <li> <p>distances \u2014 Distance between each qubit pair.</p> </li> <li> <p>min_distance \u2014 Minimum distance between all qubit pairs.</p> </li> <li> <p>radial_distances \u2014 Radial distance of each qubit from the origin.</p> </li> <li> <p>max_radial_distance \u2014 Maximum radial distance between all qubits.</p> </li> <li> <p>interactions \u2014 Interaction 1/r^6 between each qubit pair.</p> </li> <li> <p>draw \u2014 Draw the register.</p> </li> </ul> <p> source classmethod Register.from_graph(graph: DataGraph) \u2192 Register </p> <p>Initializes a Register from a graph that has coordinates.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 a DataGraph instance.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod Register.from_coordinates(coords: list) \u2192 Register </p> <p>Initializes a Register from a list of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list \u2014 a list of coordinates [(x, y), ...]</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source property Register.qubits: dict </p> <p>Returns the dictionary of qubits and respective coordinates.</p> <p> source property Register.qubits_ids: list </p> <p>Returns the qubit keys.</p> <p> source property Register.n_qubits: int </p> <p>Number of qubits in the Register.</p> <p> source method Register.distances() \u2192 dict </p> <p>Distance between each qubit pair.</p> <p> source method Register.min_distance() \u2192 float </p> <p>Minimum distance between all qubit pairs.</p> <p> source method Register.radial_distances() \u2192 dict </p> <p>Radial distance of each qubit from the origin.</p> <p> source method Register.max_radial_distance() \u2192 float </p> <p>Maximum radial distance between all qubits.</p> <p> source method Register.interactions() \u2192 dict </p> <p>Interaction 1/r^6 between each qubit pair.</p> <p> source method Register.draw(return_fig: bool = False) \u2192 plt.Figure | None </p> <p>Draw the register.</p> <p> Parameters </p> <ul> <li> <p>return_fig :  bool \u2014 boolean argument to return the plt.Figure instance.</p> </li> </ul>"},{"location":"api/qoolqit/utils/","title":"qoolqit.utils","text":"qoolqit.utils<p> source module qoolqit.utils </p> <p> Classes </p> <ul> <li> <p>CustomEnumMeta</p> </li> <li> <p>StrEnum</p> </li> </ul> <p> Functions </p> <ul> <li> <p>EQUAL</p> </li> </ul> <p> source EQUAL(a: float, b: float, rtol: float = 0.0, atol: float = ATOL_32) \u2192 bool </p> <p> source class CustomEnumMeta() </p> <p>Bases : EnumMeta</p> <p> source enum StrEnum(*args, **kwds) </p> <p>Bases : str, Enum</p> <p> Methods </p> <ul> <li> <p>list</p> </li> </ul> <p> source classmethod StrEnum.list(values: bool = False) \u2192 list </p>"}]}