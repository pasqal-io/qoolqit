{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"CONTRIBUTOR%20AGREEMENT/","title":"Contributor Agreement","text":"<p>PASQAL CONTRIBUTION AGREEMENT (the \u201cAgreement\u201d)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <p>In the course of its activities, Pasqal carries out and leads quantic projects, in their software components. These projects aim to bring together a community of like-minded individuals to contribute to the development and improvement of Pasqal\u2019s products. Pasqal clearly outlines which projects are open to contributions (\u201cProjects\u201d).</p> <p>This Agreement documents the rights granted by Contributors to Pasqal and is legally binding.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-1-definitions","title":"Article 1 Definitions","text":"<p>You, Your or Contributor : means the intellectual property rights owner or legal entity authorized by the intellectual property rights owner that is entering into this Agreement with\u00a0Pasqal</p> <p>Contribution : means any work, protected or not, that is submitted by You to Pasqal in which You own or assert ownership of the intellectual property rights, subject to proprietary licensing terms, and not otherwise distributer through an open-source license.</p> <p>Material : means the work object of the Project, made available by Pasqal to third parties. When this Agreement covers more than one Project, the Material means the work to which the Contribution was Submitted. After You Submit the Contribution, it may be included in any type of Material.</p> <p>Submit : means any form of electronic, verbal, or written communication sent to Pasqal or its representatives, including but not limited to electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Pasqal for the purpose of discussing and improving the Material.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-2-entering-into-this-agreement","title":"Article 2 Entering into this Agreement","text":"<p>By Submitting any Contribution to Pasqal, You agree to enter into the Agreement with this entity, and be bound by the following terms.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-3-limitations-as-to-the-licensing-of-contributions","title":"Article 3 Limitations as to the licensing of Contributions","text":"<p>You guarantee that any Contribution You Submit to any Project is not licensed under any type of contaminating (even weakly contaminating) license, and that Pasqal will be free to combine your Contribution into any type of Material, for any Project, without any risk of contamination of said Material and/or Project.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-4-granting-of-a-copyright-andor-authors-rights-license","title":"Article 4 Granting of a Copyright and/or author\u2019s rights License","text":"<p>Subject to the terms and conditions of this Agreement, You hereby grant to Pasqal and to recipients of any Project distributed by Pasqal a worldwide, sublicensable, non-exclusive, royalty-free license to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute Your Contributions and your Contribution in combination with the Material for the entire duration of the rights under Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-5-granting-of-a-patent-license","title":"Article 5 Granting of a patent license","text":"<p>Subject to the terms and conditions of this Agreement, You grant Pasqal a, worldwide, non-exclusive, transferable, royalty free patent license, with the right to sublicense these rights to third parties, to make, have made, use, sell, offer for sale, import and otherwise  transfer the Contribution and the Contribution in combination with the Material for the entire duration of the rights under Applicable law, if the Contribution implies the implementation of any such patent.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-6-licensing-of-the-material-and-contribution","title":"Article 6 Licensing of the Material and Contribution","text":"<p>Based on the rights granted in articles 2 and 3, if Pasqal includes Your Contribution in a Material, Pasqal may license Material including Your Contribution under any license, whether permissive, weakly contaminating, or contaminating. Pasqal will respect Your moral rights in relation to Your Contribution as provided under the Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-7-warranties-and-disclaimer","title":"Article 7 Warranties and disclaimer","text":"<p>You represent that each of Your Contributions is Your creation, or that you have obtained the authorization from the intellectual property rights owner on the Contribution to Submit it over the course of a Project.</p> <p>By making a Contribution, You confirm that, to the best of Your knowledge, the Contribution does not violate the rights of any person or entity. If You make a Contribution on behalf of Your employer, then You confirm that an appropriate representative of that employer has authorized the inclusion of such Contribution to a Project and that it meets these requirements.</p> <p>You acknowledge that Pasqal is not obligated to use Your Contribution as part of the Material and may decide to only include Contributions Pasqal considers appropriate.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-8-applicable-law-and-jurisdiction","title":"Article 8 Applicable law and jurisdiction","text":"<p>The Agreement is governed by the laws of France. Any dispute relating to the interpretation or application of the License shall be subject to best efforts for an amicable settlement. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p>"},{"location":"LICENSE/","title":"Licence (MIT-Derived)","text":"<p>PASQAL OPEN-SOURCE SOFTWARE LICENSE AGREEMENT (MIT-derived)</p> <p>The author of the License is:   Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <ul> <li> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the \u201cLicensee\u201d) and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software is \u201cas is\u201d, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise arising from, out of or in connection with the Software or the use or other dealings in the Software.</p> </li> <li> <p>If use of the Software leads to the necessary use of any patent of the Licensor and/or any of its Affiliates (defined as a company owned or controlled by the Licensor), the Licensee is granted a royalty-free license, in any country where such patent is in force, to use the object of such patent; or use the process covered by such patent,</p> </li> <li> <p>Such a patent license is granted for internal research or academic use of the Licensee's, which includes use by employees and students of the Licensee, acting on behalf of the Licensee, for research purposes only.</p> </li> <li> <p>The License is governed by the laws of France. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p> </li> </ul>"},{"location":"contents/devices/","title":"Initializing quantum devices","text":"<p>Each <code>Device</code> in QoolQit wraps a Pulser device and defines the hardware characteristics that the program will be compiled to and later executed on.</p> <pre><code>from qoolqit import MockDevice, AnalogDevice\n\n# An example of an ideal device\ndevice_ideal = MockDevice()\n\n# An example of a real device\ndevice_real = AnalogDevice()\n</code></pre> <p>Each device has a default unit converter. These are the unit values that will be used when converting an adimensional program in the Rydberg analog model to the physical units of Pulser devices for hardware execution.</p> <pre><code>device_real.converter\n</code></pre> <pre><code>UnitConverter(time=79.57747154594767, energy=12.566370614359172, distance=6.402675875387433)\n</code></pre> <p>The converter handles the logic of converting the adimensional QoolQit model to Pulser units. For theoretical details on how this conversion works between the Rydberg analog model and the implementation that Pulser uses you can check the Rydberg analog model page</p> <p>By default, each device creates a default converter where the energy unit is set as that device's maximum amplitude. If you make no changes to the device's converter, this means that amplitude values in the range \\([0, 1]\\) will be converted to values in the range \\([0, \\Omega_\\text{max}]\\).</p> <p>For advanced users, customizing the unit conversion factors is possible.</p> <pre><code>device_real.set_time_unit(50.0)\n\ndevice_real.set_energy_unit(10.0)\n\ndevice_real.set_distance_unit(6.0)\n</code></pre> <pre><code>UnitConverter(time=50.0, energy=20.0, distance=5.925497624483338)\nUnitConverter(time=100.0, energy=10.0, distance=6.651146200829891)\nUnitConverter(time=53.89252557937064, energy=18.555448816872428, distance=6.0)\n</code></pre> <p>Restoring the default unit converter is also possible.</p> <pre><code>device_real.reset_converter()\n</code></pre> <pre><code>UnitConverter(time=79.57747154594767, energy=12.566370614359172, distance=6.402675875387433)\n</code></pre>"},{"location":"contents/drives/","title":"Writing the drive Hamiltonian","text":"<p>The <code>Drive</code> is a composition of waveforms defining the drive Hamiltonian.</p> <pre><code>from qoolqit import Constant, Ramp\nfrom qoolqit import Drive\n\n# Defining two waveforms\nwf0 = Constant(0.5, 1.0) &gt;&gt; Ramp(1.0, 0.0, 0.5)\nwf1 = Ramp(2.0, -1.0, 1.0) &gt;&gt; Constant(1.0, 1.0)\n\n# Defining the drive\ndrive = Drive(\n    amplitude = wf0,\n    detuning = wf1\n)\n\n# Expanding the drive through composition\ndrive = drive &gt;&gt; drive\n</code></pre> <pre><code>Amplitude: \n| 0 \u2264 t &lt; 3: | 0 \u2264 t &lt; 1.5: | 0 \u2264 t &lt; 0.5: Constant(t, 1)\n| 0.5 \u2264 t \u2264 1.5: Ramp(t, 0, 0.5)\n| 1.5 \u2264 t \u2264 3: Delay(t)\n| 3 \u2264 t \u2264 6: | 0 \u2264 t &lt; 1.5: | 0 \u2264 t &lt; 0.5: Constant(t, 1)\n| 0.5 \u2264 t \u2264 1.5: Ramp(t, 0, 0.5)\n| 1.5 \u2264 t \u2264 3: Delay(t)\n\nDetuning: \n| 0 \u2264 t &lt; 3: | 0 \u2264 t &lt; 2: Ramp(t, -1, 1)\n| 2 \u2264 t \u2264 3: Constant(t, 1)\n| 3 \u2264 t \u2264 6: | 0 \u2264 t &lt; 2: Ramp(t, -1, 1)\n| 2 \u2264 t \u2264 3: Constant(t, 1)\n</code></pre> <pre><code>drive.draw()\n</code></pre> 2025-06-10T12:44:30.022849 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/graphs/","title":"Standard structure for Graphs","text":"<p>Working with graphs is an essential part of computations with the Rydberg analog model. For that reason, QoolQit implements a specific <code>DataGraph</code> class to serve as the basis of all graph creation and manipulation, and setting the logic related to unit-disk graphs. QoolQit integrates with NetworkX for many operations, and the <code>DataGraph</code> inherits from <code>nx.Graph</code>.</p>"},{"location":"contents/graphs/#basic-construction","title":"Basic construction","text":"<p>The <code>DataGraph</code> is an undirected graph with no self loops. The default way to instantiate a <code>DataGraph</code> is with a set of edges.</p> <pre><code>from qoolqit import DataGraph\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngraph = DataGraph(edges)\n</code></pre> <p>Later in the graph constructors section we also describe how to construct graphs from sets of coordinates, or with built-in constructors.</p> <p>As with any NetworkX graph, the set of nodes and edges can be accessed:</p> <p><pre><code>print(graph.nodes)\n</code></pre> <pre><code>[0, 1, 2, 3]\n</code></pre> <pre><code>print(graph.edges)\n</code></pre> <pre><code>[(0, 1), (0, 3), (1, 2), (2, 3)]\n</code></pre> </p> <p>These are the standard <code>NodeView</code> and <code>EdgeView</code> objects from NetworkX, and thus can be used add and access node and edge attributes.</p>"},{"location":"contents/graphs/#drawing","title":"Drawing","text":"<p>We can draw the graph with <code>graph.draw()</code>, which calls <code>draw_networkx</code>. As such, optional arguments can be passed that will be fed to NetworkX. <pre><code>import networkx as nx\n\npos = nx.circular_layout(graph)\n\ngraph.draw(pos = pos)\n</code></pre> 2025-06-10T12:44:30.130854 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ </p>"},{"location":"contents/graphs/#coordinates-and-distances","title":"Coordinates and distances","text":"<p>One convenient property added by QoolQit is the <code>sorted_edges</code>, which guarantees that the indices in each edge tuple are always provided as \\((u, v):u&lt;v\\). This condition is not guaranteed by calling the NetworkX property <code>graph.edges</code>, but is sometimes useful.</p> <pre><code>print(graph.sorted_edges)\n</code></pre> <pre><code>{(0, 1), (1, 2), (0, 3), (2, 3)}\n</code></pre> <p>Another convenient property is accessing the pairs of all nodes in the graph, which again follow the convention of \\((u, v):u&lt;v\\). <pre><code>print(graph.all_node_pairs)\n</code></pre> <pre><code>{(0, 1), (1, 2), (0, 3), (2, 3), (0, 2), (1, 3)}\n</code></pre> </p> <p>In QoolQit a set of attributes that takes center stage when dealing with graphs are the node coordinates. These are essential for the Rydberg analog model as they directly translate to qubit positions that define the interaction term in the Hamiltonian. This behaviour has a close connection with the study of unit-disk graphs, where node coordinates are also essential. The coordinates can be set directly in the respective property:</p> <p><pre><code># The list must have the same length as the number of nodes:\ngraph.coords = [(-0.5, -0.5), (-0.5, 0.5), (0.5, 0.5), (0.5, -0.5)]\n\ngraph.coords\n</code></pre> <pre><code>{0: (-0.5, -0.5), 1: (-0.5, 0.5), 2: (0.5, 0.5), 3: (0.5, -0.5)}\n</code></pre>  Both a dictionary or a list can be passed, which will be converted to a dictionary. Because the graph now has a set of node coordinates, we can directly access the distance between the nodes. Optionally, a set of node pairs can be given and only those distances will be computed.</p> <pre><code># Compute for all node pairs\ngraph.distances()\n\n# Compute only for connected nodes\ngraph.distances(graph.sorted_edges)\n\n# Compute for a specific set of node pairs\ngraph.distances([(0, 1), (0, 2)])\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 1.0, (0, 3): 1.0, (2, 3): 1.0, (0, 2): 1.4142135623730951, (1, 3): 1.4142135623730951}\n{(0, 1): 1.0, (1, 2): 1.0, (0, 3): 1.0, (2, 3): 1.0}\n{(0, 1): 1.0, (0, 2): 1.4142135623730951}\n</code></pre> <p>Note</p> <p>Accessing distances as NumPy arrays or Torch tensors will be designed later.</p> <p>Furthermore, when calling <code>graph.draw()</code> the coordinate information will be automatically used.</p> <pre><code>graph.draw()\n</code></pre> 2025-06-10T12:44:30.190478 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Graph coordinates can be rescaled. The <code>rescale_coords</code> method only accepts a keyword argument, which must be either <code>scaling</code> or <code>spacing</code>.</p> <pre><code># Rescale coordinates by a constant factor\ngraph.rescale_coords(scaling = 2.0)\n\n# Rescale coordinates by setting the minimum spacing\ngraph.rescale_coords(spacing = 1.0)\n</code></pre> <p>The minimum and maximum distance can be directly checked.</p> <pre><code># Compute for all node pairs\ngraph.min_distance()\ngraph.max_distance()\n\n# Compute only for connected nodes\ngraph.min_distance(connected = True)\n\n# Compute only for disconnected nodes\ngraph.min_distance(connected = False)\n</code></pre>"},{"location":"contents/graphs/#unit-disk-graphs","title":"Unit-disk graphs","text":"<p>Working with node coordinates and distances is an essential part of dealing with unit-disk graphs.</p> <p>Definition: Unit-Disk Graphs</p> <p>For a set of nodes \\(V\\), each node \\(i\\in V\\) marked by a set of coordinates \\((x, y)_i\\) in Euclidean space, a set of edges \\(E\\) and a radius \\(R\\), a Unit-Disk Graph \\(UDG(V, E, R)\\) is such that there exists an edge \\((i, j)\\in E\\) for two nodes \\(i\\) and \\(j\\) if and only if \\(\\text{dist}(i, j) \\leq R\\), where \\(\\text{dist}(i, j)\\) is the Euclidean distance between the coordinates of nodes \\(i\\) and \\(j\\).</p> <p>In other words, a unit-disk graph for a radius \\(R\\) is the graph where the set of edges corresponds to the intersections of disks of radius \\(R/2\\) centered at each node position in Euclidean space.</p> <p>For a <code>DataGraph</code> with a set of node coordinates, we can check if it is a valid unit-disk graph</p> <pre><code>graph.is_ud_graph()\n</code></pre> <pre><code>True\n</code></pre> <p>This method checks that <code>graph.max_distance(connected = True)</code> is smaller than <code>graph.min_distance(connected = True)</code>. If this is <code>True</code>, then for every value of \\(R\\) inside that interval the unit-disk condition is met. We can easily check this.</p> <p>First, we can check the set of edges given by the intersection of unit disks:</p> <pre><code># For a small value no disks intersect, the set is empty\nud_edges = graph.ud_edges(radius = 0.1)\n\n# For a large enough value all disks intersect\nud_edges = graph.ud_edges(radius = 50.0)\n\nassert ud_edges == graph.all_node_pairs\n</code></pre> <pre><code>Radius = 0.1:  set()\nRadius = 50.0:  {(0, 1), (1, 2), (0, 3), (2, 3), (0, 2), (1, 3)}\n</code></pre> <p>Now, we can randomly pick a value or \\(R\\) matching the unit-disk condition and verify that the set of unit-disk edges exactly match the set of edges in the graph. The possible range of values is directly available with the <code>ud_radius_range()</code> method.</p> <pre><code>import numpy as np\n\nlow, high = graph.ud_radius_range()\n\nR = np.random.uniform(low, high)\n\nprint(graph.ud_edges(radius = R) == graph.sorted_edges)\n</code></pre> <pre><code>True\n</code></pre> <p>We can also reset the set of edges on a graph to be equal to the set of unit-disk edges for a given radius with <code>graph.set_ud_edges(radius = R)</code>. For this example we will not run this line, but we show it later when constructing a graph from a set of coordinates.</p>"},{"location":"contents/graphs/#node-and-edge-weights","title":"Node and edge weights","text":"<p>Another two important attributes are node weights and edge weights:</p> <pre><code>import random\n\ngraph.node_weights = {i: random.random() for i in graph.nodes}\ngraph.edge_weights = {edge: random.random() for edge in graph.sorted_edges}\n</code></pre> <p>If the graph does not have these attributes, the dictionaries will still be returned with <code>None</code> in place of the value. A set of boolean properties allows quickly checking if the graph has coordinates or weights. It only returns <code>True</code> if there is a value set for every node / edge in the graph.</p> <p>Note</p> <p>Accessing weights as NumPy arrays or Torch tensors will be designed later.</p> <pre><code>assert graph.has_coords\nassert graph.has_node_weights\nassert graph.has_edge_weights\n</code></pre> <p></p>"},{"location":"contents/graphs/#graph-constructors","title":"Graph constructors","text":"<p>Class constructors can help you create a variety of graphs. A very useful constructor is starting from a set of coordinates. By default that will create an empty set of edges, but we can use the <code>set_ud_edges</code> method to specify the edges as the unit-disk intersections.</p> <pre><code>from qoolqit import DataGraph\n\ncoords = [(-1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (0.0, -1.0)]\n\ngraph = DataGraph.from_coordinates(coords)\n\nassert len(graph.edges) == 0\n\ngraph.set_ud_edges(radius = 1.0)\n\nassert len(graph.edges) &gt; 0\n\ngraph.draw()\n</code></pre> 2025-06-10T12:44:30.281954 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Some geometric graph constructors will already have coordinates by default.</p> <pre><code>from qoolqit import DataGraph\n\n# A line graph on n nodes.\ngraph = DataGraph.line(n = 10, spacing = 1.0)\n\n# A circle graph on n nodes.\ngraph = DataGraph.circle(n = 10, spacing = 1.0, center = (0.0, 0.0))\n\n# An random UD graph by uniformly sampling points in area of side L\ngraph = DataGraph.random_ud(n = 10, radius = 1.0, L = 2.0)\n\ngraph.draw()\n</code></pre> 2025-06-10T12:44:30.357987 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Other generic constructors are also available which have no information on node coordinates.</p> <pre><code># An Erd\u0151s\u2013R\u00e9nyi random graph\ngraph = DataGraph.random_er(n = 10, p = 0.5)\n\ngraph.draw()\n</code></pre> 2025-06-10T12:44:30.444283 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/graphs/#loading-from-a-matrix","title":"Loading from a matrix","text":"<p>Loading an adjacency matrix into a graph is also possible.</p> <ul> <li>Given that graphs in QoolQit are undirected, the matrix must be symmetric.</li> <li>As in the standard adjacency matrix interpretation, off-diagonal elements are loaded as edge-weights as long as they are non-zero.</li> <li>Given that QoolQit does not consider graphs with self-loops, diagonal elements are loaded as node-weights.</li> </ul> <pre><code>import numpy as np\n\nn_nodes = 5\ndata = np.random.rand(n_nodes, n_nodes)\n\n# Matrix must be symmetric\ndata = data + data.T\n\ngraph = DataGraph.from_matrix(data)\n\nassert graph.has_node_weights\nassert graph.has_edge_weights\n</code></pre> <p>If all values in the diagonal are 0, then no node-weights will be set. Furthermore, edges and edge-weights will only be set for non-zero off-diagonal elements.</p> <pre><code># Setting the diagonal to zero\nnp.fill_diagonal(data, 0.0)\n\n# Removing the value for the pair (1, 2)\ndata[1, 2] = 0.0\ndata[2, 1] = 0.0\n\ngraph = DataGraph.from_matrix(data)\n\n# Checking there are no node weights and the edge (1, 2) was not added\nassert not graph.has_node_weights\nassert (1, 2) not in graph.edges\n</code></pre>"},{"location":"contents/programs/","title":"Creating a quantum program","text":"<p>A <code>QuantumProgram</code> combines a <code>Register</code> and a <code>Drive</code> and serves as the main interface for compilation and execution.</p> <pre><code>from qoolqit import PiecewiseLinear\nfrom qoolqit import Register, Drive, QuantumProgram\n\n# Defining the Drive\nwf0 = PiecewiseLinear([1.0, 2.0, 1.0], [0.0, 0.5, 0.5, 0.0])\nwf1 = PiecewiseLinear([1.0, 2.0, 1.0], [-1.0, -1.0, 1.0, 1.0])\ndrive = Drive(amplitude = wf0, detuning = wf1)\n\n# Defining the Register\ncoords = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]\nregister = Register.from_coordinates(coords)\n\n# Creating the Program\nprogram = QuantumProgram(register, drive)\n</code></pre> <pre><code>Quantum Program:\n| Register(n_qubits = 4)\n| Drive(duration = 4)\n| Compiled: False\n</code></pre> <p>At this point, the program has not been compiled to any device. As shown above, this is conveniently displayed when printing the program. It can also be checked through the <code>is_compiled</code> property.</p> <pre><code>program.is_compiled\n</code></pre> <pre><code>False\n</code></pre> <p>Now we instantiate a device and compile the program to that device. Compiling in QoolQit means to translate the adimensional values of time, energy, and distance used when defining the program in the Rydberg analog model to a specific set of values that implement the same set of instructions in a Pulser device, taking into account the Pulser units and the specific parameters of that device. More detailed information on this conversion is provided in the Rydberg analog model page.</p> <pre><code>from qoolqit import AnalogDevice\n\ndevice = AnalogDevice()\n\nprogram.compile_to(device)\n</code></pre> <pre><code>Quantum Program:\n| Register(n_qubits = 4)\n| Drive(duration = 4)\n| Compiled: True\n| Device: AnalogDevice\n</code></pre> <p>Now that the program has been compiled, we can inspect the compiled sequence, which is an instance of a Pulser <code>Sequence</code>.</p> <pre><code>pulser_sequence = program.compiled_sequence\n</code></pre> <p>Finally, we can draw both the original program and the compiled sequence.</p> <pre><code>program.draw()\n</code></pre> 2025-06-10T12:44:30.599115 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <pre><code>program.draw(compiled = True)\n</code></pre> 2025-06-10T12:44:30.735007 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/programs/#compiler-profiles","title":"Compiler profiles","text":"<p>In the example above the <code>AnalogDevice</code> was used, and no changes were made to the unit converter. As such, the default was used, which sets the reference energy unit as the maximum amplitude, as described in the Devices page.</p> <p>When a QoolQit program is compiled to Pulser, several compiler profiles can be used. You can check them in the following enumeration:</p> <pre><code>from qoolqit import CompilerProfile\n\nprint(CompilerProfile)\n</code></pre> <pre><code>&lt;Enum 'CompilerProfile':\n| DEFAULT = 'Default'\n| MAX_AMPLITUDE = 'MaxAmplitude'\n| MAX_DURATION = 'MaxDuration'\n| MIN_DISTANCE = 'MinDistance'&gt;\n</code></pre> <p>By default <code>CompilerProfile.DEFAULT</code> is used, which directly takes the unit converter present in the device and uses it when converting the values.</p> <p>Other compiler profiles will ignore the unit converter present in the device and utilize their own logic to determine the best possible conversion to achieve a desired compilation directive.</p> <p>The <code>CompilerProfile.MAX_AMPLITUDE</code> maps whatever is the maximum amplitude in the drive of your QoolQit program to the device's maximum allowed amplitude: <pre><code>program.compile_to(device, profile = CompilerProfile.MAX_AMPLITUDE)\nprogram.draw(compiled = True)\n</code></pre> 2025-06-10T12:44:31.074758 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ </p> <p>The <code>CompilerProfile.MAX_DURATION</code> maps whatever is the duration of your QoolQit program to the device's maximum allowed sequence duration: <pre><code>program.compile_to(device, profile = CompilerProfile.MAX_DURATION)\nprogram.draw(compiled = True)\n</code></pre> 2025-06-10T12:44:31.419921 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ </p> <p>The <code>CompilerProfile.MIN_DISTANCE</code> maps whatever is the minimum distance in the register of your QoolQit program to the device's minimum allowed atom separation: <pre><code>try:\n    program.compile_to(device, profile = CompilerProfile.MIN_DISTANCE)\nexcept ValueError as error:\n    print(error)\n</code></pre> <pre><code>The pulse's amplitude goes over the maximum value allowed for the chosen channel.\n</code></pre> </p> <p>In this case, you can see the compilation failed because putting the atoms that close together for this program would require setting an amplitude that is larger than what the device allows.</p>"},{"location":"contents/registers/","title":"Creating qubit registers","text":"<p>A <code>Register</code> defines the qubit resources to be used by a quantum program.</p> <pre><code>from qoolqit import Register\n\nqubits = {\n    0: (0.0, 0.0),\n    1: (0.0, 1.0),\n    2: (1.0, 0.0),\n    3: (1.0, 1.0),\n}\n\nregister = Register(qubits)\n</code></pre> <pre><code>Register(n_qubits = 4)\n</code></pre> <p>It can be instantiated from a list of coordinates.</p> <pre><code>coords = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]\n\nregister = Register.from_coordinates(coords)\n\nregister.draw()\n</code></pre> 2025-06-10T12:44:31.585733 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>The distances between all qubits can be directly accessed.</p> <pre><code>register.distances()\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 1.4142135623730951, (0, 3): 1.4142135623730951, (2, 3): 1.0, (0, 2): 1.0, (1, 3): 1.0}\n</code></pre> <p>The minimum distance can be directly accessed.</p> <pre><code>register.min_distance()\n</code></pre> <pre><code>1.0\n</code></pre> <p>The interaction coefficients \\(1/r_{ij}^6\\) can be directly accessed.</p> <pre><code>register.interactions()\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 0.12499999999999994, (0, 3): 0.12499999999999994, (2, 3): 1.0, (0, 2): 1.0, (1, 3): 1.0}\n</code></pre>"},{"location":"contents/waveforms/","title":"Writing time-dependent functions","text":"<p>An essential part of writing programs in the Rydberg analog model is to write the time-dependent functions representing the amplitude and detuning terms in the drive Hamiltonian. For that, QoolQit implements a set of waveforms that can be used directly and/or composed together.</p>"},{"location":"contents/waveforms/#base-waveforms","title":"Base waveforms","text":"<p>A full list of the available waveforms can be found in the API reference.</p> <pre><code>from qoolqit import Constant, Ramp, Delay\n\n# An empty waveform\nwf1 = Delay(1.0)\n\n# A waveform with a constant value\nwf2 = Constant(1.0, 2.0)\n\n# A waveform that ramps linearly between two values\nwf3 = Ramp(1.0, -1.0, 1.0)\n</code></pre> <pre><code>0 \u2264 t \u2264 1: Delay(t)\n0 \u2264 t \u2264 1: Constant(t, 2)\n0 \u2264 t \u2264 1: Ramp(t, -1, 1)\n</code></pre> <p>As shown above, printing a waveform shows the duration interval over which it applies followed by the description of the waveform.</p> <p>The first argument is always the <code>duration</code> of the waveform, and the remaining arguments depend on the information required by each waveform. The resulting object is a callable that can be evaluated at any time \\(t\\).</p> <pre><code>wf1(t = 0.0)\nwf2(t = 0.5)\nwf3(t = 1.0)\n</code></pre> <pre><code>wf1(t = 0.0) = 0.0\nwf2(t = 0.5) = 2.0\nwf3(t = 1.0) = 1.0\n</code></pre> <p>Each waveform also supports evaluation at multiple time steps by calling it on an array of times. <pre><code>import numpy as np\n\nt_array = np.linspace(0.0, 2.0, 9)\n\nwf3(t_array)\n</code></pre> <pre><code>t =      [0.   0.25 0.5  0.75 1.   1.25 1.5  1.75 2.  ]\nwf(t) =  [-1.  -0.5  0.   0.5  1.   0.   0.   0.   0. ]\n</code></pre> </p> <p>In the waveform above, we defined it with a duration of \\(1.0\\), and then evaluated it over nine points from \\(t = 0.0\\) to \\(t=2.0\\). As you can see, all points after \\(t = 1.0\\) evaluated to \\(0.0\\). By default, any waveform evaluated at a time \\(t\\) that falls outside the specified <code>duration</code> gives \\(0.0\\).</p> <p>Waveforms can be quickly drawn with the <code>draw()</code> method.</p> <pre><code>wf3.draw()\n</code></pre> 2025-06-10T12:44:31.664073 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/waveforms/#composite-waveforms","title":"Composite waveforms","text":"<p>The most straightforward way to arbitrarily compose waveforms is to use the <code>&gt;&gt;</code> operator. This will create a <code>CompositeWaveform</code> representing the waveforms in the order provided.</p> <pre><code>wf_comp = wf1 &gt;&gt; wf2 &gt;&gt; wf3\n</code></pre> <pre><code>Composite waveform:\n| 0 \u2264 t &lt; 1: Delay(t)\n| 1 \u2264 t &lt; 2: Constant(t, 2)\n| 2 \u2264 t \u2264 3: Ramp(t, -1, 1)\n</code></pre> <p>The code above is equivalent to calling <code>CompositeWaveform(wf1, wf2, wf3)</code>. As shown, printing the composite waveform will automatically show the individual waveforms in the composition and the times at which they are active. These are automatically calculated from the individual waveforms. A <code>CompositeWaveform</code> is by itself a subclass of <code>Waveform</code>, and thus the previous logic on calling it at arbitrary time values also applies.</p> <p>A few convenient properties are directly available in a composite waveform:</p> <pre><code># Total duration\nwf_comp.duration\n\n# List of durations of the individual waveforms\nwf_comp.durations\n\n# List of times where each individual waveform starts / ends\nwf_comp.times\n</code></pre> <pre><code>Total duration : 3.0\nList of durations : [1.0, 1.0, 1.0]\nList of times : [0.0, 1.0, 2.0, 3.0]\n</code></pre> <p>A custom waveform can directly be a <code>CompositeWaveform</code>. That is the case with the <code>PiecewiseLinear</code> waveform, which takes a list of durations (of size \\(N\\)) and a list of values (of size \\(N+1\\)) and creates a linear interpolation between all values using individual waveforms of type <code>Ramp</code>.</p> <pre><code>from qoolqit import PiecewiseLinear\n\ndurations = [1.0, 1.0, 2.0]\nvalues = [0.0, 1.0, 0.5, 0.5]\n\nwf_pwl = PiecewiseLinear(durations, values)\n\nwf_pwl.draw()\n</code></pre> 2025-06-10T12:44:31.767675 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/waveforms/#defining-custom-waveforms","title":"Defining custom waveforms","text":"<p>The waveform system of QoolQit can be easily extended by subclassing the <code>Waveform</code> class and defining some key properties and methods. To exemplify this we will create a waveform representing a simple shifted sine function,</p> \\[     \\text{Sin}(t)_{\\omega, C} \\equiv \\sin(\\omega t) + C \\] <pre><code>from qoolqit.waveforms import Waveform\n\nimport math\n\nclass Sin(Waveform):\n    \"\"\"A simple sine over a given duration.\n\n    Arguments:\n        duration: the total duration.\n        omega: the frequency of the sine wave.\n        shift: the vertical shift of the sine wave.\n    \"\"\"\n\n    def __init__(\n        self,\n        duration: float,\n        omega: float = 2.0 * math.pi,\n        shift: float = 0.0,\n    ) -&gt; None:\n        super().__init__(duration, omega = omega, shift = shift)\n\n    def function(self, t: float) -&gt; float:\n        return math.sin(self.omega * t) + self.shift\n</code></pre> <p>A few things are crucial in the snippet above:</p> <ul> <li>Keeping the <code>duration</code> argument as the first one in the <code>__init__</code>, and initializing the parent class with that value, to be consistent with other waveforms.</li> <li>Passing every other parameter needed for the waveform in the <code>__init__</code> and passing it as a keyword argument to the parent class. This will automatically create a <code>params</code> dictionary of extra parameters, and set them as attributes to be used later.</li> <li>Overriding the <code>function</code> abstract method, which represents the evaluation of the waveform at some time <code>t</code>.</li> <li>Optional: overriding the <code>max</code> and <code>min</code> methods. The intended result of <code>wf.max()</code> and <code>wf.min()</code> is to get the maximum/minimum value the waveform takes over its duration. By default, the base <code>Waveform</code> class implements a brute-force sampling method that approximates the maximum and minimum values. However, if this value is easy to know from the waveform parameters, the method should be overriden.</li> </ul> <p>To showcase the usage of the newly defined waveform, let's define a new sine waveform and compose it with a piecewise linear waveform.</p> <pre><code>from qoolqit import PiecewiseLinear\nimport math\n\nwf1 = Sin(\n    duration = 1.0,\n    omega = 2.0 * math.pi,\n    shift = 1.0\n)\n\nwf2 = PiecewiseLinear(\n    durations = [0.5, 0.5],\n    values = [1.0, 1.0, 0.0],\n)\n\nwf_comp = wf1 &gt;&gt; wf2\n</code></pre> <pre><code>Composite waveform:\n| 0 \u2264 t &lt; 1: Sin(t, 6.283, 1)\n| 1 \u2264 t &lt; 1.5: Ramp(t, 1, 1)\n| 1.5 \u2264 t \u2264 2: Ramp(t, 1, 0)\n</code></pre> <pre><code>wf_comp.draw()\n</code></pre> 2025-06-10T12:44:31.872634 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Following this example, more complete <code>Sin</code> waveform is directly available in QoolQit implementing</p> \\[     \\text{Sin}(t)_{A, \\omega, \\phi, C} \\equiv A * \\sin(\\omega t + \\phi) + C \\] <pre><code>from qoolqit import Sin\n\nwf = Sin(\n    duration = 1.0,\n    amplitude = 2.0,\n    omega = 6.0,\n    phi = -5.0,\n    shift = 1.0,\n)\n\nwf.max()\n</code></pre> <pre><code>0 \u2264 t \u2264 1: Sin(t, 2, 6, -5, 1)\nMaximum value:  2.999999066583827\n</code></pre> <pre><code>wf.draw()\n</code></pre> 2025-06-10T12:44:31.948730 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"getting_started/installation/","title":"Installation","text":"<p>QoolQit can be installed from PyPi with <code>pip</code> as follows</p> <pre><code>$ pip install qoolqit\n\n# or\n\n$ pipx install qoolqit\n</code></pre>"},{"location":"getting_started/installation/#install-from-source","title":"Install from source","text":"<p>If you wish to install directly from the source, for example, if you are developing code for QoolQit, you can:</p> <p>1) Clone the QoolQit GitHub repository</p> <pre><code>git clone https://github.com/pasqal-io/qoolqit.git\n</code></pre> <p>2) Setup an environment for developing. We recommend using Hatch. With Hatch installed, you can enter the <code>qoolqit</code> repository and run</p> <pre><code>hatch shell\n</code></pre> <p>This will automatically take you into an environment with the necessary dependencies. Alternatively, if you wish to use a different environment manager like <code>conda</code> or <code>venv</code>, you can instead enter the <code>qoolqit</code> repository from within the environment and run</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"getting_started/installation/#using-any-pyproject-compatible-python-manager","title":"Using any pyproject-compatible Python manager","text":"<p>For usage within a project with a corresponding <code>pyproject.toml</code> file, you can add</p> <pre><code>  \"qoolqit\"\n</code></pre> <p>to the list of <code>dependencies</code>.</p>"},{"location":"getting_started/rydberg_model/","title":"The Rydberg Analog Model","text":"<p>In this page we will describe the computational model used by QoolQit.</p>"},{"location":"tutorials/placeholder/","title":"Coming soon!","text":"<p>Stay tuned for awesome tutorials coming with the development of QoolQit.</p>"},{"location":"api/qoolqit/","title":"Reference","text":"qoolqit<p> source package qoolqit </p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> <li> <p>Drive \u2014 The drive Hamiltonian acting over a duration.</p> </li> <li> <p>MockDevice \u2014 An ideal device without constraints.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>TestAnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>AvailableDevices</p> </li> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> <li> <p>Register \u2014 The Register in QoolQit, representing a set of qubits with coordinates.</p> </li> <li> <p>QuantumProgram \u2014 A program representing a Sequence acting on a Register of qubits.</p> </li> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> <li> <p>CompilerProfile</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>from_pyg \u2014 Create a graph from a pyg data object.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod DataGraph.from_pyg(data) \u2192 DataGraph </p> <p>Create a graph from a pyg data object.</p> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> source class Drive(*args: Any, amplitude: Waveform | None = None, detuning: Waveform | None = None, phase: float = 0.0) </p> <p>The drive Hamiltonian acting over a duration.</p> <p>Default constructor for the Drive.</p> <p>Must be instantiated with keyword arguments. Accepts either an amplitude waveform, a detuning waveform, or both. A phase value can also be passed.</p> <p> Parameters </p> <ul> <li> <p>amplitude :  Waveform | None \u2014 waveform representing \u03a9(t) in the drive Hamiltonian.</p> </li> <li> <p>detuning :  Waveform | None \u2014 waveform representing \u03b4(t) in the drive Hamiltonian.</p> </li> <li> <p>phase :  float \u2014 phase value \u0278 for the amplitude term.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>amplitude :  Waveform \u2014 The amplitude waveform in the drive.</p> </li> <li> <p>detuning :  Waveform \u2014 The detuning waveform in the drive.</p> </li> <li> <p>phase :  float \u2014 The phase value in the drive.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw</p> </li> </ul> <p> source property Drive.amplitude: Waveform </p> <p>The amplitude waveform in the drive.</p> <p> source property Drive.detuning: Waveform </p> <p>The detuning waveform in the drive.</p> <p> source property Drive.phase: float </p> <p>The phase value in the drive.</p> <p> source property Drive.duration: float </p> <p> source method Drive.draw(n_points: int = 500, return_fig: bool = False) \u2192 plt.Figure | None </p> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>An ideal device without constraints.</p> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source class TestAnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source enum AvailableDevices() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>MOCK</p> </li> <li> <p>ANALOG</p> </li> <li> <p>TEST_ANALOG</p> </li> </ul> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Delay(duration: float, *args: float, **kwargs: float) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p> <p> source class Register(qubits: dict) </p> <p>The Register in QoolQit, representing a set of qubits with coordinates.</p> <p>Default constructor for the Register.</p> <p> Parameters </p> <ul> <li> <p>qubits :  dict \u2014 a dictionary of qubits and respective coordinates {q: (x, y), ...}.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>qubits :  dict \u2014 Returns the dictionary of qubits and respective coordinates.</p> </li> <li> <p>n_qubits :  int \u2014 Number of qubits in the Register.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_graph \u2014 Initializes a Register from a graph that has coordinates.</p> </li> <li> <p>from_coordinates \u2014 Initializes a Register from a list of coordinates.</p> </li> <li> <p>distances \u2014 Distance between each qubit pair.</p> </li> <li> <p>min_distance \u2014 Minimum distance between all qubit pairs.</p> </li> <li> <p>interactions \u2014 Interaction 1/r^6 between each qubit pair.</p> </li> <li> <p>draw \u2014 Draw the register.</p> </li> </ul> <p> source classmethod Register.from_graph(graph: DataGraph) \u2192 Register </p> <p>Initializes a Register from a graph that has coordinates.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 a DataGraph instance.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod Register.from_coordinates(coords: list) \u2192 Register </p> <p>Initializes a Register from a list of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list \u2014 a list of coordinates [(x, y), ...]</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source property Register.qubits: dict </p> <p>Returns the dictionary of qubits and respective coordinates.</p> <p> source property Register.n_qubits: int </p> <p>Number of qubits in the Register.</p> <p> source method Register.distances() \u2192 dict </p> <p>Distance between each qubit pair.</p> <p> source method Register.min_distance() \u2192 float </p> <p>Minimum distance between all qubit pairs.</p> <p> source method Register.interactions() \u2192 dict </p> <p>Interaction 1/r^6 between each qubit pair.</p> <p> source method Register.draw(return_fig: bool = False) \u2192 plt.Figure | None </p> <p>Draw the register.</p> <p> Parameters </p> <ul> <li> <p>return_fig :  bool \u2014 boolean argument to return the plt.Figure instance.</p> </li> </ul> <p> source class QuantumProgram(register: Register, drive: Drive) </p> <p>A program representing a Sequence acting on a Register of qubits.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the Register of qubits.</p> </li> <li> <p>sequence \u2014 the Sequence of waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>register :  Register \u2014 The register of qubits.</p> </li> <li> <p>drive :  Drive \u2014 The driving waveforms.</p> </li> <li> <p>is_compiled :  bool \u2014 Check if the program has been compiled.</p> </li> <li> <p>compiled_sequence :  PulserSequence \u2014 The Pulser sequence compiled to a specific device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_to \u2014 Compiles the given program to a device.</p> </li> <li> <p>draw</p> </li> <li> <p>run \u2014 Temporary method to run a simulation on QuTip.</p> </li> </ul> <p> source property QuantumProgram.register: Register </p> <p>The register of qubits.</p> <p> source property QuantumProgram.drive: Drive </p> <p>The driving waveforms.</p> <p> source property QuantumProgram.is_compiled: bool </p> <p>Check if the program has been compiled.</p> <p> source property QuantumProgram.compiled_sequence: PulserSequence </p> <p>The Pulser sequence compiled to a specific device.</p> <p> source method QuantumProgram.compile_to(device: Device, profile: CompilerProfile = CompilerProfile.DEFAULT) \u2192 None </p> <p>Compiles the given program to a device.</p> <p> Parameters </p> <ul> <li> <p>device :  Device \u2014 the Device to compile to.</p> </li> <li> <p>profile :  CompilerProfile \u2014 the compiler profile to use during compilation.</p> </li> </ul> <p> source method QuantumProgram.draw(n_points: int = 500, compiled: bool = False, return_fig: bool = False) \u2192 plt.Figure | None </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source method QuantumProgram.run() \u2192 ArrayLike </p> <p>Temporary method to run a simulation on QuTip.</p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source enum CompilerProfile() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul>"},{"location":"api/qoolqit/devices/","title":"qoolqit.devices","text":"qoolqit.devices<p> source package qoolqit.devices </p> <p> Classes </p> <ul> <li> <p>MockDevice \u2014 An ideal device without constraints.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>TestAnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>AvailableDevices</p> </li> <li> <p>Device \u2014 Abstract base class for a Device in QoolQit.</p> </li> <li> <p>UnitConverter \u2014 A dataclass representing a unit converter in the Rydberg-Analog model.</p> </li> </ul> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>An ideal device without constraints.</p> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source class TestAnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source enum AvailableDevices() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>MOCK</p> </li> <li> <p>ANALOG</p> </li> <li> <p>TEST_ANALOG</p> </li> </ul> <p> source class Device() </p> <p>Bases : ABC</p> <p>Abstract base class for a Device in QoolQit.</p> <p>The device in QoolQit holds a Pulser device, and all the logic is based on that. Defining a new device for usage in QoolQit should be done by inheriting from this base class and overriding the <code>_device</code> private property with the corresponding Pulser device.</p> <p> Methods </p> <ul> <li> <p>reset_converter \u2014 Resets the unit converter to the default one.</p> </li> <li> <p>set_time_unit \u2014 Changes the unit converter according to a reference time unit.</p> </li> <li> <p>set_energy_unit \u2014 Changes the unit converter according to a reference energy unit.</p> </li> <li> <p>set_distance_unit \u2014 Changes the unit converter according to a reference distance unit.</p> </li> </ul> <p> source property Device.name: str </p> <p> source property Device.converter: UnitConverter </p> <p> source method Device.reset_converter() \u2192 None </p> <p>Resets the unit converter to the default one.</p> <p> source method Device.set_time_unit(time: float) \u2192 None </p> <p>Changes the unit converter according to a reference time unit.</p> <p> source method Device.set_energy_unit(energy: float) \u2192 None </p> <p>Changes the unit converter according to a reference energy unit.</p> <p> source method Device.set_distance_unit(distance: float) \u2192 None </p> <p>Changes the unit converter according to a reference distance unit.</p> <p> source dataclass UnitConverter(C6: float = field(repr=False), time: float, energy: float, distance: float) </p> <p>A dataclass representing a unit converter in the Rydberg-Analog model.</p> <p>Includes three inter-dependent factors for TIME, ENERGY and DISTANCE conversion, also depending on the interaction coeffiecient C6. The converter checks the following invariants, based on the units used by Pulser:</p> <p> Conversion invariants </p> <ol> <li>TIME * ENERGY = 1000 ( &lt;=&gt; TIME = 1000 / ENERGY )</li> <li>DISTANCE^6 * ENERGY = C6 ( &lt;=&gt; ENERGY = C6 / (DISTANCE ^ 6) )</li> </ol> <p> Attributes </p> <ul> <li> <p>C6 :  float \u2014 Time conversion factor.</p> </li> <li> <p>time :  float \u2014 Energy conversion factor.</p> </li> <li> <p>energy :  float \u2014 Distance conversion factor.</p> </li> <li> <p>factors :  tuple[float, ...] \u2014 Return the current conversion factors set.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_factors \u2014 Returns True if the conversion invariants are respected.</p> </li> <li> <p>from_time \u2014 Instantiate from a reference C6 value and a reference time unit.</p> </li> <li> <p>from_energy \u2014 Instantiate from a reference C6 value and a reference energy unit.</p> </li> <li> <p>from_distance \u2014 Instantiate from a reference C6 value and a reference distance unit.</p> </li> <li> <p>factors_from_time \u2014 Get factors from a different reference time than the one set.</p> </li> <li> <p>factors_from_energy \u2014 Get factors from a different reference energy than the one set.</p> </li> <li> <p>factors_from_distance \u2014 Get factors from a different reference distance than the one set.</p> </li> </ul> <p> source method UnitConverter.validate_factors(time: float, energy: float, distance: float) \u2192 bool </p> <p>Returns True if the conversion invariants are respected.</p> <p> source classmethod UnitConverter.from_time(C6: float, time: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference time unit.</p> <p> source classmethod UnitConverter.from_energy(C6: float, energy: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference energy unit.</p> <p> source classmethod UnitConverter.from_distance(C6: float, distance: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference distance unit.</p> <p> source property UnitConverter.factors: tuple[float, ...] </p> <p>Return the current conversion factors set.</p> <p> source method UnitConverter.factors_from_time(time: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference time than the one set.</p> <p> source method UnitConverter.factors_from_energy(energy: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference energy than the one set.</p> <p> source method UnitConverter.factors_from_distance(distance: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference distance than the one set.</p>"},{"location":"api/qoolqit/devices/device/","title":"qoolqit.devices.device","text":"qoolqit.devices.device<p> source module qoolqit.devices.device </p> <p> Classes </p> <ul> <li> <p>Device \u2014 Abstract base class for a Device in QoolQit.</p> </li> <li> <p>MockDevice \u2014 An ideal device without constraints.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>TestAnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> </ul> <p> source class Device() </p> <p>Bases : ABC</p> <p>Abstract base class for a Device in QoolQit.</p> <p>The device in QoolQit holds a Pulser device, and all the logic is based on that. Defining a new device for usage in QoolQit should be done by inheriting from this base class and overriding the <code>_device</code> private property with the corresponding Pulser device.</p> <p> Methods </p> <ul> <li> <p>reset_converter \u2014 Resets the unit converter to the default one.</p> </li> <li> <p>set_time_unit \u2014 Changes the unit converter according to a reference time unit.</p> </li> <li> <p>set_energy_unit \u2014 Changes the unit converter according to a reference energy unit.</p> </li> <li> <p>set_distance_unit \u2014 Changes the unit converter according to a reference distance unit.</p> </li> </ul> <p> source property Device.name: str </p> <p> source property Device.converter: UnitConverter </p> <p> source method Device.reset_converter() \u2192 None </p> <p>Resets the unit converter to the default one.</p> <p> source method Device.set_time_unit(time: float) \u2192 None </p> <p>Changes the unit converter according to a reference time unit.</p> <p> source method Device.set_energy_unit(energy: float) \u2192 None </p> <p>Changes the unit converter according to a reference energy unit.</p> <p> source method Device.set_distance_unit(distance: float) \u2192 None </p> <p>Changes the unit converter according to a reference distance unit.</p> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>An ideal device without constraints.</p> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source class TestAnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p>"},{"location":"api/qoolqit/devices/unit_converter/","title":"qoolqit.devices.unit_converter","text":"qoolqit.devices.unit_converter<p> source module qoolqit.devices.unit_converter </p> <p> Classes </p> <ul> <li> <p>UnitConverter \u2014 A dataclass representing a unit converter in the Rydberg-Analog model.</p> </li> </ul> <p> source dataclass UnitConverter(C6: float = field(repr=False), time: float, energy: float, distance: float) </p> <p>A dataclass representing a unit converter in the Rydberg-Analog model.</p> <p>Includes three inter-dependent factors for TIME, ENERGY and DISTANCE conversion, also depending on the interaction coeffiecient C6. The converter checks the following invariants, based on the units used by Pulser:</p> <p> Conversion invariants </p> <ol> <li>TIME * ENERGY = 1000 ( &lt;=&gt; TIME = 1000 / ENERGY )</li> <li>DISTANCE^6 * ENERGY = C6 ( &lt;=&gt; ENERGY = C6 / (DISTANCE ^ 6) )</li> </ol> <p> Attributes </p> <ul> <li> <p>C6 :  float \u2014 Time conversion factor.</p> </li> <li> <p>time :  float \u2014 Energy conversion factor.</p> </li> <li> <p>energy :  float \u2014 Distance conversion factor.</p> </li> <li> <p>factors :  tuple[float, ...] \u2014 Return the current conversion factors set.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_factors \u2014 Returns True if the conversion invariants are respected.</p> </li> <li> <p>from_time \u2014 Instantiate from a reference C6 value and a reference time unit.</p> </li> <li> <p>from_energy \u2014 Instantiate from a reference C6 value and a reference energy unit.</p> </li> <li> <p>from_distance \u2014 Instantiate from a reference C6 value and a reference distance unit.</p> </li> <li> <p>factors_from_time \u2014 Get factors from a different reference time than the one set.</p> </li> <li> <p>factors_from_energy \u2014 Get factors from a different reference energy than the one set.</p> </li> <li> <p>factors_from_distance \u2014 Get factors from a different reference distance than the one set.</p> </li> </ul> <p> source method UnitConverter.validate_factors(time: float, energy: float, distance: float) \u2192 bool </p> <p>Returns True if the conversion invariants are respected.</p> <p> source classmethod UnitConverter.from_time(C6: float, time: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference time unit.</p> <p> source classmethod UnitConverter.from_energy(C6: float, energy: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference energy unit.</p> <p> source classmethod UnitConverter.from_distance(C6: float, distance: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference distance unit.</p> <p> source property UnitConverter.factors: tuple[float, ...] </p> <p>Return the current conversion factors set.</p> <p> source method UnitConverter.factors_from_time(time: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference time than the one set.</p> <p> source method UnitConverter.factors_from_energy(energy: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference energy than the one set.</p> <p> source method UnitConverter.factors_from_distance(distance: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference distance than the one set.</p>"},{"location":"api/qoolqit/devices/utils/","title":"qoolqit.devices.utils","text":"qoolqit.devices.utils<p> source module qoolqit.devices.utils </p> <p> Classes </p> <ul> <li> <p>AvailableDevices</p> </li> </ul> <p> source enum AvailableDevices() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>MOCK</p> </li> <li> <p>ANALOG</p> </li> <li> <p>TEST_ANALOG</p> </li> </ul>"},{"location":"api/qoolqit/execution/","title":"qoolqit.execution","text":"qoolqit.execution<p> source package qoolqit.execution </p> <p> Classes </p> <ul> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> <li> <p>CompilerProfile</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source enum CompilerProfile() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul>"},{"location":"api/qoolqit/execution/compilation_functions/","title":"qoolqit.execution.compilation_functions","text":"qoolqit.execution.compilation_functions<p> source module qoolqit.execution.compilation_functions </p> <p> Functions </p> <ul> <li> <p>basic_compilation</p> </li> </ul> <p> source basic_compilation(register: Register, drive: Drive, device: Device, profile: CompilerProfile) \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul>"},{"location":"api/qoolqit/execution/sequence_compiler/","title":"qoolqit.execution.sequence_compiler","text":"qoolqit.execution.sequence_compiler<p> source module qoolqit.execution.sequence_compiler </p> <p> Classes </p> <ul> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/qoolqit/execution/utils/","title":"qoolqit.execution.utils","text":"qoolqit.execution.utils<p> source module qoolqit.execution.utils </p> <p> Classes </p> <ul> <li> <p>CompilerProfile</p> </li> </ul> <p> source enum CompilerProfile() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul>"},{"location":"api/qoolqit/graphs/","title":"qoolqit.graphs","text":"qoolqit.graphs<p> source package qoolqit.graphs </p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> <li> <p>BaseGraph \u2014 The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>all_node_pairs \u2014 Return all pairs of nodes (u, v) where u &lt; v.</p> </li> <li> <p>distances \u2014 Return a dictionary of edge distances.</p> </li> <li> <p>random_coords \u2014 Generate a random set of node coordinates on a square of side L.</p> </li> <li> <p>random_edge_list \u2014 Generates a random set of k edges linkings items from a set of nodes.</p> </li> <li> <p>scale_coords \u2014 Scale the coordinates by a given value.</p> </li> <li> <p>space_coords \u2014 Spaces the coordinates so the minimum distance is equal to a set spacing.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>from_pyg \u2014 Create a graph from a pyg data object.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod DataGraph.from_pyg(data) \u2192 DataGraph </p> <p>Create a graph from a pyg data object.</p> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> source class BaseGraph(edges: Iterable = []) </p> <p>Bases : nx.Graph</p> <p>The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> <p>Defines basic functionalities for graphs within the Rydberg Analog, such as instantiating from a set of node coordinates, directly accessing node distances, and checking if the graph is unit-disk.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_nodes \u2014 Construct a base graph from a set of nodes.</p> </li> <li> <p>from_coordinates \u2014 Construct a base graph from a set of coordinates.</p> </li> <li> <p>distances \u2014 Returns a dictionary of distances for a given set of edges.</p> </li> <li> <p>min_distance \u2014 Returns the minimum distance in the graph.</p> </li> <li> <p>max_distance \u2014 Returns the maximum distance in the graph.</p> </li> <li> <p>ud_radius_range \u2014 Return the range (R_min, R_max) where the graph is unit-disk.</p> </li> <li> <p>is_ud_graph \u2014 Check if the graph is unit-disk.</p> </li> <li> <p>ud_edges \u2014 Returns the set of edges given by the intersection of circles of a given radius.</p> </li> <li> <p>rescale_coords \u2014 Rescales the node coordinates by a factor.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> <li> <p>draw \u2014 Draw the graph.</p> </li> </ul> <p> source classmethod BaseGraph.from_nodes(nodes: Iterable) \u2192 BaseGraph </p> <p>Construct a base graph from a set of nodes.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of nodes.</p> </li> </ul> <p> source classmethod BaseGraph.from_coordinates(coords: list | dict) \u2192 BaseGraph </p> <p>Construct a base graph from a set of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list | dict \u2014 list or dictionary of coordinate pairs.</p> </li> </ul> <p> source property BaseGraph.sorted_edges: set </p> <p>Returns the set of edges (u, v) such that (u &lt; v).</p> <p> source property BaseGraph.all_node_pairs: set </p> <p>Return a list of all possible node pairs in the graph.</p> <p> source property BaseGraph.has_coords: bool </p> <p>Check if the graph has coordinates.</p> <p>Requires all nodes to have coordinates.</p> <p> source property BaseGraph.has_edges: bool </p> <p>Check if the graph has edges.</p> <p> source property BaseGraph.coords: dict </p> <p>Return the dictionary of node coordinates.</p> <p> source method BaseGraph.distances(edge_list: Iterable | None = None) \u2192 dict </p> <p>Returns a dictionary of distances for a given set of edges.</p> <p>Distances are calculated directly from the coordinates. Raises an error if there are no coordinates on the graph.</p> <p> Parameters </p> <ul> <li> <p>edge_list :  Iterable | None \u2014 set of edges.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.min_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the minimum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.max_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the maximum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.ud_radius_range() \u2192 tuple </p> <p>Return the range (R_min, R_max) where the graph is unit-disk.</p> <p>The graph is unit-disk if the maximum distance between all connected nodes is smaller than the minimum distance between disconnected nodes. This means that for any value R in that interval, the following condition is true:</p> <p>graph.ud_edges(radius = R) == graph.sorted edges</p> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.is_ud_graph() \u2192 bool </p> <p>Check if the graph is unit-disk.</p> <p> source method BaseGraph.ud_edges(radius: float) \u2192 set </p> <p>Returns the set of edges given by the intersection of circles of a given radius.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the value</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> </ul> <p> source method BaseGraph.rescale_coords(*args: Any, scaling: float | None = None, spacing: float | None = None) \u2192 None </p> <p>Rescales the node coordinates by a factor.</p> <p>Accepts either a scaling or a spacing factor.</p> <p> Parameters </p> <ul> <li> <p>scaling :  float | None \u2014 value to scale by.</p> </li> <li> <p>spacing :  float | None \u2014 value to set as the minimum distance in the graph.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>TypeError</p> </li> </ul> <p> source method BaseGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the radius to use in determining the set of unit-disk edges.</p> </li> </ul> <p> source method BaseGraph.draw(return_fig: bool = False, *args: Any, **kwargs: Any) \u2192 plt.Figure | None </p> <p>Draw the graph.</p> <p>Uses the draw_networkx function from NetworkX.</p> <p> Parameters </p> <ul> <li> <p>*args :  Any \u2014 arguments to pass to draw_networkx.</p> </li> <li> <p>**kwargs :  Any \u2014 keyword-arguments to pass to draw_networkx.</p> </li> </ul> <p> source all_node_pairs(nodes: Iterable) \u2192 set </p> <p>Return all pairs of nodes (u, v) where u &lt; v.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of node indices.</p> </li> </ul> <p> source distances(coords: dict, edge_list: Iterable) \u2192 dict </p> <p>Return a dictionary of edge distances.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>edge_list :  Iterable \u2014 edge list to compute the distances for.</p> </li> </ul> <p> source random_coords(n: int, L: float = 1.0) \u2192 list </p> <p>Generate a random set of node coordinates on a square of side L.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of coordinate pairs to generate.</p> </li> <li> <p>L :  float \u2014 side of the square.</p> </li> </ul> <p> source random_edge_list(nodes: Iterable, k: int) \u2192 list </p> <p>Generates a random set of k edges linkings items from a set of nodes.</p> <p> source scale_coords(coords: dict, scaling: float) \u2192 dict </p> <p>Scale the coordinates by a given value.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>scaling :  float \u2014 value to scale by.</p> </li> </ul> <p> source space_coords(coords: dict, spacing: float) \u2192 dict </p> <p>Spaces the coordinates so the minimum distance is equal to a set spacing.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>spacing :  float \u2014 value to set as minimum distance.</p> </li> </ul>"},{"location":"api/qoolqit/graphs/base_graph/","title":"qoolqit.graphs.base_graph","text":"qoolqit.graphs.base_graph<p> source module qoolqit.graphs.base_graph </p> <p> Classes </p> <ul> <li> <p>BaseGraph \u2014 The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> </li> </ul> <p> source class BaseGraph(edges: Iterable = []) </p> <p>Bases : nx.Graph</p> <p>The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> <p>Defines basic functionalities for graphs within the Rydberg Analog, such as instantiating from a set of node coordinates, directly accessing node distances, and checking if the graph is unit-disk.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_nodes \u2014 Construct a base graph from a set of nodes.</p> </li> <li> <p>from_coordinates \u2014 Construct a base graph from a set of coordinates.</p> </li> <li> <p>distances \u2014 Returns a dictionary of distances for a given set of edges.</p> </li> <li> <p>min_distance \u2014 Returns the minimum distance in the graph.</p> </li> <li> <p>max_distance \u2014 Returns the maximum distance in the graph.</p> </li> <li> <p>ud_radius_range \u2014 Return the range (R_min, R_max) where the graph is unit-disk.</p> </li> <li> <p>is_ud_graph \u2014 Check if the graph is unit-disk.</p> </li> <li> <p>ud_edges \u2014 Returns the set of edges given by the intersection of circles of a given radius.</p> </li> <li> <p>rescale_coords \u2014 Rescales the node coordinates by a factor.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> <li> <p>draw \u2014 Draw the graph.</p> </li> </ul> <p> source classmethod BaseGraph.from_nodes(nodes: Iterable) \u2192 BaseGraph </p> <p>Construct a base graph from a set of nodes.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of nodes.</p> </li> </ul> <p> source classmethod BaseGraph.from_coordinates(coords: list | dict) \u2192 BaseGraph </p> <p>Construct a base graph from a set of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list | dict \u2014 list or dictionary of coordinate pairs.</p> </li> </ul> <p> source property BaseGraph.sorted_edges: set </p> <p>Returns the set of edges (u, v) such that (u &lt; v).</p> <p> source property BaseGraph.all_node_pairs: set </p> <p>Return a list of all possible node pairs in the graph.</p> <p> source property BaseGraph.has_coords: bool </p> <p>Check if the graph has coordinates.</p> <p>Requires all nodes to have coordinates.</p> <p> source property BaseGraph.has_edges: bool </p> <p>Check if the graph has edges.</p> <p> source property BaseGraph.coords: dict </p> <p>Return the dictionary of node coordinates.</p> <p> source method BaseGraph.distances(edge_list: Iterable | None = None) \u2192 dict </p> <p>Returns a dictionary of distances for a given set of edges.</p> <p>Distances are calculated directly from the coordinates. Raises an error if there are no coordinates on the graph.</p> <p> Parameters </p> <ul> <li> <p>edge_list :  Iterable | None \u2014 set of edges.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.min_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the minimum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.max_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the maximum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.ud_radius_range() \u2192 tuple </p> <p>Return the range (R_min, R_max) where the graph is unit-disk.</p> <p>The graph is unit-disk if the maximum distance between all connected nodes is smaller than the minimum distance between disconnected nodes. This means that for any value R in that interval, the following condition is true:</p> <p>graph.ud_edges(radius = R) == graph.sorted edges</p> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.is_ud_graph() \u2192 bool </p> <p>Check if the graph is unit-disk.</p> <p> source method BaseGraph.ud_edges(radius: float) \u2192 set </p> <p>Returns the set of edges given by the intersection of circles of a given radius.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the value</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> </ul> <p> source method BaseGraph.rescale_coords(*args: Any, scaling: float | None = None, spacing: float | None = None) \u2192 None </p> <p>Rescales the node coordinates by a factor.</p> <p>Accepts either a scaling or a spacing factor.</p> <p> Parameters </p> <ul> <li> <p>scaling :  float | None \u2014 value to scale by.</p> </li> <li> <p>spacing :  float | None \u2014 value to set as the minimum distance in the graph.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>TypeError</p> </li> </ul> <p> source method BaseGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the radius to use in determining the set of unit-disk edges.</p> </li> </ul> <p> source method BaseGraph.draw(return_fig: bool = False, *args: Any, **kwargs: Any) \u2192 plt.Figure | None </p> <p>Draw the graph.</p> <p>Uses the draw_networkx function from NetworkX.</p> <p> Parameters </p> <ul> <li> <p>*args :  Any \u2014 arguments to pass to draw_networkx.</p> </li> <li> <p>**kwargs :  Any \u2014 keyword-arguments to pass to draw_networkx.</p> </li> </ul>"},{"location":"api/qoolqit/graphs/data_graph/","title":"qoolqit.graphs.data_graph","text":"qoolqit.graphs.data_graph<p> source module qoolqit.graphs.data_graph </p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>from_pyg \u2014 Create a graph from a pyg data object.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod DataGraph.from_pyg(data) \u2192 DataGraph </p> <p>Create a graph from a pyg data object.</p> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p>"},{"location":"api/qoolqit/graphs/utils/","title":"qoolqit.graphs.utils","text":"qoolqit.graphs.utils<p> source module qoolqit.graphs.utils </p> <p> Functions </p> <ul> <li> <p>all_node_pairs \u2014 Return all pairs of nodes (u, v) where u &lt; v.</p> </li> <li> <p>distances \u2014 Return a dictionary of edge distances.</p> </li> <li> <p>scale_coords \u2014 Scale the coordinates by a given value.</p> </li> <li> <p>space_coords \u2014 Spaces the coordinates so the minimum distance is equal to a set spacing.</p> </li> <li> <p>random_coords \u2014 Generate a random set of node coordinates on a square of side L.</p> </li> <li> <p>random_edge_list \u2014 Generates a random set of k edges linkings items from a set of nodes.</p> </li> <li> <p>less_or_equal \u2014 Less or approximately equal.</p> </li> </ul> <p> source all_node_pairs(nodes: Iterable) \u2192 set </p> <p>Return all pairs of nodes (u, v) where u &lt; v.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of node indices.</p> </li> </ul> <p> source distances(coords: dict, edge_list: Iterable) \u2192 dict </p> <p>Return a dictionary of edge distances.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>edge_list :  Iterable \u2014 edge list to compute the distances for.</p> </li> </ul> <p> source scale_coords(coords: dict, scaling: float) \u2192 dict </p> <p>Scale the coordinates by a given value.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>scaling :  float \u2014 value to scale by.</p> </li> </ul> <p> source space_coords(coords: dict, spacing: float) \u2192 dict </p> <p>Spaces the coordinates so the minimum distance is equal to a set spacing.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>spacing :  float \u2014 value to set as minimum distance.</p> </li> </ul> <p> source random_coords(n: int, L: float = 1.0) \u2192 list </p> <p>Generate a random set of node coordinates on a square of side L.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of coordinate pairs to generate.</p> </li> <li> <p>L :  float \u2014 side of the square.</p> </li> </ul> <p> source random_edge_list(nodes: Iterable, k: int) \u2192 list </p> <p>Generates a random set of k edges linkings items from a set of nodes.</p> <p> source less_or_equal(a: float, b: float, rel_tol: float = 0.0, abs_tol: float = ATOL_32) \u2192 bool </p> <p>Less or approximately equal.</p>"},{"location":"api/qoolqit/waveforms/","title":"qoolqit.waveforms","text":"qoolqit.waveforms<p> source package qoolqit.waveforms </p> <p> Classes </p> <ul> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> <li> <p>CompositeWaveform \u2014 Base class for composite waveforms.</p> </li> <li> <p>Waveform \u2014 Base class for waveforms.</p> </li> </ul> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Delay(duration: float, *args: float, **kwargs: float) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p> <p> source class CompositeWaveform(*waveforms: Waveform) </p> <p>Bases : Waveform</p> <p>Base class for composite waveforms.</p> <p>A CompositeWaveform stores a sequence of waveforms occuring one after the other by the order given. When it is evaluated at time t, the corresponding waveform from the sequence is identified depending on the duration of each one, and it is then evaluated for a time t' = t minus the duration of all previous waveforms.</p> <p>Initializes the CompositeWaveform.</p> <p> Parameters </p> <ul> <li> <p>waveforms :  Waveform \u2014 an iterator over waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Identifies the right waveform in the composition and evaluates it at time t.</p> </li> <li> <p>max \u2014 Get the maximum value of the waveform.</p> </li> </ul> <p> source property CompositeWaveform.durations: list[float] </p> <p>Returns the list of durations of each individual waveform.</p> <p> source property CompositeWaveform.times: list[float] </p> <p>Returns the list of times when each individual waveform starts.</p> <p> source property CompositeWaveform.waveforms: list[Waveform] </p> <p>Returns a list of the individual waveforms.</p> <p> source property CompositeWaveform.n_waveforms: int </p> <p>Returns the number of waveforms.</p> <p> source method CompositeWaveform.function(t: float) \u2192 float </p> <p>Identifies the right waveform in the composition and evaluates it at time t.</p> <p> source method CompositeWaveform.max() \u2192 float </p> <p>Get the maximum value of the waveform.</p> <p> source class Waveform(duration: float, *args: float, **kwargs: float) </p> <p>Bases : ABC</p> <p>Base class for waveforms.</p> <p>A Waveform is a function of time for t &gt;= 0. Custom waveforms can be defined by inheriting from the base class and overriding the <code>function</code> method corresponding to the function f(t) that returns the value of the waveform evaluated at time t.</p> <p>A waveform is always a 1D function, so if it includes other parameters, these should be passed and saved at initialization for usage within the <code>function</code> method.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Evaluates the waveform function at a given time t.</p> </li> <li> <p>max \u2014 Get the approximate maximum value of the waveform.</p> </li> <li> <p>min \u2014 Get the approximate minimum value of the waveform.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property Waveform.duration: float </p> <p>Returns the duration of the waveform.</p> <p> source property Waveform.params: dict[str, float] </p> <p>Dictonary of parameters used by the waveform.</p> <p> source method Waveform.function(t: float) \u2192 float </p> <p>Evaluates the waveform function at a given time t.</p> <p> source method Waveform.max() \u2192 float </p> <p>Get the approximate maximum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the maximum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.min() \u2192 float </p> <p>Get the approximate minimum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the minimum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.draw(n_points: int = N_POINTS, return_fig: bool = False, **kwargs: Any) \u2192 plt.Figure | None </p>"},{"location":"api/qoolqit/waveforms/base_waveforms/","title":"qoolqit.waveforms.base_waveforms","text":"qoolqit.waveforms.base_waveforms<p> source module qoolqit.waveforms.base_waveforms </p> <p> Classes </p> <ul> <li> <p>Waveform \u2014 Base class for waveforms.</p> </li> <li> <p>CompositeWaveform \u2014 Base class for composite waveforms.</p> </li> </ul> <p> source class Waveform(duration: float, *args: float, **kwargs: float) </p> <p>Bases : ABC</p> <p>Base class for waveforms.</p> <p>A Waveform is a function of time for t &gt;= 0. Custom waveforms can be defined by inheriting from the base class and overriding the <code>function</code> method corresponding to the function f(t) that returns the value of the waveform evaluated at time t.</p> <p>A waveform is always a 1D function, so if it includes other parameters, these should be passed and saved at initialization for usage within the <code>function</code> method.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Evaluates the waveform function at a given time t.</p> </li> <li> <p>max \u2014 Get the approximate maximum value of the waveform.</p> </li> <li> <p>min \u2014 Get the approximate minimum value of the waveform.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property Waveform.duration: float </p> <p>Returns the duration of the waveform.</p> <p> source property Waveform.params: dict[str, float] </p> <p>Dictonary of parameters used by the waveform.</p> <p> source method Waveform.function(t: float) \u2192 float </p> <p>Evaluates the waveform function at a given time t.</p> <p> source method Waveform.max() \u2192 float </p> <p>Get the approximate maximum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the maximum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.min() \u2192 float </p> <p>Get the approximate minimum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the minimum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.draw(n_points: int = N_POINTS, return_fig: bool = False, **kwargs: Any) \u2192 plt.Figure | None </p> <p> source class CompositeWaveform(*waveforms: Waveform) </p> <p>Bases : Waveform</p> <p>Base class for composite waveforms.</p> <p>A CompositeWaveform stores a sequence of waveforms occuring one after the other by the order given. When it is evaluated at time t, the corresponding waveform from the sequence is identified depending on the duration of each one, and it is then evaluated for a time t' = t minus the duration of all previous waveforms.</p> <p>Initializes the CompositeWaveform.</p> <p> Parameters </p> <ul> <li> <p>waveforms :  Waveform \u2014 an iterator over waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Identifies the right waveform in the composition and evaluates it at time t.</p> </li> <li> <p>max \u2014 Get the maximum value of the waveform.</p> </li> </ul> <p> source property CompositeWaveform.durations: list[float] </p> <p>Returns the list of durations of each individual waveform.</p> <p> source property CompositeWaveform.times: list[float] </p> <p>Returns the list of times when each individual waveform starts.</p> <p> source property CompositeWaveform.waveforms: list[Waveform] </p> <p>Returns a list of the individual waveforms.</p> <p> source property CompositeWaveform.n_waveforms: int </p> <p>Returns the number of waveforms.</p> <p> source method CompositeWaveform.function(t: float) \u2192 float </p> <p>Identifies the right waveform in the composition and evaluates it at time t.</p> <p> source method CompositeWaveform.max() \u2192 float </p> <p>Get the maximum value of the waveform.</p>"},{"location":"api/qoolqit/waveforms/waveforms/","title":"qoolqit.waveforms.waveforms","text":"qoolqit.waveforms.waveforms<p> source module qoolqit.waveforms.waveforms </p> <p> Classes </p> <ul> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> </ul> <p> source class Delay(duration: float, *args: float, **kwargs: float) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p>"},{"location":"api/qoolqit/drive/","title":"qoolqit.drive","text":"qoolqit.drive<p> source module qoolqit.drive </p> <p> Classes </p> <ul> <li> <p>Drive \u2014 The drive Hamiltonian acting over a duration.</p> </li> </ul> <p> source class Drive(*args: Any, amplitude: Waveform | None = None, detuning: Waveform | None = None, phase: float = 0.0) </p> <p>The drive Hamiltonian acting over a duration.</p> <p>Default constructor for the Drive.</p> <p>Must be instantiated with keyword arguments. Accepts either an amplitude waveform, a detuning waveform, or both. A phase value can also be passed.</p> <p> Parameters </p> <ul> <li> <p>amplitude :  Waveform | None \u2014 waveform representing \u03a9(t) in the drive Hamiltonian.</p> </li> <li> <p>detuning :  Waveform | None \u2014 waveform representing \u03b4(t) in the drive Hamiltonian.</p> </li> <li> <p>phase :  float \u2014 phase value \u0278 for the amplitude term.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>amplitude :  Waveform \u2014 The amplitude waveform in the drive.</p> </li> <li> <p>detuning :  Waveform \u2014 The detuning waveform in the drive.</p> </li> <li> <p>phase :  float \u2014 The phase value in the drive.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw</p> </li> </ul> <p> source property Drive.amplitude: Waveform </p> <p>The amplitude waveform in the drive.</p> <p> source property Drive.detuning: Waveform </p> <p>The detuning waveform in the drive.</p> <p> source property Drive.phase: float </p> <p>The phase value in the drive.</p> <p> source property Drive.duration: float </p> <p> source method Drive.draw(n_points: int = 500, return_fig: bool = False) \u2192 plt.Figure | None </p>"},{"location":"api/qoolqit/program/","title":"qoolqit.program","text":"qoolqit.program<p> source module qoolqit.program </p> <p> Classes </p> <ul> <li> <p>QuantumProgram \u2014 A program representing a Sequence acting on a Register of qubits.</p> </li> </ul> <p> source class QuantumProgram(register: Register, drive: Drive) </p> <p>A program representing a Sequence acting on a Register of qubits.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the Register of qubits.</p> </li> <li> <p>sequence \u2014 the Sequence of waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>register :  Register \u2014 The register of qubits.</p> </li> <li> <p>drive :  Drive \u2014 The driving waveforms.</p> </li> <li> <p>is_compiled :  bool \u2014 Check if the program has been compiled.</p> </li> <li> <p>compiled_sequence :  PulserSequence \u2014 The Pulser sequence compiled to a specific device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_to \u2014 Compiles the given program to a device.</p> </li> <li> <p>draw</p> </li> <li> <p>run \u2014 Temporary method to run a simulation on QuTip.</p> </li> </ul> <p> source property QuantumProgram.register: Register </p> <p>The register of qubits.</p> <p> source property QuantumProgram.drive: Drive </p> <p>The driving waveforms.</p> <p> source property QuantumProgram.is_compiled: bool </p> <p>Check if the program has been compiled.</p> <p> source property QuantumProgram.compiled_sequence: PulserSequence </p> <p>The Pulser sequence compiled to a specific device.</p> <p> source method QuantumProgram.compile_to(device: Device, profile: CompilerProfile = CompilerProfile.DEFAULT) \u2192 None </p> <p>Compiles the given program to a device.</p> <p> Parameters </p> <ul> <li> <p>device :  Device \u2014 the Device to compile to.</p> </li> <li> <p>profile :  CompilerProfile \u2014 the compiler profile to use during compilation.</p> </li> </ul> <p> source method QuantumProgram.draw(n_points: int = 500, compiled: bool = False, return_fig: bool = False) \u2192 plt.Figure | None </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source method QuantumProgram.run() \u2192 ArrayLike </p> <p>Temporary method to run a simulation on QuTip.</p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/qoolqit/register/","title":"qoolqit.register","text":"qoolqit.register<p> source module qoolqit.register </p> <p> Classes </p> <ul> <li> <p>Register \u2014 The Register in QoolQit, representing a set of qubits with coordinates.</p> </li> </ul> <p> source class Register(qubits: dict) </p> <p>The Register in QoolQit, representing a set of qubits with coordinates.</p> <p>Default constructor for the Register.</p> <p> Parameters </p> <ul> <li> <p>qubits :  dict \u2014 a dictionary of qubits and respective coordinates {q: (x, y), ...}.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>qubits :  dict \u2014 Returns the dictionary of qubits and respective coordinates.</p> </li> <li> <p>n_qubits :  int \u2014 Number of qubits in the Register.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_graph \u2014 Initializes a Register from a graph that has coordinates.</p> </li> <li> <p>from_coordinates \u2014 Initializes a Register from a list of coordinates.</p> </li> <li> <p>distances \u2014 Distance between each qubit pair.</p> </li> <li> <p>min_distance \u2014 Minimum distance between all qubit pairs.</p> </li> <li> <p>interactions \u2014 Interaction 1/r^6 between each qubit pair.</p> </li> <li> <p>draw \u2014 Draw the register.</p> </li> </ul> <p> source classmethod Register.from_graph(graph: DataGraph) \u2192 Register </p> <p>Initializes a Register from a graph that has coordinates.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 a DataGraph instance.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod Register.from_coordinates(coords: list) \u2192 Register </p> <p>Initializes a Register from a list of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list \u2014 a list of coordinates [(x, y), ...]</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source property Register.qubits: dict </p> <p>Returns the dictionary of qubits and respective coordinates.</p> <p> source property Register.n_qubits: int </p> <p>Number of qubits in the Register.</p> <p> source method Register.distances() \u2192 dict </p> <p>Distance between each qubit pair.</p> <p> source method Register.min_distance() \u2192 float </p> <p>Minimum distance between all qubit pairs.</p> <p> source method Register.interactions() \u2192 dict </p> <p>Interaction 1/r^6 between each qubit pair.</p> <p> source method Register.draw(return_fig: bool = False) \u2192 plt.Figure | None </p> <p>Draw the register.</p> <p> Parameters </p> <ul> <li> <p>return_fig :  bool \u2014 boolean argument to return the plt.Figure instance.</p> </li> </ul>"},{"location":"api/qoolqit/utils/","title":"qoolqit.utils","text":"qoolqit.utils<p> source module qoolqit.utils </p> <p> Classes </p> <ul> <li> <p>CustomEnumMeta</p> </li> <li> <p>StrEnum</p> </li> </ul> <p> Functions </p> <ul> <li> <p>EQUAL</p> </li> </ul> <p> source EQUAL(a: float, b: float, rtol: float = 0.0, atol: float = ATOL_64) \u2192 bool </p> <p> source class CustomEnumMeta() </p> <p>Bases : EnumMeta</p> <p> source enum StrEnum() </p> <p>Bases : str, Enum</p> <p> Methods </p> <ul> <li> <p>list</p> </li> </ul> <p> source classmethod StrEnum.list(values: bool = False) \u2192 list </p>"}]}