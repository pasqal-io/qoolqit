{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#installation","title":"Installation","text":"<p>QoolQit can be installed from PyPi with <code>pip</code> as follows</p> <pre><code>$ pip install qoolqit\n</code></pre> <p>Install from source</p> <p>If you wish to install directly from the source, for example, if you are developing code for QoolQit, you can:</p> <p>1) Clone the QoolQit GitHub repository</p> <pre><code>$ git clone https://github.com/pasqal-io/qoolqit.git\n</code></pre> <p>2) Setup an environment for developing. We recommend using Hatch. From your <code>qoolqit</code> folder run</p> <pre><code>$ hatch shell\n</code></pre> <p>If you wish to use a different environment manager like <code>conda</code> or <code>venv</code>, activate your environment and run</p> <pre><code>$ pip install -e .\n</code></pre> <p>Using any pyproject-compatible Python manager</p> <p>For usage within a project with a corresponding <code>pyproject.toml</code> file, you can add</p> <pre><code>  \"qoolqit\"\n</code></pre> <p>to the list of <code>dependencies</code>.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/","title":"Contributor Agreement","text":"<p>PASQAL CONTRIBUTION AGREEMENT (the \u201cAgreement\u201d)</p> <p>The author of the License is:</p> <p>Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <p>In the course of its activities, Pasqal carries out and leads quantic projects, in their software components. These projects aim to bring together a community of like-minded individuals to contribute to the development and improvement of Pasqal\u2019s products. Pasqal clearly outlines which projects are open to contributions (\u201cProjects\u201d).</p> <p>This Agreement documents the rights granted by Contributors to Pasqal and is legally binding.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-1-definitions","title":"Article 1 - Definitions","text":"<p>You, Your or Contributor : means the intellectual property rights owner or legal entity authorized by the intellectual property rights owner that is entering into this Agreement with\u00a0Pasqal</p> <p>Contribution : means any work, protected or not, that is submitted by You to Pasqal in which You own or assert ownership of the intellectual property rights, subject to proprietary licensing terms, and not otherwise distributer through an open-source license.</p> <p>Material : means the work object of the Project, made available by Pasqal to third parties. When this Agreement covers more than one Project, the Material means the work to which the Contribution was Submitted. After You Submit the Contribution, it may be included in any type of Material.</p> <p>Submit : means any form of electronic, verbal, or written communication sent to Pasqal or its representatives, including but not limited to electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, Pasqal for the purpose of discussing and improving the Material.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-2-entering-into-this-agreement","title":"Article 2 - Entering into this Agreement","text":"<p>By Submitting any Contribution to Pasqal, You agree to enter into the Agreement with this entity, and be bound by the following terms.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-3-limitations-as-to-the-licensing-of-contributions","title":"Article 3 - Limitations as to the licensing of Contributions","text":"<p>You guarantee that any Contribution You Submit to any Project is not licensed under any type of contaminating (even weakly contaminating) license, and that Pasqal will be free to combine your Contribution into any type of Material, for any Project, without any risk of contamination of said Material and/or Project.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-4-granting-of-a-copyright-andor-authors-rights-license","title":"Article 4 - Granting of a Copyright and/or author\u2019s rights License","text":"<p>Subject to the terms and conditions of this Agreement, You hereby grant to Pasqal and to recipients of any Project distributed by Pasqal a worldwide, sublicensable, non-exclusive, royalty-free license to reproduce, prepare derivative works of, publicly display, publicly perform, and distribute Your Contributions and your Contribution in combination with the Material for the entire duration of the rights under Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-5-granting-of-a-patent-license","title":"Article 5 - Granting of a patent license","text":"<p>Subject to the terms and conditions of this Agreement, You grant Pasqal a, worldwide, non-exclusive, transferable, royalty free patent license, with the right to sublicense these rights to third parties, to make, have made, use, sell, offer for sale, import and otherwise  transfer the Contribution and the Contribution in combination with the Material for the entire duration of the rights under Applicable law, if the Contribution implies the implementation of any such patent.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-6-licensing-of-the-material-and-contribution","title":"Article 6 - Licensing of the Material and Contribution","text":"<p>Based on the rights granted in articles 2 and 3, if Pasqal includes Your Contribution in a Material, Pasqal may license Material including Your Contribution under any license, whether permissive, weakly contaminating, or contaminating. Pasqal will respect Your moral rights in relation to Your Contribution as provided under the Applicable law.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-7-warranties-and-disclaimer","title":"Article 7 - Warranties and disclaimer","text":"<p>You represent that each of Your Contributions is Your creation, or that you have obtained the authorization from the intellectual property rights owner on the Contribution to Submit it over the course of a Project.</p> <p>By making a Contribution, You confirm that, to the best of Your knowledge, the Contribution does not violate the rights of any person or entity. If You make a Contribution on behalf of Your employer, then You confirm that an appropriate representative of that employer has authorized the inclusion of such Contribution to a Project and that it meets these requirements.</p> <p>You acknowledge that Pasqal is not obligated to use Your Contribution as part of the Material and may decide to only include Contributions Pasqal considers appropriate.</p>"},{"location":"CONTRIBUTOR%20AGREEMENT/#article-8-applicable-law-and-jurisdiction","title":"Article 8 - Applicable law and jurisdiction","text":"<p>The Agreement is governed by the laws of France. Any dispute relating to the interpretation or application of the License shall be subject to best efforts for an amicable settlement. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p>"},{"location":"LICENSE/","title":"License (MIT-Derived)","text":"<p>PASQAL OPEN-SOURCE SOFTWARE LICENSE AGREEMENT (MIT-DERIVED)</p> <p>The author of the License is:</p> <p>Pasqal, a Soci\u00e9t\u00e9 par Actions Simplifi\u00e9e (Simplified Joint Stock Company) registered under number 849 441 522 at the Registre du commerce et des soci\u00e9t\u00e9s (Trade and Companies Register) of Evry \u2013 France, headquartered at 24 rue \u00c9mile Baudot \u2013 91120 \u2013 Palaiseau \u2013 France, duly represented by its Pr\u00e9sident, M. Georges-Olivier REYMOND, Hereafter referred to as \u00ab the Licensor \u00bb</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the \u201cLicensee\u201d) and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. The Software is \u201cas is\u201d, without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and non-infringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise arising from, out of or in connection with the Software or the use or other dealings in the Software.</p> <p>If use of the Software leads to the necessary use of any patent of the Licensor and/or any of its Affiliates (defined as a company owned or controlled by the Licensor), the Licensee is granted a royalty-free license, in any country where such patent is in force, to use the object of such patent; or use the process covered by such patent,</p> <p>Such a patent license is granted for internal research or academic use of the Licensee's, which includes use by employees and students of the Licensee, acting on behalf of the Licensee, for research purposes only.</p> <p>The License is governed by the laws of France. Any dispute relating to the License, notably its execution, performance and/or termination shall be brought to, heard and tried by the Tribunal Judiciaire de Paris, regardless of the rules of jurisdiction in the matter.</p>"},{"location":"contents/available_embedders/","title":"The embedding problem","text":"<p>Embedding data and problems into the Rydberg analog model is a broad research topic. Typically, an embedding is a structure preserving map \\(f_\\text{embedding}: X \\rightarrow Y\\), such that an object \\(X\\) is embedded into an object \\(Y\\). Our goal is to define optimal embedding functions such that problem-specific data and definitions are embedded into model-compatible objects with the Rydberg analog model.</p> <p>In QoolQit, all concrete embedders follow a basic interface set by the <code>BaseEmbedder</code> abstract base class:</p> <pre><code>from qoolqit import ConcreteEmbedder\n\n# Initialize the embedder\nembedder = ConcreteEmbedder()\n\n# Access information about the embedding algorithm\nembedder.info\n\n# Access the configuration of the embedding algorithm\nembedder.config\n\n# Change some value of the embedding configuration\nembedder.config.param = new_value\n\n# Define some initial data object\ndata = some_data_generator()\n\n# Embed the data with the embedder\nembedded_data = embedder.embed(data)\n</code></pre> <p>In this case, <code>ConcreteEmbedder</code> exemplifies an embedder that already has a mapping function and the respective configuration dataclass for that mapping function. Below, we will exemplify how to use some of the pre-defined concrete embedders directly available in QoolQit, and then show some considerations when defining custom embedders.</p>"},{"location":"contents/available_embedders/#unit-disk-graph-embedding","title":"Unit-disk graph embedding","text":"<p>Unit-disk graph embedding is the problem of finding a suitable function \\(f_\\text{UD}: V\\rightarrow\\mathbb{R}^2\\) that assigns coordinates to each node in the graph, such that the resulting unit-disk graph exactly matches the original graph (see the graphs page for the definition of a unit-disk graph). In general, not all graphs can be embedded into unit-disk graphs, and deciding if a graph can be embedded into a unit-disk graph is a NP-Hard problem.</p> <p>However, several heuristic algorithms can be developed to tackle the unit-disk graph embedding problem.</p>"},{"location":"contents/available_embedders/#spring-layout-embedding","title":"Spring-layout embedding","text":"<p>The spring-layout embedding utilizes the Fruchterman-Reingold force-directed algorithm. It assigns spring-like forces to the edges that keep nodes closer, while treating nodes themselves as repelling objects. The system is then simulated until the nodes find an equilibrium position, which represent the final coordinates assigned to the nodes.</p> <p>In QoolQit, the <code>SpringLayoutEmbedder</code> directly wraps the <code>nx.spring_layout</code> function, and it maps a <code>DataGraph</code> without coordinates to another <code>DataGraph</code> with coordinates.</p> <pre><code>from qoolqit import SpringLayoutEmbedder\n\nembedder = SpringLayoutEmbedder()\n</code></pre> <pre><code>SpringLayoutEmbedder:\n| Algorithm: spring_layout_embedding\n| Config: SpringLayoutConfig(k=None, iterations=50, threshold=0.0001, seed=None)\n</code></pre> <p>As you can see above it holds an algorithm and a config with a set of default parameters. For information on the algorithm and parameters, you can use the <code>embedder.info</code> property.</p> <pre><code>print(embedder.info)\n</code></pre> <pre><code>-- Embedding agorithm docstring:\n\nForce-directed embedding, wrapping nx.spring_layout.\n\nGenerates a graph with the same nodes and edges as the original graph, but with\nnode coordinates set to be the positions given by nx.spring_layout.\n\nCheck the documentation for nx.spring_layout for more information on each parameter.\n\nArguments:\n    graph: the graph to embed.\n    k: optimal distance between nodes.\n    iterations: maximum number of iterations to take.\n    threshold: threshold value for relative error in node position changes.\n    sed: random seed.\n</code></pre> <p>In this case, this embedder is a direct wrapper on top of <code>nx.spring_layout</code>, and any parameters are the ones directly used by that function. For more information, you can check the documentation for NetworkX. The parameters can be directly changed in the config.</p> <pre><code>embedder.config.iterations = 100\nembedder.config.seed = 1\n\nprint(embedder)\n</code></pre> <pre><code>SpringLayoutEmbedder:\n| Algorithm: spring_layout_embedding\n| Config: SpringLayoutConfig(k=None, iterations=100, threshold=0.0001, seed=1)\n</code></pre> <p>Finally, we can run the embedder with the <code>embed</code> method.</p> <pre><code>from qoolqit import DataGraph\n\ngraph_1 = DataGraph.random_er(n = 7, p = 0.3, seed = 3)\n\nembedded_graph_1 = embedder.embed(graph_1)\n\ngraph_1.draw()\nembedded_graph_1.draw()\n</code></pre> 2025-07-29T14:50:40.547064 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-07-29T14:50:40.574339 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Now, we can check if the resulting graph is a unit-disk graph</p> <pre><code>embedded_graph_1.is_ud_graph()\n</code></pre> <pre><code>True\n</code></pre> <p>In this case the embedding was successful and we obtained a unit-disk graph. For more densely connected graphs, the spring layout algorithm tends to struggle with finding a unit-disk graph embedding, if it even exists.</p> <pre><code>graph_2 = DataGraph.random_er(n = 7, p = 0.8, seed = 3)\n\nembedded_graph_2 = embedder.embed(graph_2)\n\ngraph_2.draw()\nembedded_graph_2.draw()\n</code></pre> 2025-07-29T14:50:40.691271 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-07-29T14:50:40.720539 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p><pre><code>embedded_graph_2.is_ud_graph()\n</code></pre> <pre><code>False\n</code></pre>  While the algorithm converged and assigned positions to each node, the resulting embedded graph fails the unit-disk graph test.</p> <p>However, in both cases, we have embedded the original data into a graph with coordinates, which is an object that is compatible with the Rydberg analog model. As such, we can directly intantiate a register of qubits from these graphs.</p> <pre><code>from qoolqit import Register\n\nregister_1 = Register.from_graph(embedded_graph_1)\nregister_2 = Register.from_graph(embedded_graph_2)\n\nregister_1.draw()\nregister_2.draw()\n</code></pre> 2025-07-29T14:50:40.816110 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-07-29T14:50:40.868517 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/available_embedders/#matrix-embedding","title":"Matrix embedding","text":"<p>Matrix embedding is the problem of encoding a matrix into the Rydberg analog model. Several approaches can be taken, using different algorithms.</p>"},{"location":"contents/available_embedders/#interaction-embedding","title":"Interaction embedding","text":"<p>Interaction embedding means to encode a matrix in the interaction term of the Rydberg analog model. For a matrix \\(U\\), the goal is to find the set of coordinates that minimize</p> \\[ \\min_{\\{(x,\\, y)\\}}~\\sum_{ij}\\left\\|U_{ij}-\\frac{1}{r^6_{ij}}\\right\\|, \\] <p>where \\(r_{ij} = \\sqrt{(x_i-x_j)^2 + (y_i-y_j)^2}\\) is the distance between qubits \\(i\\) and \\(j\\). This requires the matrix \\(U\\) to be positive and symmetric, and only the off-diagonal terms are embedded.</p> <p>In QoolQit, the <code>InteractionEmbedder</code> performs this minimization using <code>scipy.minimize</code>, and it maps a <code>np.ndarray</code> to a <code>DataGraph</code> with coordinates.</p> <pre><code>from qoolqit import InteractionEmbedder\n\nembedder = InteractionEmbedder()\n</code></pre> <pre><code>InteractionEmbedder:\n| Algorithm: interaction_embedding\n| Config: InteractionEmbeddingConfig(method='Nelder-Mead', maxiter=200000, tol=1e-08)\n</code></pre> <p>Checking the <code>info</code> on the embedder, we see a few parameters are available for customization through the <code>config</code>. There are parameters that get passed to <code>scipy.minimize</code>, and their description can be found in the SciPy documentation.</p> <pre><code>print(embedder.info)\n</code></pre> <pre><code>-- Embedding agorithm docstring:\n\nMatrix embedding into the interaction term of the Rydberg Analog Model.\n\nUses scipy.minimize to find the optimal set of node coordinates such that the\nmatrix of values 1/(r_ij)^6 approximate the off-diagonal terms of the input matrix.\n\nCheck scipy.minimize documentation for more information on each parameter.\n\nArguments:\n    matrix: the matrix to embed.\n    method: the method used by scipy.minimize.\n    maxiter: maximum number of iterations.\n    tol: tolerance for termination.\n</code></pre> <p>We can try it out with the default configuration by generating a random symmetric positive matrix.</p> <pre><code>import numpy as np\n\nmatrix = np.random.rand(6, 6)\n\nmatrix = matrix + matrix.T\n</code></pre> <pre><code>[[0.54167148 0.15279868 1.64286505 1.55535244 1.32085794 1.82121381]\n [0.15279868 0.60854795 1.12626962 1.42969097 0.30766048 1.18868351]\n [1.64286505 1.12626962 0.89044947 1.5905557  1.03731673 1.78639811]\n [1.55535244 1.42969097 1.5905557  1.29270149 1.56436762 0.63291855]\n [1.32085794 0.30766048 1.03731673 1.56436762 0.13542587 1.41499468]\n [1.82121381 1.18868351 1.78639811 0.63291855 1.41499468 0.46768294]]\n</code></pre> <p>Finally, running the embedding we obtain a <code>DataGraph</code> with coordinates that can be easily converted to a <code>Register</code> of qubits.</p> <pre><code>import numpy as np\n\nembedded_graph = embedder.embed(matrix)\n\nregister = Register.from_graph(embedded_graph)\n\nembedded_graph.draw()\nregister.draw()\n</code></pre> 2025-07-29T14:50:41.225598 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ 2025-07-29T14:50:41.275500 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>To check how the embedding performed, we can inspect the interaction values in the <code>Register</code> and compare them to the off-diagonal elements in the matrix.</p> <pre><code>interactions = list(register.interactions().values())\n\ntriang_upper = np.triu(matrix, k = 1)\noff_diagonal = triang_upper[triang_upper != 0].tolist()\n\nprint([f\"{f:.4f}\" for f in sorted(interactions)])\nprint([f\"{f:.4f}\" for f in sorted(off_diagonal)])\n</code></pre> <pre><code>['0.0205', '0.0211', '0.0227', '0.0487', '0.0543', '0.0635', '1.1411', '1.1925', '1.3469', '1.4296', '1.5740', '1.6071', '1.6469', '1.8021', '1.8196']\n['0.1528', '0.3077', '0.6329', '1.0373', '1.1263', '1.1887', '1.3209', '1.4150', '1.4297', '1.5554', '1.5644', '1.5906', '1.6429', '1.7864', '1.8212']\n</code></pre>"},{"location":"contents/custom_embedders/","title":"Defining custom embedders","text":"<p>In the available embedders page you saw the usage of some pre-defined embedders. The embedding module in QoolQit is designed to be flexible and extendable to various forms of embedding algorithms developed for the Rydberg analog model, with potentially different inputs and outputs, and different configuration parameters. It is structured in three levels:</p> <p>Level 0: Concretizing the interface</p> <p>The <code>BaseEmbedder</code> is the abstract base class for all embedders, but it is defined on generic input and output data types. It enforces the interface for all embedders by defining the <code>info</code> and <code>config</code> properties, as well as the <code>embed</code> method. It also defines abstract <code>validate_input</code> and <code>validate_output</code> methods that must be overwritten by subclasses.</p> <p>Level 1: Concretizing the data inputs and data outputs</p> <p>The next level is to define the concrete data types involved in the mapping, thus defining a family of embedders. Currently, there are two families of embedders defined in QoolQit:</p> <ul> <li><code>GraphToGraphEmbedder</code> which concretizes the <code>BaseEmbedder</code> with a <code>DataGraph</code> input type and a <code>DataGraph</code> output type.</li> <li><code>MatrixToGraphEmbedder</code> which concretizes the <code>BaseEmbedder</code> with a <code>np.ndarray</code> input type and a <code>DataGraph</code> output type.</li> </ul> <p>In both cases, the <code>validate_input</code> and <code>validate_output</code> are overriden to check the input and output are of the correct type. In the case of the <code>MatrixToGraphEmbedder</code> conditions on the input matrix are also checked such as if the array has the right dimensions and is symmetric. Still, at this level, no specific embedding algorithm is defined.</p> <p>In the future, more families of embedders can be defined that may require different input and output data types.</p> <p>Level 2: Concretizing the algorithms and configurations</p> <p>The final level is defining concrete embedders, such as the ones we have used in the available embedders page. Here the requirement is to define a concrete function that maps the input to the output, along with any parameters required, and a config dataclass inheriting from <code>EmbeddingConfig</code> holding all the configuration parameters. In the previous examples, we used the <code>SpingLayoutEmbedder</code> which is a subclass of a <code>GraphToGraphEmbedder</code> and the <code>InteractionEmbedder</code> which is a subclass of the <code>MatrixToGraphEmbedder</code>.</p> <p>Let's exemplify the case of defining a custom embedder in the family of graph to graph embedders.</p> <pre><code>from qoolqit.embedding import GraphToGraphEmbedder\nfrom qoolqit.embedding import EmbeddingConfig\nfrom qoolqit import DataGraph\nfrom dataclasses import dataclass\n\ndef my_embedding_function(graph: DataGraph, param1: float) -&gt; DataGraph:\n    \"\"\"Some embedding function that manipulates the input graph.\n\n    This docstring should be clear on the embedding logic, because it will be\n    directly accessed by the embedder.info property.\n\n    Arguments:\n        param1: a useless parameter...\n    \"\"\"\n    return graph\n\n@dataclass\nclass MyEmbeddingConfig(EmbeddingConfig):\n    param1: float = 1.0\n\nembedder = GraphToGraphEmbedder(my_embedding_function, MyEmbeddingConfig())\n</code></pre> <pre><code>GraphToGraphEmbedder:\n| Algorithm: my_embedding_function\n| Config: MyEmbeddingConfig(param1=1.0)\n</code></pre> <p>It can now be used like any other embedder.</p> <pre><code>print(embedder.info)\n\nembedder.config.param1 = 2.0\n\ngraph = DataGraph.random_er(5, 0.5)\n\nembedded_graph = embedder.embed(graph)\n</code></pre> <pre><code>-- Embedding agorithm docstring:\n\nSome embedding function that manipulates the input graph.\n\nThis docstring should be clear on the embedding logic, because it will be\ndirectly accessed by the embedder.info property.\n\nArguments:\n    param1: a useless parameter...\n</code></pre> <p>To share this embedder or potentially add it to the QoolQit codebase, we might want to create a concrete embedder wrapper that users can easily import.</p> <pre><code>class MyNewEmbedder(GraphToGraphEmbedder):\n    def __init__(self):\n        super().__init__(my_embedding_function, MyEmbeddingConfig())\n</code></pre>"},{"location":"contents/custom_embedders/#automatic-validation","title":"Automatic validation","text":"<p>To define a custom embedder, the extra arguments in the embedding function (besides the data) must match the fields in the configuration dataclass, otherwise an error will be raised.</p> <pre><code>def my_embedding_function(graph: DataGraph, param1: float) -&gt; DataGraph:\n    return graph\n\n@dataclass\nclass MyWrongConfig(EmbeddingConfig):\n    some_other_param: float = 1.0\n\ntry:\n    wrong_embedder = GraphToGraphEmbedder(my_embedding_function, MyWrongConfig())\nexcept KeyError as error:\n    print(error)\n</code></pre> <pre><code>'Config MyWrongConfig is not compatible with the algorithm my_embedding_function, as not all configuration fields correspond to keyword arguments in the algorithm function.'\n</code></pre> <p>Furthermore, because we are defining an embedder in the <code>GraphToGraphEmbedder</code> the input must be an instance of a <code>DataGraph</code>:</p> <pre><code>embedder = GraphToGraphEmbedder(my_embedding_function, MyEmbeddingConfig())\n\ntry:\n    data = 1.0 # Not a DataGraph\n    embedded_data = embedder.embed(data)\nexcept TypeError as error:\n    print(error)\n</code></pre> <pre><code>Embedding data of type &lt;class 'float'&gt; not supported by this embedder. GraphToGraphEmbedder requires data of type DataGraph.\n</code></pre> <p>The output of the embedding function must also be a <code>DataGraph</code>:</p> <pre><code>def my_wrong_embedding_function(graph: DataGraph, param1: float) -&gt; DataGraph:\n    return param1 # Not a DataGraph\n\nembedder = GraphToGraphEmbedder(my_wrong_embedding_function, MyEmbeddingConfig())\n\ntry:\n    graph = DataGraph.random_er(5, 0.5)\n    embedded_graph = embedder.embed(graph)\nexcept TypeError as error:\n    print(error)\n</code></pre> <pre><code>Expected embedding result to be of type DataGraph, algorithm returned &lt;class 'float'&gt; instead.\n</code></pre>"},{"location":"contents/devices/","title":"Initializing quantum devices","text":"<p>Each <code>Device</code> in QoolQit wraps a Pulser device and defines the hardware characteristics that the program will be compiled to and later executed on.</p> <pre><code>from qoolqit import MockDevice, AnalogDevice\n\n# An example of an ideal device\ndevice_ideal = MockDevice()\n\n# An example of a real device\ndevice_real = AnalogDevice()\n</code></pre> <p>Each device has a default unit converter. These are the unit values that will be used when converting an adimensional program in the Rydberg analog model to the physical units of Pulser devices for hardware execution.</p> <pre><code>device_real.converter\n</code></pre> <pre><code>UnitConverter(time = 79.577, energy = 12.566, distance = 6.403)\n</code></pre> <p>The converter handles the logic of converting the adimensional QoolQit model to Pulser units. For theoretical details on how this conversion works between the Rydberg analog model and the implementation that Pulser uses you can check the Rydberg analog model page</p> <p>By default, each device creates a default converter where the energy unit is set as that device's maximum amplitude. If you make no changes to the device's converter, this means that amplitude values in the range \\([0, 1]\\) will be converted to values in the range \\([0, \\Omega_\\text{max}]\\).</p> <p>For advanced users, customizing the unit conversion factors is possible.</p> <pre><code>device_real.set_time_unit(50.0)\n\ndevice_real.set_energy_unit(10.0)\n\ndevice_real.set_distance_unit(6.0)\n</code></pre> <pre><code>UnitConverter(time = 50.000, energy = 20.000, distance = 5.925)\nUnitConverter(time = 100.000, energy = 10.000, distance = 6.651)\nUnitConverter(time = 53.893, energy = 18.555, distance = 6.000)\n</code></pre> <p>Restoring the default unit converter is also possible.</p> <pre><code>device_real.reset_converter()\n</code></pre> <pre><code>UnitConverter(time = 79.577, energy = 12.566, distance = 6.403)\n</code></pre>"},{"location":"contents/drives/","title":"Writing the drive Hamiltonian","text":"<p>The <code>Drive</code> is a composition of waveforms defining the drive Hamiltonian.</p> <pre><code>from qoolqit import Constant, Ramp\nfrom qoolqit import Drive\n\n# Defining two waveforms\nwf0 = Constant(0.5, 1.0) &gt;&gt; Ramp(1.0, 0.0, 0.5)\nwf1 = Ramp(2.0, -1.0, 1.0) &gt;&gt; Constant(1.0, 1.0)\n\n# Defining the drive\ndrive = Drive(\n    amplitude = wf0,\n    detuning = wf1\n)\n\n# Expanding the drive through composition\ndrive = drive &gt;&gt; drive\n</code></pre> <pre><code>Amplitude: \n| 0.00 \u2264 t &lt; 0.50: Constant(t, 1.00)\n| 0.50 \u2264 t &lt; 1.50: Ramp(t, 0.00, 0.50)\n| 1.50 \u2264 t &lt; 3.00: Delay(t)\n| 3.00 \u2264 t &lt; 3.50: Constant(t, 1.00)\n| 3.50 \u2264 t &lt; 4.50: Ramp(t, 0.00, 0.50)\n| 4.50 \u2264 t \u2264 6.00: Delay(t)\n\nDetuning: \n| 0.00 \u2264 t &lt; 2.00: Ramp(t, -1.00, 1.00)\n| 2.00 \u2264 t &lt; 3.00: Constant(t, 1.00)\n| 3.00 \u2264 t &lt; 5.00: Ramp(t, -1.00, 1.00)\n| 5.00 \u2264 t \u2264 6.00: Constant(t, 1.00)\n</code></pre> <pre><code>drive.draw()\n</code></pre> 2025-07-29T14:50:41.493337 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/execution/","title":"Executing a quantum program","text":"<p>Let us revisit the quantum program described in the Quantum program page.</p> <pre><code>from qoolqit import PiecewiseLinear\nfrom qoolqit import Register, Drive, QuantumProgram\nfrom qoolqit import MockDevice\n\n# Defining the Drive\nwf0 = PiecewiseLinear([1.0, 2.0, 1.0], [0.0, 0.5, 0.5, 0.0])\nwf1 = PiecewiseLinear([1.0, 2.0, 1.0], [-1.0, -1.0, 1.0, 1.0])\ndrive = Drive(amplitude = wf0, detuning = wf1)\n\n# Defining the Register\ncoords = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]\nregister = Register.from_coordinates(coords)\n\n# Creating the Program\nprogram = QuantumProgram(register, drive)\n\n# Compiling the Program\ndevice = MockDevice()\nprogram.compile_to(device)\n</code></pre> <pre><code>\n</code></pre> <p>The compiled program is ready to be executed using its <code>run()</code> method. The signature of this method is the following: <pre><code>def run(\n    self,\n    backend_name: BackendName = BackendName.QUTIP,\n    result_type: ResultType = ResultType.STATEVECTOR,\n    runs: int = 100,\n    evaluation_times: list[float] = [1.0],\n    **backend_params: Any,\n) -&gt; OutputType:\n    ...\n</code></pre></p> <p>The execution process is primarily controlled by two arguments: <code>backend_name</code> and <code>result_type</code>.</p> <p>The <code>backend_name</code> parameter expects a value from the <code>BackendName</code> enumeration, which specifies the computational backend responsible for simulating the underlying Pulser sequence. Supported values include <code>QUTIP</code> and <code>EMUMPS</code>, corresponding to the QuTiP backend for Pulser and the emu-mps quantum emulator, respectively.</p> <p>The <code>result_type</code> argument determines the format of the output returned by the <code>run()</code> method. It accepts values from the <code>ResultType</code> enumeration: <code>STATEVECTOR</code> and <code>BITSTRINGS</code>.</p> <ul> <li> <p><code>STATEVECTOR</code> returns a NumPy array of shape \\(T \\times 2^N\\), representing the quantum state vectors of an \\(N\\)-qubit system at \\(T\\) time points.</p> </li> <li> <p><code>BITSTRINGS</code> returns a list of length \\(T\\), where each element is a <code>Counter</code> object containing the counts of the sampled bitstrings of the system\u2019s output state at the corresponding time point. The total number of samples is given by the <code>runs</code> argument of the <code>run()</code> method.</p> </li> </ul> <p>The collection of \\(T\\) time points where the output states are returned are controlled by the <code>evaluation_time</code> argument. It accepts a list of floats between 0.0 and 1.0 that are mapped internally to the whole duration of the underlying sequence of the quantum program.</p> <p>Finally, the user can pass keyword arguments for the backend's internal configuration. The corresponding documentation on the underlying configuration object is available here.</p> <p>Let us run the quantum program defined previously and request the state vectors as output.</p> <pre><code>from qoolqit.execution import BackendName, ResultType\nimport numpy as np\n\n# Define the evaluation times list\nT = 101\nevaluation_times = np.linspace(0, 1, T).tolist()\n\n# Simulate with QUTIP backend and output state vectors\nqutip_state_vecs = program.run(\n    backend_name=BackendName.QUTIP,\n    result_type=ResultType.STATEVECTOR,\n    evaluationtimes=evaluation_times)\n\nprint(\"Shape of the output for state vectors:\")\nprint(qutip_state_vecs.shape)\n\nprint(\"Final state vector:\")\nprint(qutip_state_vecs[-1])\n</code></pre> <pre><code>Shape of the output for state vectors:\n(1, 16)\nFinal state vector:\n[ 0.32824231-0.04375191j  0.29735705-0.05562653j  0.29735705-0.05562653j\n -0.11008115-0.21027933j  0.29735705-0.05562653j -0.11008115-0.21027933j\n  0.23702074-0.22449441j -0.09603816+0.10719559j  0.29735705-0.05562653j\n  0.23702074-0.22449441j -0.11008115-0.21027933j -0.09603816+0.10719559j\n -0.11008115-0.21027933j -0.09603816+0.10719559j -0.09603816+0.10719559j\n  0.04086465-0.03547378j]\n</code></pre> <p>We can run similar simulation and output bitstrings instead.</p> <pre><code># Number of samples\nruns = 1000\n\n# Simulate with EMUMPS backend and output bitstring counts\nemumps_bitstrings = program.run(\n    backend_name=BackendName.EMUMPS,\n    result_type=ResultType.BITSTRINGS,\n    evaluation_times=evaluation_times,\n    runs=runs)\n\nprint(\"Length of the output list:\")\nprint(len(emumps_bitstrings))\n\nprint(\"Final state bitstrings:\")\nprint(emumps_bitstrings[-1])\n</code></pre> <pre><code>Length of the output list:\n100\nFinal state bitstrings:\nCounter({'0000': 119, '0110': 109, '1001': 102, '0001': 95, '0100': 90, '0010': 88, '1000': 84, '0101': 63, '1010': 60, '1100': 58, '0011': 47, '1011': 22, '0111': 22, '1110': 20, '1101': 18, '1111': 3})\n</code></pre>"},{"location":"contents/graphs/","title":"Standard structure for Graphs","text":"<p>Working with graphs is an essential part of computations with the Rydberg analog model. For that reason, QoolQit implements a specific <code>DataGraph</code> class to serve as the basis of all graph creation and manipulation, and setting the logic related to unit-disk graphs. QoolQit integrates with NetworkX for many operations, and the <code>DataGraph</code> inherits from <code>nx.Graph</code>.</p>"},{"location":"contents/graphs/#basic-construction","title":"Basic construction","text":"<p>The <code>DataGraph</code> is an undirected graph with no self loops. The default way to instantiate a <code>DataGraph</code> is with a set of edges.</p> <pre><code>from qoolqit import DataGraph\n\nedges = [(0, 1), (1, 2), (2, 3), (3, 0)]\ngraph = DataGraph(edges)\n</code></pre> <p>Later in the graph constructors section we also describe how to construct graphs from sets of coordinates, or with built-in constructors.</p> <p>As with any NetworkX graph, the set of nodes and edges can be accessed:</p> <p><pre><code>print(graph.nodes)\n</code></pre> <pre><code>[0, 1, 2, 3]\n</code></pre> <pre><code>print(graph.edges)\n</code></pre> <pre><code>[(0, 1), (0, 3), (1, 2), (2, 3)]\n</code></pre> </p> <p>These are the standard <code>NodeView</code> and <code>EdgeView</code> objects from NetworkX, and thus can be used add and access node and edge attributes.</p>"},{"location":"contents/graphs/#drawing","title":"Drawing","text":"<p>We can draw the graph with <code>graph.draw()</code>, which calls <code>draw_networkx</code>. As such, optional arguments can be passed that will be fed to NetworkX. <pre><code>import networkx as nx\n\npos = nx.circular_layout(graph)\n\ngraph.draw(pos = pos)\n</code></pre> 2025-07-29T14:50:48.818389 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ </p>"},{"location":"contents/graphs/#coordinates-and-distances","title":"Coordinates and distances","text":"<p>One convenient property added by QoolQit is the <code>sorted_edges</code>, which guarantees that the indices in each edge tuple are always provided as \\((u, v):u&lt;v\\). This condition is not guaranteed by calling the NetworkX property <code>graph.edges</code>, but is sometimes useful.</p> <pre><code>print(graph.sorted_edges)\n</code></pre> <pre><code>{(0, 1), (1, 2), (0, 3), (2, 3)}\n</code></pre> <p>Another convenient property is accessing the pairs of all nodes in the graph, which again follow the convention of \\((u, v):u&lt;v\\). <pre><code>print(graph.all_node_pairs)\n</code></pre> <pre><code>{(0, 1), (1, 2), (0, 3), (2, 3), (0, 2), (1, 3)}\n</code></pre> </p> <p>In QoolQit a set of attributes that takes center stage when dealing with graphs are the node coordinates. These are essential for the Rydberg analog model as they directly translate to qubit positions that define the interaction term in the Hamiltonian. This behaviour has a close connection with the study of unit-disk graphs, where node coordinates are also essential. The coordinates can be set directly in the respective property:</p> <p><pre><code># The list must have the same length as the number of nodes:\ngraph.coords = [(-0.5, -0.5), (-0.5, 0.5), (0.5, 0.5), (0.5, -0.5)]\n\ngraph.coords\n</code></pre> <pre><code>{0: (-0.5, -0.5), 1: (-0.5, 0.5), 2: (0.5, 0.5), 3: (0.5, -0.5)}\n</code></pre>  Both a dictionary or a list can be passed, which will be converted to a dictionary. Because the graph now has a set of node coordinates, we can directly access the distance between the nodes. Optionally, a set of node pairs can be given and only those distances will be computed.</p> <pre><code># Compute for all node pairs\ngraph.distances()\n\n# Compute only for connected nodes\ngraph.distances(graph.sorted_edges)\n\n# Compute for a specific set of node pairs\ngraph.distances([(0, 1), (0, 2)])\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 1.0, (0, 3): 1.0, (2, 3): 1.0, (0, 2): 1.4142135623730951, (1, 3): 1.4142135623730951}\n{(0, 1): 1.0, (1, 2): 1.0, (0, 3): 1.0, (2, 3): 1.0}\n{(0, 1): 1.0, (0, 2): 1.4142135623730951}\n</code></pre> <p>Note</p> <p>Accessing distances as NumPy arrays or Torch tensors will be designed later.</p> <p>Furthermore, when calling <code>graph.draw()</code> the coordinate information will be automatically used.</p> <pre><code>graph.draw()\n</code></pre> 2025-07-29T14:50:48.881522 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Graph coordinates can be rescaled. The <code>rescale_coords</code> method only accepts a keyword argument, which must be either <code>scaling</code> or <code>spacing</code>.</p> <pre><code># Rescale coordinates by a constant factor\ngraph.rescale_coords(scaling = 2.0)\n\n# Rescale coordinates by setting the minimum spacing\ngraph.rescale_coords(spacing = 1.0)\n</code></pre> <p>The minimum and maximum distance can be directly checked.</p> <pre><code># Compute for all node pairs\ngraph.min_distance()\ngraph.max_distance()\n\n# Compute only for connected nodes\ngraph.min_distance(connected = True)\n\n# Compute only for disconnected nodes\ngraph.min_distance(connected = False)\n</code></pre>"},{"location":"contents/graphs/#unit-disk-graphs","title":"Unit-disk graphs","text":"<p>Working with node coordinates and distances is an essential part of dealing with unit-disk graphs.</p> <p></p> <p>Definition: Unit-Disk Graphs</p> <p>For a set of nodes \\(V\\), each node \\(i\\in V\\) marked by a set of coordinates \\((x, y)_i\\) in Euclidean space, a set of edges \\(E\\) and a radius \\(R\\), a Unit-Disk Graph \\(UDG(V, E, R)\\) is such that there exists an edge \\((i, j)\\in E\\) for two nodes \\(i\\) and \\(j\\) if and only if \\(\\text{dist}(i, j) \\leq R\\), where \\(\\text{dist}(i, j)\\) is the Euclidean distance between the coordinates of nodes \\(i\\) and \\(j\\).</p> <p>In other words, a unit-disk graph for a radius \\(R\\) is the graph where the set of edges corresponds to the intersections of disks of radius \\(R/2\\) centered at each node position in Euclidean space.</p> <p>For a <code>DataGraph</code> with a set of node coordinates, we can check if it is a valid unit-disk graph</p> <pre><code>graph.is_ud_graph()\n</code></pre> <pre><code>True\n</code></pre> <p>This method checks that <code>graph.max_distance(connected = True)</code> is smaller than <code>graph.min_distance(connected = False)</code>. If this is <code>True</code>, then for every value of \\(R\\) inside that interval the unit-disk condition is met. We can easily check this.</p> <p>First, we can check the set of edges given by the intersection of unit disks:</p> <pre><code># For a small value no disks intersect, the set is empty\nud_edges = graph.ud_edges(radius = 0.1)\n\n# For a large enough value all disks intersect\nud_edges = graph.ud_edges(radius = 50.0)\n\nassert ud_edges == graph.all_node_pairs\n</code></pre> <pre><code>Radius = 0.1:  set()\nRadius = 50.0:  {(0, 1), (1, 2), (0, 3), (2, 3), (0, 2), (1, 3)}\n</code></pre> <p>Now, we can randomly pick a value or \\(R\\) matching the unit-disk condition and verify that the set of unit-disk edges exactly match the set of edges in the graph. The possible range of values is directly available with the <code>ud_radius_range()</code> method.</p> <pre><code>import numpy as np\n\nlow, high = graph.ud_radius_range()\n\nR = np.random.uniform(low, high)\n\nprint(graph.ud_edges(radius = R) == graph.sorted_edges)\n</code></pre> <pre><code>True\n</code></pre> <p>We can also reset the set of edges on a graph to be equal to the set of unit-disk edges for a given radius with <code>graph.set_ud_edges(radius = R)</code>. For this example we will not run this line, but we show it later when constructing a graph from a set of coordinates.</p>"},{"location":"contents/graphs/#node-and-edge-weights","title":"Node and edge weights","text":"<p>Another two important attributes are node weights and edge weights:</p> <pre><code>import random\n\ngraph.node_weights = {i: random.random() for i in graph.nodes}\ngraph.edge_weights = {edge: random.random() for edge in graph.sorted_edges}\n</code></pre> <p>If the graph does not have these attributes, the dictionaries will still be returned with <code>None</code> in place of the value. A set of boolean properties allows quickly checking if the graph has coordinates or weights. It only returns <code>True</code> if there is a value set for every node / edge in the graph.</p> <p>Note</p> <p>Accessing weights as NumPy arrays or Torch tensors will be designed later.</p> <pre><code>assert graph.has_coords\nassert graph.has_node_weights\nassert graph.has_edge_weights\n</code></pre> <p></p>"},{"location":"contents/graphs/#graph-constructors","title":"Graph constructors","text":"<p>Class constructors can help you create a variety of graphs. A very useful constructor is starting from a set of coordinates. By default that will create an empty set of edges, but we can use the <code>set_ud_edges</code> method to specify the edges as the unit-disk intersections.</p> <pre><code>from qoolqit import DataGraph\n\ncoords = [(-1.0, 0.0), (0.0, 0.0), (1.0, 0.0), (0.0, 1.0), (0.0, -1.0)]\n\ngraph = DataGraph.from_coordinates(coords)\n\nassert len(graph.edges) == 0\n\ngraph.set_ud_edges(radius = 1.0)\n\nassert len(graph.edges) &gt; 0\n\ngraph.draw()\n</code></pre> 2025-07-29T14:50:49.229148 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Some geometric graph constructors will already have coordinates by default.</p> <pre><code>from qoolqit import DataGraph\n\n# A line graph on n nodes.\ngraph = DataGraph.line(n = 10, spacing = 1.0)\n\n# A circle graph on n nodes.\ngraph = DataGraph.circle(n = 10, spacing = 1.0, center = (0.0, 0.0))\n\n# An random UD graph by uniformly sampling points in area of side L\ngraph = DataGraph.random_ud(n = 10, radius = 1.0, L = 2.0)\n\ngraph.draw()\n</code></pre> 2025-07-29T14:50:49.309237 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Other generic constructors are also available which have no information on node coordinates.</p> <pre><code># An Erd\u0151s\u2013R\u00e9nyi random graph\ngraph = DataGraph.random_er(n = 10, p = 0.5, seed = 1)\n\ngraph.draw()\n</code></pre> 2025-07-29T14:50:49.397321 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/graphs/#loading-from-a-matrix","title":"Loading from a matrix","text":"<p>Loading an adjacency matrix into a graph is also possible.</p> <ul> <li>Given that graphs in QoolQit are undirected, the matrix must be symmetric.</li> <li>As in the standard adjacency matrix interpretation, off-diagonal elements are loaded as edge-weights as long as they are non-zero.</li> <li>Given that QoolQit does not consider graphs with self-loops, diagonal elements are loaded as node-weights.</li> </ul> <pre><code>import numpy as np\n\nn_nodes = 5\ndata = np.random.rand(n_nodes, n_nodes)\n\n# Matrix must be symmetric\ndata = data + data.T\n\ngraph = DataGraph.from_matrix(data)\n\nassert graph.has_node_weights\nassert graph.has_edge_weights\n</code></pre> <p>If all values in the diagonal are 0, then no node-weights will be set. Furthermore, edges and edge-weights will only be set for non-zero off-diagonal elements.</p> <pre><code># Setting the diagonal to zero\nnp.fill_diagonal(data, 0.0)\n\n# Removing the value for the pair (1, 2)\ndata[1, 2] = 0.0\ndata[2, 1] = 0.0\n\ngraph = DataGraph.from_matrix(data)\n\n# Checking there are no node weights and the edge (1, 2) was not added\nassert not graph.has_node_weights\nassert (1, 2) not in graph.edges\n</code></pre>"},{"location":"contents/programs/","title":"Creating a quantum program","text":"<p>A <code>QuantumProgram</code> combines a <code>Register</code> and a <code>Drive</code> and serves as the main interface for compilation and execution.</p> <pre><code>from qoolqit import PiecewiseLinear\nfrom qoolqit import Register, Drive, QuantumProgram\n\n# Defining the Drive\nwf0 = PiecewiseLinear([1.0, 2.0, 1.0], [0.0, 0.5, 0.5, 0.0])\nwf1 = PiecewiseLinear([1.0, 2.0, 1.0], [-1.0, -1.0, 1.0, 1.0])\ndrive = Drive(amplitude = wf0, detuning = wf1)\n\n# Defining the Register\ncoords = [(0.0, 0.0), (0.0, 1.0), (1.0, 0.0), (1.0, 1.0)]\nregister = Register.from_coordinates(coords)\n\n# Creating the Program\nprogram = QuantumProgram(register, drive)\n</code></pre> <pre><code>Quantum Program:\n| Register(n_qubits = 4)\n| Drive(duration = 4.000)\n| Compiled: False\n</code></pre> <p>At this point, the program has not been compiled to any device. As shown above, this is conveniently displayed when printing the program. It can also be checked through the <code>is_compiled</code> property.</p> <pre><code>program.is_compiled\n</code></pre> <pre><code>False\n</code></pre> <p>Now we instantiate a device and compile the program to that device. Compiling in QoolQit means to translate the adimensional values of time, energy, and distance used when defining the program in the Rydberg analog model to a specific set of values that implement the same set of instructions in a Pulser device, taking into account the Pulser units and the specific parameters of that device. More detailed information on this conversion is provided in the Rydberg analog model page.</p> <pre><code>from qoolqit import AnalogDevice\n\ndevice = AnalogDevice()\n\nprogram.compile_to(device)\n</code></pre> <pre><code>Quantum Program:\n| Register(n_qubits = 4)\n| Drive(duration = 4.000)\n| Compiled: True\n| Device: AnalogDevice\n</code></pre> <p>Now that the program has been compiled, we can inspect the compiled sequence, which is an instance of a Pulser <code>Sequence</code>.</p> <pre><code>pulser_sequence = program.compiled_sequence\n</code></pre> <p>Finally, we can draw both the original program and the compiled sequence.</p> <pre><code>program.draw()\n</code></pre> 2025-07-29T14:50:49.567629 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <pre><code>program.draw(compiled = True)\n</code></pre> 2025-07-29T14:50:49.700324 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/programs/#compiler-profiles","title":"Compiler profiles","text":"<p>In the example above the <code>AnalogDevice</code> was used, and no changes were made to the unit converter. As such, the default was used, which sets the reference energy unit as the maximum amplitude, as described in the Devices page.</p> <p>When a QoolQit program is compiled to Pulser, several compiler profiles can be used. You can check them in the following enumeration:</p> <pre><code>from qoolqit import CompilerProfile\n\nprint(CompilerProfile)\n</code></pre> <pre><code>&lt;Enum 'CompilerProfile':\n| DEFAULT = 'Default'\n| MAX_AMPLITUDE = 'MaxAmplitude'\n| MAX_DURATION = 'MaxDuration'\n| MIN_DISTANCE = 'MinDistance'&gt;\n</code></pre> <p>By default <code>CompilerProfile.DEFAULT</code> is used, which directly takes the unit converter present in the device and uses it when converting the values.</p> <p>Other compiler profiles will ignore the unit converter present in the device and utilize their own logic to determine the best possible conversion to achieve a desired compilation directive.</p> <p>The <code>CompilerProfile.MAX_AMPLITUDE</code> maps whatever is the maximum amplitude in the drive of your QoolQit program to the device's maximum allowed amplitude: <pre><code>program.compile_to(device, profile = CompilerProfile.MAX_AMPLITUDE)\nprogram.draw(compiled = True)\n</code></pre> 2025-07-29T14:50:49.907105 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ </p> <p>The <code>CompilerProfile.MAX_DURATION</code> maps whatever is the duration of your QoolQit program to the device's maximum allowed sequence duration: <pre><code>program.compile_to(device, profile = CompilerProfile.MAX_DURATION)\nprogram.draw(compiled = True)\n</code></pre> 2025-07-29T14:50:50.257679 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ </p> <p>The <code>CompilerProfile.MIN_DISTANCE</code> maps whatever is the minimum distance in the register of your QoolQit program to the device's minimum allowed atom separation: <pre><code>try:\n    program.compile_to(device, profile = CompilerProfile.MIN_DISTANCE)\nexcept Exception as error:\n    print(error)\n</code></pre> <pre><code>Failed to compile the sequence due to:\n\nThe pulse's amplitude goes over the maximum value allowed for the chosen channel.\n</code></pre> </p> <p>In this case, you can see the compilation failed because putting the atoms that close together for this program would require setting an amplitude that is larger than what the device allows.</p>"},{"location":"contents/registers/","title":"Creating qubit registers","text":"<p>A <code>Register</code> defines the qubit resources to be used by a quantum program.</p> <pre><code>from qoolqit import Register\n\nqubits = {\n    0: (-0.5, -0.5),\n    1: (-0.5, 0.5),\n    2: (0.5, -0.5),\n    3: (0.5, 0.5),\n}\n\nregister = Register(qubits)\n</code></pre> <pre><code>Register(n_qubits = 4)\n</code></pre> <p>It can be instantiated from a list of coordinates.</p> <pre><code>coords = [(-0.5, -0.5), (-0.5, 0.5), (0.5, -0.5), (0.5, 0.5)]\n\nregister = Register.from_coordinates(coords)\n\nregister.draw()\n</code></pre> 2025-07-29T14:50:50.433285 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>The distances between all qubits can be directly accessed.</p> <pre><code>register.distances()\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 1.4142135623730951, (0, 3): 1.4142135623730951, (2, 3): 1.0, (0, 2): 1.0, (1, 3): 1.0}\n</code></pre> <p>The minimum distance can be directly accessed.</p> <pre><code>register.min_distance()\n</code></pre> <pre><code>1.0\n</code></pre> <p>The interaction coefficients \\(1/r_{ij}^6\\) can be directly accessed.</p> <pre><code>register.interactions()\n</code></pre> <pre><code>{(0, 1): 1.0, (1, 2): 0.12499999999999994, (0, 3): 0.12499999999999994, (2, 3): 1.0, (0, 2): 1.0, (1, 3): 1.0}\n</code></pre>"},{"location":"contents/waveforms/","title":"Writing time-dependent functions","text":"<p>An essential part of writing programs in the Rydberg analog model is to write the time-dependent functions representing the amplitude and detuning terms in the drive Hamiltonian. For that, QoolQit implements a set of waveforms that can be used directly and/or composed together.</p>"},{"location":"contents/waveforms/#base-waveforms","title":"Base waveforms","text":"<p>A full list of the available waveforms can be found in the API reference.</p> <pre><code>from qoolqit import Constant, Ramp, Delay\n\n# An empty waveform\nwf1 = Delay(1.0)\n\n# A waveform with a constant value\nwf2 = Constant(1.0, 2.0)\n\n# A waveform that ramps linearly between two values\nwf3 = Ramp(1.0, -1.0, 1.0)\n</code></pre> <pre><code>0.00 \u2264 t \u2264 1.00: Delay(t)\n0.00 \u2264 t \u2264 1.00: Constant(t, 2.00)\n0.00 \u2264 t \u2264 1.00: Ramp(t, -1.00, 1.00)\n</code></pre> <p>As shown above, printing a waveform shows the duration interval over which it applies followed by the description of the waveform.</p> <p>The first argument is always the <code>duration</code> of the waveform, and the remaining arguments depend on the information required by each waveform. The resulting object is a callable that can be evaluated at any time \\(t\\).</p> <pre><code>wf1(t = 0.0)\nwf2(t = 0.5)\nwf3(t = 1.0)\n</code></pre> <pre><code>wf1(t = 0.0) = 0.0\nwf2(t = 0.5) = 2.0\nwf3(t = 1.0) = 1.0\n</code></pre> <p>Each waveform also supports evaluation at multiple time steps by calling it on an array of times. <pre><code>import numpy as np\n\nt_array = np.linspace(0.0, 2.0, 9)\n\nwf3(t_array)\n</code></pre> <pre><code>t =      [0.   0.25 0.5  0.75 1.   1.25 1.5  1.75 2.  ]\nwf(t) =  [-1.  -0.5  0.   0.5  1.   0.   0.   0.   0. ]\n</code></pre> </p> <p>In the waveform above, we defined it with a duration of \\(1.0\\), and then evaluated it over nine points from \\(t = 0.0\\) to \\(t=2.0\\). As you can see, all points after \\(t = 1.0\\) evaluated to \\(0.0\\). By default, any waveform evaluated at a time \\(t\\) that falls outside the specified <code>duration</code> gives \\(0.0\\).</p> <p>Waveforms can be quickly drawn with the <code>draw()</code> method.</p> <pre><code>wf3.draw()\n</code></pre> 2025-07-29T14:50:50.530985 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/waveforms/#composite-waveforms","title":"Composite waveforms","text":"<p>The most straightforward way to arbitrarily compose waveforms is to use the <code>&gt;&gt;</code> operator. This will create a <code>CompositeWaveform</code> representing the waveforms in the order provided.</p> <pre><code>wf_comp = wf1 &gt;&gt; wf2 &gt;&gt; wf3\n</code></pre> <pre><code>Composite waveform:\n| 0.00 \u2264 t &lt; 1.00: Delay(t)\n| 1.00 \u2264 t &lt; 2.00: Constant(t, 2.00)\n| 2.00 \u2264 t \u2264 3.00: Ramp(t, -1.00, 1.00)\n</code></pre> <p>The code above is equivalent to calling <code>CompositeWaveform(wf1, wf2, wf3)</code>. As shown, printing the composite waveform will automatically show the individual waveforms in the composition and the times at which they are active. These are automatically calculated from the individual waveforms. A <code>CompositeWaveform</code> is by itself a subclass of <code>Waveform</code>, and thus the previous logic on calling it at arbitrary time values also applies.</p> <p>A few convenient properties are directly available in a composite waveform:</p> <pre><code># Total duration\nwf_comp.duration\n\n# List of durations of the individual waveforms\nwf_comp.durations\n\n# List of times where each individual waveform starts / ends\nwf_comp.times\n</code></pre> <pre><code>Total duration : 3.0\nList of durations : [1.0, 1.0, 1.0]\nList of times : [0.0, 1.0, 2.0, 3.0]\n</code></pre> <p>A custom waveform can directly be a <code>CompositeWaveform</code>. That is the case with the <code>PiecewiseLinear</code> waveform, which takes a list of durations (of size \\(N\\)) and a list of values (of size \\(N+1\\)) and creates a linear interpolation between all values using individual waveforms of type <code>Ramp</code>.</p> <pre><code>from qoolqit import PiecewiseLinear\n\ndurations = [1.0, 1.0, 2.0]\nvalues = [0.0, 1.0, 0.5, 0.5]\n\nwf_pwl = PiecewiseLinear(durations, values)\n\nwf_pwl.draw()\n</code></pre> 2025-07-29T14:50:50.641185 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"contents/waveforms/#defining-custom-waveforms","title":"Defining custom waveforms","text":"<p>The waveform system of QoolQit can be easily extended by subclassing the <code>Waveform</code> class and defining some key properties and methods. To exemplify this we will create a waveform representing a simple shifted sine function,</p> \\[     \\text{Sin}(t)_{\\omega, C} \\equiv \\sin(\\omega t) + C \\] <pre><code>from qoolqit.waveforms import Waveform\n\nimport math\n\nclass Sin(Waveform):\n    \"\"\"A simple sine over a given duration.\n\n    Arguments:\n        duration: the total duration.\n        omega: the frequency of the sine wave.\n        shift: the vertical shift of the sine wave.\n    \"\"\"\n\n    def __init__(\n        self,\n        duration: float,\n        omega: float = 2.0 * math.pi,\n        shift: float = 0.0,\n    ) -&gt; None:\n        super().__init__(duration, omega = omega, shift = shift)\n\n    def function(self, t: float) -&gt; float:\n        return math.sin(self.omega * t) + self.shift\n</code></pre> <p>A few things are crucial in the snippet above:</p> <ul> <li>Keeping the <code>duration</code> argument as the first one in the <code>__init__</code>, and initializing the parent class with that value, to be consistent with other waveforms.</li> <li>Passing every other parameter needed for the waveform in the <code>__init__</code> and passing it as a keyword argument to the parent class. This will automatically create a <code>params</code> dictionary of extra parameters, and set them as attributes to be used later.</li> <li>Overriding the <code>function</code> abstract method, which represents the evaluation of the waveform at some time <code>t</code>.</li> <li>Optional: overriding the <code>max</code> and <code>min</code> methods. The intended result of <code>wf.max()</code> and <code>wf.min()</code> is to get the maximum/minimum value the waveform takes over its duration. By default, the base <code>Waveform</code> class implements a brute-force sampling method that approximates the maximum and minimum values. However, if this value is easy to know from the waveform parameters, the method should be overriden.</li> </ul> <p>To showcase the usage of the newly defined waveform, let's define a new sine waveform and compose it with a piecewise linear waveform.</p> <pre><code>from qoolqit import PiecewiseLinear\nimport math\n\nwf1 = Sin(\n    duration = 1.0,\n    omega = 2.0 * math.pi,\n    shift = 1.0\n)\n\nwf2 = PiecewiseLinear(\n    durations = [0.5, 0.5],\n    values = [1.0, 1.0, 0.0],\n)\n\nwf_comp = wf1 &gt;&gt; wf2\n</code></pre> <pre><code>Composite waveform:\n| 0.00 \u2264 t &lt; 1.00: Sin(t, 6.28, 1.00)\n| 1.00 \u2264 t &lt; 1.50: Ramp(t, 1.00, 1.00)\n| 1.50 \u2264 t \u2264 2.00: Ramp(t, 1.00, 0.00)\n</code></pre> <pre><code>wf_comp.draw()\n</code></pre> 2025-07-29T14:50:50.751975 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Following this example, more complete <code>Sin</code> waveform is directly available in QoolQit implementing</p> \\[     \\text{Sin}(t)_{A, \\omega, \\phi, C} \\equiv A * \\sin(\\omega t + \\phi) + C \\] <pre><code>from qoolqit import Sin\n\nwf = Sin(\n    duration = 1.0,\n    amplitude = 2.0,\n    omega = 6.0,\n    phi = -5.0,\n    shift = 1.0,\n)\n\nwf.max()\n</code></pre> <pre><code>0.00 \u2264 t \u2264 1.00: Sin(t, 2.00, 6.00, -5.00, 1.00)\nMaximum value:  2.999999066583827\n</code></pre> <pre><code>wf.draw()\n</code></pre> 2025-07-29T14:50:50.833211 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"getting_started/installation/","title":"Installation","text":"<p>QoolQit can be installed from PyPi with <code>pip</code> as follows</p> <pre><code>$ pip install qoolqit\n\n# or\n\n$ pipx install qoolqit\n</code></pre>"},{"location":"getting_started/installation/#install-from-source","title":"Install from source","text":"<p>If you wish to install directly from the source, for example, if you are developing code for QoolQit, you can:</p> <p>1) Clone the QoolQit GitHub repository</p> <pre><code>git clone https://github.com/pasqal-io/qoolqit.git\n</code></pre> <p>2) Setup an environment for developing. We recommend using Hatch. With Hatch installed, you can enter the <code>qoolqit</code> repository and run</p> <pre><code>hatch shell\n</code></pre> <p>This will automatically take you into an environment with the necessary dependencies. Alternatively, if you wish to use a different environment manager like <code>conda</code> or <code>venv</code>, you can instead enter the <code>qoolqit</code> repository from within the environment and run</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"getting_started/installation/#using-any-pyproject-compatible-python-manager","title":"Using any pyproject-compatible Python manager","text":"<p>For usage within a project with a corresponding <code>pyproject.toml</code> file, you can add</p> <pre><code>  \"qoolqit\"\n</code></pre> <p>to the list of <code>dependencies</code>.</p>"},{"location":"theory/rydberg_model/","title":"Quantum computing with Rydberg atoms","text":"<p>This page centralizes the theoretical framework of QoolQit. To start writing programs, go straight to the contents section, or check out the tutorials section.</p> <p>Manipulating Rydberg atomic systems for quantum computing is a complex topic, and in this page we will not cover all aspects of it. The aim of this page is to introduce the underlying computational model when writing analog algorithms with Rydberg atoms, and to abstract away as much as possible the hardware details on how these algorithms are implemented. For a more detailed description on the physics and hardware implementation of quantum computing with Rydberg atoms, check out the Pulser library.</p>"},{"location":"theory/rydberg_model/#the-rydberg-analog-model","title":"The Rydberg Analog Model","text":"<p>The Rydberg Analog Model is a computational model following the Ising-mode operation of Rydberg atoms. Similarly to the circuit-model, it adopts the qubit as the basic unit of information. Two characteristics of the Rydberg analog model make it inherently different from the circuit-model:</p> <ul> <li> <p>It is a continuous-time model, meaning all operations are defined as time-evolving processes that continuously alter the state of the qubits.</p> </li> <li> <p>The spatial arrangement of the qubits has a direct influence on the operations due to the always-on physical interaction of the atoms.</p> </li> </ul>"},{"location":"theory/rydberg_model/#register","title":"Register","text":"<p>The register defines the qubit resources available to perform the computation.</p> <p>Definition: Register</p> <p>A register \\(R\\) is a set of qubits, each identified by an index \\(q_i\\) and a position \\(p_i = (x_i, y_i)\\), \\(R=\\{(q_i, p_i)\\}\\), with size \\(|R|=N\\). A register is assumed to have an initial state \\(|\\psi_R(t=0)\\rangle = |0\\rangle^{\\otimes N}\\)</p>"},{"location":"theory/rydberg_model/#interaction","title":"Interaction","text":"<p>Once a register is initialized, the physics of Rydberg atoms dictate that the state of the qubits evolves with an always-on interaction Hamiltonian. This background interaction is constant in time, and present during the whole program.</p> <p>Definition: Interaction Hamiltonian</p> <p>The interaction Hamiltonian is defined as</p> \\[H^\\text{int}=\\sum_{i=0}^{N-1}\\sum_{j=0}^{i-1}\\frac{1}{r^6_{ij}}\\hat{n}_i\\hat{n}_j,\\] <p>where \\(r_{ij}=\\sqrt{(x_i-x_j)^2+(y_i-y_j)^2}\\) is the distance between qubits \\(q_i\\) and \\(q_j\\), and \\(\\hat{n}=\\frac12(1-\\hat{\\sigma}^z)\\) is the number operator.</p>"},{"location":"theory/rydberg_model/#drive","title":"Drive","text":"<p>A program in the Rydberg analog model is defined as a time-dependent drive Hamiltonian that is imposed on the qubits (in addition to the interaction Hamiltonian).</p> <p>Definition: Drive Hamiltonian</p> <p>The drive Hamiltonian is defined as</p> \\[ H^\\text{d}(t)=\\sum_{i=0}^{N-1}\\frac{\\Omega_i(t)}{2}\\left(\\cos\\phi_i(t)\\hat{\\sigma}^x_i-\\sin\\phi_i(t)\\hat{\\sigma}^y_i\\right)-\\delta_i(t)\\hat{n}_i \\] <p>where \\(\\Omega_i(t)\\), \\(\\delta_i(t)\\) and \\(\\phi_i(t)\\) are time-dependent functions, or waveforms, that encode the program corresponding, respectively, to the amplitude, detuning and phase of the drive on each qubit.</p> <p>The drive \\(D_i(t)\\) is the set of functions \\(D_i(t) = \\{\\Omega_i(t), \\delta_i(t), \\phi_i(t)\\}\\) defined for \\(t\\geq0\\) that define the time-dependent Hamiltonian \\(H^\\text{d}_i(t)\\) driving qubit \\(q_i\\).</p> <p>The drive is global if it is the same for all qubits in the register, \\(D_i(t)=D(t)~\\forall~q_i\\in R\\).</p>"},{"location":"theory/rydberg_model/#weighted-detuning","title":"Weighted detuning","text":"<p>In the Rydberg analog model drives are global. However, an extra local detuning term can be added when a weight map is passed \\(\\{q_i: \\epsilon_i\\}\\), where \\(\\epsilon_i\\in[0, 1]\\) is the weight for each qubit \\(q_i\\). Then, the detuning term changes to</p> \\[ H^\\text{d}(t)=\\sum_{i=0}^{N-1}\\frac{\\Omega(t)}{2}\\left(\\cos\\phi(t)\\hat{\\sigma}^x_i-\\sin\\phi(t)\\hat{\\sigma}^y_i\\right)-\\delta_\\text{max}(\\delta(t)+\\epsilon_i\\Delta(t))\\hat{n}_i \\] <p>with the condition that the waveform \\(\\Delta(t)\\) must be negative.</p>"},{"location":"theory/rydberg_model/#the-full-model","title":"The full model","text":"<p>Definition: Rydberg Analog Model</p> <p>A register of qubits \\(R\\) is initialized, where each qubit \\(q_i\\) has a position \\(p_i = (x_i, y_i)\\).</p> <p>The local detuning weights are programmed, \\(\\{q_i: \\epsilon_i\\}\\).</p> <p>The drive waveforms are programmed, \\(D(t) = \\{\\Omega(t), \\delta(t), \\Delta(t), \\phi(t)\\}\\).</p> <p>The system evolves with the Hamiltonian:</p> \\[ H(t)=\\sum_{i=0}^{N-1}\\frac{\\Omega(t)}{2}\\left(\\cos\\phi(t)\\hat{\\sigma}^x_i-\\sin\\phi(t)\\hat{\\sigma}^y_i\\right)-(\\delta(t)+\\epsilon_i\\Delta(t))\\hat{n}_i + \\sum_{i=0}^{N-1}\\sum_{j=0}^{i-1}\\frac{1}{r^6_{ij}}\\hat{n}_i\\hat{n}_j \\] <p>The system is measured in the computational basis at some time \\(t^* &gt; 0\\).</p>"},{"location":"theory/rydberg_model/#model-units","title":"Model units","text":"<p>The Rydberg Analog Model as implemented in QoolQit is adimensional, which is not the case in Pulser. Below we go over some details on how this works.</p>"},{"location":"theory/rydberg_model/#pulser-units","title":"Pulser units","text":"<p>Pulser sets \\(\\hbar=1\\) and then uses the following units:</p> \\[\\text{Time:}~[\\text{ns}],\\qquad\\text{Energy:}~[\\text{rad}.\\mu\\text{s}^{-1}],\\qquad\\text{Distance:}~[\\mu\\text{m}]\\] <p>Furthermore, Pulser writes the interaction term using a physical coefficient related to the energy level where the qubit is encoded:</p> \\[H^\\text{int}_\\text{Pulser}=\\sum_{i=0}^{N-1}\\sum_{j=0}^{i-1}\\frac{C_6}{r^6_{ij}}\\hat{n}_i\\hat{n}_j.\\] <p>The interaction coefficient \\(C_6\\) has units of \\([\\text{rad}.\\mu\\text{s}^{-1}.\\mu\\text{m}^{6}].\\)</p> <p>This seemingly small difference has an important implication: a Pulser sequence is fundamentally device-specific. Pulser has a safety-first design, and does extensive validation when each sequence is created to guarantee it is compatible with the device it is created for, which is very important.</p>"},{"location":"theory/rydberg_model/#unit-conversion","title":"Unit conversion","text":"<p>QoolQit handles the unit conversion automatically through a compilation layer, and also includes a number of features for more advanced users to customize it. This is done by defining a set of conversion factors for time, energy and distance, \\(\\{\\Delta_T\\), \\(\\Delta_E\\), \\(\\Delta_D\\}\\), such that:</p> \\[\\text{Time[P]}=\\Delta_T \\times \\text{Time[Q]},\\quad\\text{Energy[P]}=\\Delta_E \\times \\text{Energy[Q]},\\quad\\text{Distance[P]}=\\Delta_D \\times \\text{Distance[Q]},\\] <p>where \\(\\text{P}\\) and \\(\\text{Q}\\) refer to the Pulser and QoolQit units, respectively. Defining a valid set of conversion factors between QoolQit and Pulser can be done arbitrarily, as long as both the time-energy invariant and the energy-distance invariant are respected:</p> \\[\\Delta_T\\,\\times\\,\\Delta_E = 1000,\\qquad \\Delta_D^6\\,\\times\\,\\Delta_E = C_6.\\] <p>This means that it is possible to pick an arbitrary value for one of the conversion factors, and the two remaining ones can be automatically calculated from the invariants. As seen from the dependence of the invariants on the interaction coefficient \\(C_6\\), these are calculated specifically for each device, and this is what guarantees that QoolQit programs can be device agnostic.</p> <p>For details on how to customize the unit conversion in QoolQit check the contents pages on devices and quantum programs. For further examples on understanding the unit conversion check the unit conversion tutorial.</p>"},{"location":"theory/rydberg_model/#advantages-disadvantages","title":"Advantages &amp; disadvantages","text":"<p>Working with an adimensional model has a few advantages:</p> <ul> <li>Programs are more abstract and device agnostic, and the rules to compile to different devices are clearly defined.</li> <li>Algorithm descriptions are more unified and consistent, focusing more on the logic of the algorithm and less on the implementation details.</li> <li>Increases code portability between experimental setups, different hardware configurations, and even different hardware calibrations.</li> <li>Program descriptions are more future-proof, as the same description today can be valid for future hardware generations.</li> </ul> <p>However, while the above conversion is exact in theory, in practice real device execution will have sources of errors and discrepancies that are not accounted for in a simple unit conversion. Abstracting away the finer control over such errors can be seen as a disadvantage, but it is also an opportunity for improvement. The advanced user who understands such discrepancies can work on developing more robust protocols for compilation and noise mitigation and integrating them in the stack.</p>"},{"location":"tutorials/basic_qubo/","title":"Solving a basic QUBO problem","text":"<p>A QUBO instance on \\(N\\) variables consists in a symmetric matrix \\(Q\\) of size \\(N\\times N\\), and solving a QUBO problems means to find the bitstring \\(z=(z_1,...,z_N)\\in\\{0, 1\\}^N\\) that minimizes the quantity</p> \\[ f(z) = z^TQz \\]"},{"location":"tutorials/basic_qubo/#problem-generation","title":"Problem generation","text":"<p>Many real-world problems can be mapped to a QUBO problem, which means to create the matrix \\(Q\\) that encodes the problem to solve. For the purpose of this tutorial we assume this task has already been performed and we are given the matrix \\(Q\\), such as the one below:</p> <pre><code>import numpy as np\n\nQ = np.array([\n        [-10.0, 19.7365809, 19.7365809, 5.42015853, 5.42015853],\n        [19.7365809, -10.0, 20.67626392, 0.17675796, 0.85604541],\n        [19.7365809, 20.67626392, -10.0, 0.85604541, 0.17675796],\n        [5.42015853, 0.17675796, 0.85604541, -10.0, 0.32306662],\n        [5.42015853, 0.85604541, 0.17675796, 0.32306662, -10.0],\n])\n</code></pre> <p>QUBO problems are scale-invariant, and so we can work with the normalized matrix \\(\\tilde{Q}=Q/\\text{max}(Q)\\) instead.</p> <p>Before showing how to solve this QUBO instance in the Rydberg analog model, we can compute the optimal solutions classically to compare. For that we do a brute force cost calculation over all possible bitstrings, which scales exponentially with the number of variables. This is only possible because we are dealing with a small QUBO.</p> <pre><code># Normalize QUBO matrix\nQ = Q/Q.max()\n\n# Classical solution\nbitstrings = np.array([np.binary_repr(i, len(Q)) for i in range(2 ** len(Q))])\nbitstring_lists = np.array([np.array(list(b), dtype=int) for b in bitstrings])\ncosts = np.array([z.T @ Q @ z for z in bitstring_lists])\nidx_sort = np.argsort(costs).tolist()\n\nsorted_costs = costs[idx_sort]\nsorted_bitstrings = bitstrings[idx_sort]\n\nprint(\"Two best solutions: \", sorted_bitstrings[:2])\nprint(\"Respective costs: \", sorted_costs[:2])\n\n# We save the two best solutions for plotting\nmarked_bitstrings = sorted_bitstrings[:2]\n</code></pre> <pre><code>Two best solutions:  ['01011' '00111']\nRespective costs:  [-1.31978679 -1.31978679]\n</code></pre>"},{"location":"tutorials/basic_qubo/#problem-embedding","title":"Problem embedding","text":"<p>To embed the QUBO problem in the Rydberg analog model, we can directly use a matrix embedding technique like the <code>InteractionEmbedder</code>. You can read more about it in the available embedders contents page.</p> <p>The <code>InteractionEmbedder</code> maps a matrix to a graph with node coordinates, from which we can directly instantiate a qubit register later.</p> <pre><code>from qoolqit import InteractionEmbedder\n\nembedder = InteractionEmbedder()\n\nembedded_graph = embedder.embed(Q)\n\nembedded_graph.draw()\n</code></pre> 2025-07-29T14:50:51.100725 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"tutorials/basic_qubo/#writing-a-quantum-program","title":"Writing a quantum program","text":"<p>To solve this QUBO instance, we are going to use an annealing schedule where we raise the amplitude to some value \\(\\Omega\\) while sweeping the detuning from \\(\\delta_i\\) to \\(\\delta_f\\). We pick the \\(\\Omega\\) as the median of the values of \\(Q\\), and define \\(\\delta_i\\) and \\(\\delta_f\\) as \\(\\pm 2 \\Omega\\). A long enough duration should allow the annealing schedule to be successful.</p> <pre><code>from qoolqit import Register, PiecewiseLinear, Ramp, Drive, QuantumProgram\n\n# Create the register\nregister = Register.from_graph(embedded_graph)\n\n# Defining the annealing parameters\nomega = np.median(Q[Q &gt; 0].flatten())\ndelta_i = -2.0 * omega\ndelta_f = 2.0 * omega\nT = 50.0\n\n# Defining the annealing schedule\nwf_amp = PiecewiseLinear([T/4, T/2, T/4], [0.0, omega, omega, 0.0])\nwf_det = Ramp(T, delta_i, delta_f)\n\ndrive = Drive(amplitude = wf_amp, detuning = wf_det)\n\n# Writing the quantum program\nprogram = QuantumProgram(register, drive)\n\nprogram.draw()\n</code></pre> 2025-07-29T14:50:51.246179 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/"},{"location":"tutorials/basic_qubo/#execution-and-visualization","title":"Execution and visualization","text":"<p>The program can now be executed. We pick the <code>AnalogDevice</code>, compile the program, and run it for a set number of samples.</p> <pre><code>from qoolqit import AnalogDevice, ResultType\n\nprogram.compile_to(device = AnalogDevice())\n\nresult = program.run(runs = 500, result_type = ResultType.BITSTRINGS)\n\ncounter = result[0]\n</code></pre> <pre><code>Counter({np.str_('01011'): 225, np.str_('00111'): 198, np.str_('00011'): 20, np.str_('00101'): 14, np.str_('10000'): 13, np.str_('10001'): 10, np.str_('00010'): 5, np.str_('10010'): 5, np.str_('01010'): 4, np.str_('00001'): 3, np.str_('01001'): 2, np.str_('01000'): 1})\n</code></pre> <p>And finally we plot a histogram of the sampled bitstrings.</p> <pre><code>import matplotlib.pyplot as plt\n\ndef plot_distribution(counter, solutions):\n    counter = dict(sorted(counter.items(), key=lambda item: item[1], reverse=True))\n    indexes = solutions.tolist()\n    color_dict = {key: \"r\" if key in indexes else \"g\" for key in counter}\n    fig, ax = plt.subplots(1, 1, figsize=(12, 6))\n    plt.figure(figsize=(12, 6))\n    ax.set_xlabel(\"Bitstrings\")\n    ax.set_ylabel(\"Counts\")\n    ax.bar(counter.keys(), counter.values(), width=0.5, color=color_dict.values())\n    return fig\n</code></pre> <pre><code>fig = plot_distribution(counter, marked_bitstrings)\n</code></pre> 2025-07-29T14:50:51.487495 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>As we can see, the bitstrings we had marked as the optimal solutions of this QUBO problem were the ones sampled with the highest probability, meaning the the QUBO problem was successfully solved with the quantum program we defined.</p>"},{"location":"tutorials/unit_conversion/","title":"Understanding unit conversions","text":"<p>In this tutorial we will exemplify how unit conversions play a role in the underlying QoolQit program compilation and execution. For that we will analyse the dynamics of one of the most fundamental algorithmic behaviours in the Rydberg analog model: the Rydberg blockade.</p>"},{"location":"tutorials/unit_conversion/#rydberg-blockade","title":"Rydberg blockade","text":"<p>Consider a system of two qubits in state \\(|00\\rangle\\), placed in two sites at a distance \\(r\\) at \\(t=0\\). For simplicity, we set the program drive as a constant amplitude waveform of value \\(\\Omega\\) for \\(t\\geq0\\). Following the Rydberg model page, the two qubit system evolves with the Hamiltonian</p> \\[ H_{01}=\\frac{\\Omega}{2}(\\hat{\\sigma}^x_0+\\hat{\\sigma}^x_1)+\\frac{1}{r^6}\\hat{n}_0\\hat{n}_1 \\] <p>The interaction term imposes an energy of \\(1/r^6\\) on state \\(|11\\rangle\\), and thus this state is only accessible if \\(\\Omega&gt;1/r^6\\). As such, the radius</p> \\[ r_b=\\Omega^{-\\frac{1}{6}} \\] <p>is called the Rydberg blockade radius, such that if two qubits are at a distance \\(r &lt; r_b\\), the state \\(|11\\rangle\\) is blocked, while if they are at a distance \\(r &gt; r_b\\), the state \\(|11\\rangle\\) is accessible.</p> <p>For simplicity we now set \\(\\Omega = 1\\), and thus \\(r_b = 1\\). If you solve the system analytically you will find that in the blockade regime the initial population of \\(|00\\rangle\\) transitions to \\(\\frac{1}{\\sqrt{2}}|01\\rangle+|10\\rangle\\) at \\(t=\\pi/\\sqrt{2}\\), while in the non-blockade regime the transition \\(|00\\rangle \\rightarrow |11\\rangle\\) is complete at \\(t=\\pi\\).</p> <p>Let's now write a simple program in QoolQit to demonstrate the behaviour described. We will create a program for the \\(r &lt; 1\\) regime (qubits are close), and one for the \\(r &gt; 1\\) (qubits are far), and start by defining the drive of the program with two different durations.</p> <pre><code>import numpy as np\nfrom qoolqit import Constant, Drive\n\nomega = 1.0\n\n# Defining the Drive for the close / far system\nduration_close = np.pi * np.sqrt(2.0)\nduration_far = np.pi\n\ndrive_close = Drive(amplitude = Constant(duration_close, omega))\ndrive_far = Drive(amplitude = Constant(duration_far, omega))\n</code></pre> <p>Now we create the two registers, and then instantiate the programs. We arbitrarily pick \\(r_\\text{close} = 0.7\\) and \\(r_\\text{far} = 1.5\\).</p> <pre><code>from qoolqit import Register, QuantumProgram\n\nr_close = 0.7\nr_far = 1.5\n\nreg_close = Register.from_coordinates([(0.0, 0.0), (r_close, 0.0)])\nreg_far = Register.from_coordinates([(0.0, 0.0), (r_far, 0.0)])\n\nprogram_close = QuantumProgram(reg_close, drive_close)\nprogram_far = QuantumProgram(reg_far, drive_far)\n</code></pre> <p>For executing the programs, we will do a statevector simulation of the dynamics and save 100 states during the duration of the program.</p> <pre><code>n_points = 100\n\nevaluation_times = np.linspace(0, 1.0, n_points).tolist()\n</code></pre>"},{"location":"tutorials/unit_conversion/#running-on-a-mock-device","title":"Running on a mock device","text":"<p>First, let's run the programs on a mock device and see what we get. We instantiate the device, compile both programs, and call the <code>run()</code> method. By default, this uses <code>ResultType.STATEVECTOR</code>, which is what we want here.</p> <pre><code>from qoolqit import MockDevice\n\ndevice = MockDevice()\n\nprogram_close.compile_to(device)\nprogram_far.compile_to(device)\n\nstates_close = program_close.run(evaluation_times = evaluation_times)\nstates_far = program_far.run(evaluation_times = evaluation_times)\n</code></pre> <p>With the states saved, we can plot the results. We do this by defining a plotting function so that we can reuse it later.</p> Click to inspect the plotting function <pre><code>import matplotlib.pyplot as plt\n\ndef get_figure(states_close: np.ndarray, states_far: np.ndarray) -&gt; plt.Figure:\n\n    # Compute the population\n    pop_close = abs(states_close.T)**2\n    pop_far = abs(states_far.T)**2\n\n    fig, ax = plt.subplots(1, 2, figsize=(8, 4), dpi=200)\n    t_vals = np.linspace(0, duration_close, n_points).tolist()\n    ax[0].grid(True, color=\"lightgray\", linestyle=\"--\", linewidth=0.7)\n    ax[0].plot(t_vals, pop_close[0], label = \"00\")\n    ax[0].plot(t_vals, pop_close[1], label = \"01\")\n    ax[0].plot(t_vals, pop_close[2], label = \"10\", linestyle = \"dashed\")\n    ax[0].plot(t_vals, pop_close[3], label = \"11\")\n    ax[0].set_ylabel(\"Population\")\n    ax[0].set_xlabel(\"Time t\")\n    ax[0].set_title(\"Blockade regime\")\n    ax[0].legend()\n\n    t_vals = np.linspace(0, duration_far, n_points).tolist()\n    ax[1].grid(True, color=\"lightgray\", linestyle=\"--\", linewidth=0.7)\n    ax[1].plot(t_vals, pop_far[0], label = \"00\")\n    ax[1].plot(t_vals, pop_far[1], label = \"01\")\n    ax[1].plot(t_vals, pop_far[2], label = \"10\", linestyle = \"dashed\")\n    ax[1].plot(t_vals, pop_far[3], label = \"11\")\n    ax[1].set_xlabel(\"Time t\")\n    ax[1].set_title(\"Non-blockade regime\")\n    ax[1].legend()\n\n    return fig\n</code></pre> <pre><code>fig = get_figure(states_close, states_far)\n</code></pre> 2025-07-29T14:50:52.026882 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>As you can see above, the results obtained are exactly what we expected from the model. Now we may check what was the Pulser sequence that was used under the hood, for example, for the blockaded regime.</p> <pre><code>program_close.draw(compiled = True)\n</code></pre> 2025-07-29T14:50:52.163270 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>This was the sequence created by the device's default unit converter. <pre><code>device.converter\n</code></pre> <pre><code>UnitConverter(time = 79.577, energy = 12.566, distance = 8.692)\n</code></pre> </p> <p>As described in the model page, unit conversion is done by multiplying the values in QoolQit by the conversion factors. You can double-check yourself that the values of \\(\\Omega\\) and duration for this sequence match the ones set in QoolQit multiplied by the factors in the converter.</p> <p>What if we wanted to set some custom conversion factors? Would it make a difference? Below we set the energy unit to \\(10.0\\), and check that the converter is updated.</p> <pre><code>device.set_energy_unit(10.0)\n\ndevice.converter\n</code></pre> <pre><code>UnitConverter(time = 100.000, energy = 10.000, distance = 9.030)\n</code></pre> <p>We can now recompile our programs to the updated device, run, and plot the results.</p> <pre><code>program_close.compile_to(device)\nprogram_far.compile_to(device)\n\nstates_close = program_close.run(evaluation_times = evaluation_times)\nstates_far = program_far.run(evaluation_times = evaluation_times)\n\nfig = get_figure(states_close, states_far)\n</code></pre> 2025-07-29T14:50:52.397671 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>As expected, the results are exactly the same. Our program did not change, and since we are running on a perfect device the conversion is exact, independently of the conversion factors used. Only the physical implementation of our program has changed.</p>"},{"location":"tutorials/unit_conversion/#running-on-a-realistic-device","title":"Running on a realistic device","text":"<p>Now, let's replicate this experiment for a more realistic device. Note that the workflow we will show now is for demonstration purposes, and is not the recommended one for the average QoolQit user.</p> <p>We can use the <code>AnalogDevice</code>, which unlike the <code>MockDevice</code>, has limitations on certain values that can be set. This is immediately clear if we try to compile the program as it is to the default settings of the <code>AnalogDevice</code>:</p> <pre><code>from qoolqit import AnalogDevice\n\ndevice = AnalogDevice()\n\ntry:\n    program_close.compile_to(device)\nexcept Exception as error:\n    print(error)\n\nprogram_far.compile_to(device)\n</code></pre> <pre><code>Failed to compile the sequence due to:\n\nThe minimal distance between atoms in this device (5 \u00b5m) is not respected (up to a precision of 1e-6 \u00b5m) for the pairs: [('0', '1')]\n</code></pre> <p>While the program setting the qubits far apart compiled without problems, the one with the qubits closer together did not, because the compiler tried to put atoms closer than the minimum physical distance allowed on this device. Such limitations can be checked at the level of QoolQit in the <code>specs</code> property of the devices:</p> <pre><code>device.specs\n</code></pre> <pre><code>{'max_duration': 75.39822368615503, 'max_amplitude': 1.0, 'max_detuning': 10.0, 'min_distance': 0.7809234915702248}\n</code></pre> <p>Note that the values shown are adimensional, meaning that they depend on the current unit converter that is set on the device. Since we tried setting the qubits at \\(r_\\text{close} = 0.7\\), this is lower than the minimum distance allowed on this device given the default converter.</p> <p>Changing the program would be an option to achieve the compilation. For example, instead of using \\(\\Omega = 1\\), we could set \\(\\Omega = 0.3\\), which in turn would increase the blockade radius. Then we could set \\(r_\\text{close} = 0.7r_b\\approx0.856\\) and \\(r_\\text{far} = 1.5r_b\\approx1.833\\), which would now match the device constrains, and we would observe the same blockade behaviour (albeit with the dynamics on a different time-scale, scaled as \\(t/\\Omega\\)).</p> <p>However, that would be a fundamentally different program, and the goal in this tutorial is to exemplify how a fixed program can be translated differently through unit conversions. So, instead, we are just going to compile our original program differently. Below we check the unit converter used, then make a small arbitrary increase to the distance unit, and check the updated converter.</p> <pre><code>print(device.converter)\n\ndevice.set_distance_unit(7.5)\n\nprint(device.converter)\n</code></pre> <pre><code>UnitConverter(time = 79.577, energy = 12.566, distance = 6.403)\nUnitConverter(time = 205.584, energy = 4.864, distance = 7.500)\n</code></pre> <p>Let's check the device specs again:</p> <pre><code>device.specs\n</code></pre> <pre><code>{'max_duration': 29.185197447901235, 'max_amplitude': 2.583440589043439, 'max_detuning': 25.83440589043439, 'min_distance': 0.6666666666666666}\n</code></pre> <p>With the updated converter the allowed minimum distance is smaller, and both programs should now compile. We can again plot the results:</p> <pre><code>program_close.compile_to(device)\nprogram_far.compile_to(device)\n\nstates_close = program_close.run(evaluation_times = evaluation_times)\nstates_far = program_far.run(evaluation_times = evaluation_times)\n\nfig = get_figure(states_close, states_far)\n</code></pre> 2025-07-29T14:50:52.672610 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>Once again, we get the expected results. However, notice that there is slight difference in the dynamics compared to the ideal case shown earlier, as both the start and end of the plots are more horizontal. Let's inspect the compiled sequence for one of the programs.</p> <pre><code>program_close.draw(compiled = True)\n</code></pre> 2025-07-29T14:50:52.813491 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>As you can see, in a realistic device you cannot implement a perfectly square waveform, as the system requires some time to raise and lower the amplitude of the laser that implements it. This is called the waveform modulation and in this case it introduces a discrepancy between the expected results in the ideal scenario and the actual results from the physical implementation.</p>"},{"location":"tutorials/unit_conversion/#using-compiler-profiles","title":"Using compiler profiles","text":"<p>At the start of the previous section it was noted that the workflow of manually changing the unit converter is not necessarily the recommended one, and should be reserved for more advanced users. At the same time, at the end of the section we saw that in this case the compilation was not ideal, because the program was slightly affected by waveform modulation errors.</p> <p>To address both of these issues, we can use compiler profiles. These are directives for the compiler to follow while trying to compile the sequence, which can be designed with various specific purposes in mind. Going in detail on compiler profiles in QoolQit is not the purpose of this tutorial, but here can exemplify the usage of one:</p> <pre><code>from qoolqit import AnalogDevice, CompilerProfile\n\ndevice = AnalogDevice()\n\nprogram_close.compile_to(device, profile = CompilerProfile.MAX_DURATION)\nprogram_far.compile_to(device, profile = CompilerProfile.MAX_DURATION)\n\nstates_close = program_close.run(evaluation_times = evaluation_times)\nstates_far = program_far.run(evaluation_times = evaluation_times)\n\nfig = get_figure(states_close, states_far)\n</code></pre> 2025-07-29T14:50:53.060934 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>The results are now much closer to the ideal case. Let's inspect the compiled sequence:</p> <pre><code>program_close.draw(compiled = True)\n</code></pre> 2025-07-29T14:50:53.216341 image/svg+xml Matplotlib v3.10.3, https://matplotlib.org/ <p>By using the <code>CompilerProfile.MAX_DURATION</code>, the compiler automatically mapped whatever was the program duration to be equal to the device's maximum duration. This was done by calculating the ideal conversions factors that match this condition, and using those. This not only allowed for a successful compilation of both programs, but it also mitigated the modulation errors by stretching the program over a longer time.</p> <p>Note</p> <p>In the future we can add a <code>safe_mode = True</code> to the compiler, where a profile is dynamically adjusted until it achieves a successful compilation.</p>"},{"location":"api/qoolqit/","title":"Reference","text":"qoolqit<p> source package qoolqit </p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> <li> <p>Drive \u2014 The drive Hamiltonian acting over a duration.</p> </li> <li> <p>MockDevice \u2014 An ideal device without constraints.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>TestAnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>AvailableDevices</p> </li> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> <li> <p>Register \u2014 The Register in QoolQit, representing a set of qubits with coordinates.</p> </li> <li> <p>QuantumProgram \u2014 A program representing a Sequence acting on a Register of qubits.</p> </li> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> <li> <p>CompilerProfile</p> </li> <li> <p>ResultType</p> </li> <li> <p>BackendName</p> </li> <li> <p>EmuMPSBackend \u2014 Emu-MPS backend.</p> </li> <li> <p>QutipBackend \u2014 Qutip backend.</p> </li> <li> <p>SpringLayoutEmbedder \u2014 A graph to graph embedder using the spring layout algorithm.</p> </li> <li> <p>InteractionEmbedder \u2014 A matrix to graph embedder using the interaction embedding algorithm.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>from_pyg \u2014 Create a graph from a pyg data object.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float, seed: int | None = None) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod DataGraph.from_pyg(data) \u2192 DataGraph </p> <p>Create a graph from a pyg data object.</p> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> source class Drive(*args: Any, amplitude: Waveform | None = None, detuning: Waveform | None = None, phase: float = 0.0) </p> <p>The drive Hamiltonian acting over a duration.</p> <p>Default constructor for the Drive.</p> <p>Must be instantiated with keyword arguments. Accepts either an amplitude waveform, a detuning waveform, or both. A phase value can also be passed.</p> <p> Parameters </p> <ul> <li> <p>amplitude :  Waveform | None \u2014 waveform representing \u03a9(t) in the drive Hamiltonian.</p> </li> <li> <p>detuning :  Waveform | None \u2014 waveform representing \u03b4(t) in the drive Hamiltonian.</p> </li> <li> <p>phase :  float \u2014 phase value \u0278 for the amplitude term.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>amplitude :  Waveform \u2014 The amplitude waveform in the drive.</p> </li> <li> <p>detuning :  Waveform \u2014 The detuning waveform in the drive.</p> </li> <li> <p>phase :  float \u2014 The phase value in the drive.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw</p> </li> </ul> <p> source property Drive.amplitude: Waveform </p> <p>The amplitude waveform in the drive.</p> <p> source property Drive.detuning: Waveform </p> <p>The detuning waveform in the drive.</p> <p> source property Drive.phase: float </p> <p>The phase value in the drive.</p> <p> source property Drive.duration: float </p> <p> source method Drive.draw(n_points: int = 500, return_fig: bool = False) \u2192 plt.Figure | None </p> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>An ideal device without constraints.</p> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source class TestAnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source enum AvailableDevices() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>MOCK</p> </li> <li> <p>ANALOG</p> </li> <li> <p>TEST_ANALOG</p> </li> </ul> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Delay(duration: float, *args: float, **kwargs: float) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p> <p> source class Register(qubits: dict) </p> <p>The Register in QoolQit, representing a set of qubits with coordinates.</p> <p>Default constructor for the Register.</p> <p> Parameters </p> <ul> <li> <p>qubits :  dict \u2014 a dictionary of qubits and respective coordinates {q: (x, y), ...}.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>qubits :  dict \u2014 Returns the dictionary of qubits and respective coordinates.</p> </li> <li> <p>n_qubits :  int \u2014 Number of qubits in the Register.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_graph \u2014 Initializes a Register from a graph that has coordinates.</p> </li> <li> <p>from_coordinates \u2014 Initializes a Register from a list of coordinates.</p> </li> <li> <p>distances \u2014 Distance between each qubit pair.</p> </li> <li> <p>min_distance \u2014 Minimum distance between all qubit pairs.</p> </li> <li> <p>interactions \u2014 Interaction 1/r^6 between each qubit pair.</p> </li> <li> <p>draw \u2014 Draw the register.</p> </li> </ul> <p> source classmethod Register.from_graph(graph: DataGraph) \u2192 Register </p> <p>Initializes a Register from a graph that has coordinates.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 a DataGraph instance.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod Register.from_coordinates(coords: list) \u2192 Register </p> <p>Initializes a Register from a list of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list \u2014 a list of coordinates [(x, y), ...]</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source property Register.qubits: dict </p> <p>Returns the dictionary of qubits and respective coordinates.</p> <p> source property Register.n_qubits: int </p> <p>Number of qubits in the Register.</p> <p> source method Register.distances() \u2192 dict </p> <p>Distance between each qubit pair.</p> <p> source method Register.min_distance() \u2192 float </p> <p>Minimum distance between all qubit pairs.</p> <p> source method Register.interactions() \u2192 dict </p> <p>Interaction 1/r^6 between each qubit pair.</p> <p> source method Register.draw(return_fig: bool = False) \u2192 plt.Figure | None </p> <p>Draw the register.</p> <p> Parameters </p> <ul> <li> <p>return_fig :  bool \u2014 boolean argument to return the plt.Figure instance.</p> </li> </ul> <p> source class QuantumProgram(register: Register, drive: Drive) </p> <p>A program representing a Sequence acting on a Register of qubits.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the Register of qubits.</p> </li> <li> <p>sequence \u2014 the Sequence of waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>register :  Register \u2014 The register of qubits.</p> </li> <li> <p>drive :  Drive \u2014 The driving waveforms.</p> </li> <li> <p>is_compiled :  bool \u2014 Check if the program has been compiled.</p> </li> <li> <p>compiled_sequence :  PulserSequence \u2014 The Pulser sequence compiled to a specific device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_to \u2014 Compiles the given program to a device.</p> </li> <li> <p>draw</p> </li> <li> <p>run \u2014 Run the compiled sequence on selected backend.</p> </li> </ul> <p> source property QuantumProgram.register: Register </p> <p>The register of qubits.</p> <p> source property QuantumProgram.drive: Drive </p> <p>The driving waveforms.</p> <p> source property QuantumProgram.is_compiled: bool </p> <p>Check if the program has been compiled.</p> <p> source property QuantumProgram.compiled_sequence: PulserSequence </p> <p>The Pulser sequence compiled to a specific device.</p> <p> source method QuantumProgram.compile_to(device: Device, profile: CompilerProfile = CompilerProfile.DEFAULT) \u2192 None </p> <p>Compiles the given program to a device.</p> <p> Parameters </p> <ul> <li> <p>device :  Device \u2014 the Device to compile to.</p> </li> <li> <p>profile :  CompilerProfile \u2014 the compiler profile to use during compilation.</p> </li> </ul> <p> source method QuantumProgram.draw(n_points: int = 500, compiled: bool = False, return_fig: bool = False) \u2192 plt.Figure | None </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source method QuantumProgram.run(backend_name: BackendName = BackendName.QUTIP, result_type: ResultType = ResultType.STATEVECTOR, runs: int = 100, evaluation_times: list[float] = [1.0], **backend_params: Any) \u2192 OutputType </p> <p>Run the compiled sequence on selected backend.</p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> <li> <p>CompilationError</p> </li> </ul> <p> source enum CompilerProfile() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul> <p> source enum ResultType() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>BITSTRINGS</p> </li> <li> <p>STATEVECTOR</p> </li> </ul> <p> source enum BackendName() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>QUTIP</p> </li> <li> <p>EMUMPS</p> </li> </ul> <p> source class EmuMPSBackend(seq: PulserSequence, result_type: ResultType = ResultType.STATEVECTOR, **backend_params: Any) </p> <p>Bases : BaseBackend</p> <p>Emu-MPS backend.</p> <p> Methods </p> <ul> <li> <p>contract_mps \u2014 Contract a MPS state into a full state vector.</p> </li> <li> <p>run</p> </li> </ul> <p> source method EmuMPSBackend.contract_mps(mps_state: emu_mps.MPS) \u2192 torch.Tensor </p> <p>Contract a MPS state into a full state vector.</p> <p> Parameters </p> <ul> <li> <p>mps_state :  MPS \u2014 MPS state to contract</p> </li> </ul> <p> Returns </p> <ul> <li> <p>torch.Tensor \u2014 A flattened torch.Tensor representing the state vector.</p> </li> </ul> <p> source method EmuMPSBackend.run(runs: int = 100, evaluation_times: list[float] = [1.0]) \u2192 OutputType </p> <p> source class QutipBackend(seq: PulserSequence, result_type: ResultType = ResultType.STATEVECTOR, **backend_params: Any) </p> <p>Bases : BaseBackend</p> <p>Qutip backend.</p> <p> Methods </p> <ul> <li> <p>run</p> </li> </ul> <p> source method QutipBackend.run(runs: int = 100, evaluation_times: list[float] = [1.0]) \u2192 OutputType </p> <p> source class SpringLayoutEmbedder() </p> <p>Bases : GraphToGraphEmbedder[SpringLayoutConfig]</p> <p>A graph to graph embedder using the spring layout algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source class InteractionEmbedder() </p> <p>Bases : MatrixToGraphEmbedder[InteractionEmbeddingConfig]</p> <p>A matrix to graph embedder using the interaction embedding algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul>"},{"location":"api/qoolqit/devices/","title":"qoolqit.devices","text":"qoolqit.devices<p> source package qoolqit.devices </p> <p> Classes </p> <ul> <li> <p>MockDevice \u2014 An ideal device without constraints.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>TestAnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>AvailableDevices</p> </li> <li> <p>Device \u2014 Abstract base class for a Device in QoolQit.</p> </li> <li> <p>UnitConverter \u2014 A dataclass representing a unit converter in the Rydberg-Analog model.</p> </li> </ul> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>An ideal device without constraints.</p> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source class TestAnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source enum AvailableDevices() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>MOCK</p> </li> <li> <p>ANALOG</p> </li> <li> <p>TEST_ANALOG</p> </li> </ul> <p> source class Device() </p> <p>Bases : ABC</p> <p>Abstract base class for a Device in QoolQit.</p> <p>The device in QoolQit holds a Pulser device, and all the logic is based on that. Defining a new device for usage in QoolQit should be done by inheriting from this base class and overriding the <code>_device</code> private property with the corresponding Pulser device.</p> <p> Methods </p> <ul> <li> <p>reset_converter \u2014 Resets the unit converter to the default one.</p> </li> <li> <p>set_time_unit \u2014 Changes the unit converter according to a reference time unit.</p> </li> <li> <p>set_energy_unit \u2014 Changes the unit converter according to a reference energy unit.</p> </li> <li> <p>set_distance_unit \u2014 Changes the unit converter according to a reference distance unit.</p> </li> </ul> <p> source property Device.specs: dict </p> <p> source property Device.name: str </p> <p> source property Device.converter: UnitConverter </p> <p> source method Device.reset_converter() \u2192 None </p> <p>Resets the unit converter to the default one.</p> <p> source method Device.set_time_unit(time: float) \u2192 None </p> <p>Changes the unit converter according to a reference time unit.</p> <p> source method Device.set_energy_unit(energy: float) \u2192 None </p> <p>Changes the unit converter according to a reference energy unit.</p> <p> source method Device.set_distance_unit(distance: float) \u2192 None </p> <p>Changes the unit converter according to a reference distance unit.</p> <p> source dataclass UnitConverter(C6: float = field(repr=False), time: float, energy: float, distance: float) </p> <p>A dataclass representing a unit converter in the Rydberg-Analog model.</p> <p>Includes three inter-dependent factors for TIME, ENERGY and DISTANCE conversion, also depending on the interaction coeffiecient C6. The converter checks the following invariants, based on the units used by Pulser:</p> <p> Conversion invariants </p> <ol> <li>TIME * ENERGY = 1000 ( &lt;=&gt; TIME = 1000 / ENERGY )</li> <li>DISTANCE^6 * ENERGY = C6 ( &lt;=&gt; ENERGY = C6 / (DISTANCE ^ 6) )</li> </ol> <p> Attributes </p> <ul> <li> <p>C6 :  float \u2014 Time conversion factor.</p> </li> <li> <p>time :  float \u2014 Energy conversion factor.</p> </li> <li> <p>energy :  float \u2014 Distance conversion factor.</p> </li> <li> <p>factors :  tuple[float, ...] \u2014 Return the current conversion factors set.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_factors \u2014 Returns True if the conversion invariants are respected.</p> </li> <li> <p>from_time \u2014 Instantiate from a reference C6 value and a reference time unit.</p> </li> <li> <p>from_energy \u2014 Instantiate from a reference C6 value and a reference energy unit.</p> </li> <li> <p>from_distance \u2014 Instantiate from a reference C6 value and a reference distance unit.</p> </li> <li> <p>factors_from_time \u2014 Get factors from a different reference time than the one set.</p> </li> <li> <p>factors_from_energy \u2014 Get factors from a different reference energy than the one set.</p> </li> <li> <p>factors_from_distance \u2014 Get factors from a different reference distance than the one set.</p> </li> </ul> <p> source method UnitConverter.validate_factors(time: float, energy: float, distance: float) \u2192 bool </p> <p>Returns True if the conversion invariants are respected.</p> <p> source classmethod UnitConverter.from_time(C6: float, time: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference time unit.</p> <p> source classmethod UnitConverter.from_energy(C6: float, energy: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference energy unit.</p> <p> source classmethod UnitConverter.from_distance(C6: float, distance: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference distance unit.</p> <p> source property UnitConverter.factors: tuple[float, ...] </p> <p>Return the current conversion factors set.</p> <p> source method UnitConverter.factors_from_time(time: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference time than the one set.</p> <p> source method UnitConverter.factors_from_energy(energy: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference energy than the one set.</p> <p> source method UnitConverter.factors_from_distance(distance: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference distance than the one set.</p>"},{"location":"api/qoolqit/devices/device/","title":"qoolqit.devices.device","text":"qoolqit.devices.device<p> source module qoolqit.devices.device </p> <p> Classes </p> <ul> <li> <p>Device \u2014 Abstract base class for a Device in QoolQit.</p> </li> <li> <p>MockDevice \u2014 An ideal device without constraints.</p> </li> <li> <p>AnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> <li> <p>TestAnalogDevice \u2014 A realistic device with constraints mimicking a real QPU.</p> </li> </ul> <p> source class Device() </p> <p>Bases : ABC</p> <p>Abstract base class for a Device in QoolQit.</p> <p>The device in QoolQit holds a Pulser device, and all the logic is based on that. Defining a new device for usage in QoolQit should be done by inheriting from this base class and overriding the <code>_device</code> private property with the corresponding Pulser device.</p> <p> Methods </p> <ul> <li> <p>reset_converter \u2014 Resets the unit converter to the default one.</p> </li> <li> <p>set_time_unit \u2014 Changes the unit converter according to a reference time unit.</p> </li> <li> <p>set_energy_unit \u2014 Changes the unit converter according to a reference energy unit.</p> </li> <li> <p>set_distance_unit \u2014 Changes the unit converter according to a reference distance unit.</p> </li> </ul> <p> source property Device.specs: dict </p> <p> source property Device.name: str </p> <p> source property Device.converter: UnitConverter </p> <p> source method Device.reset_converter() \u2192 None </p> <p>Resets the unit converter to the default one.</p> <p> source method Device.set_time_unit(time: float) \u2192 None </p> <p>Changes the unit converter according to a reference time unit.</p> <p> source method Device.set_energy_unit(energy: float) \u2192 None </p> <p>Changes the unit converter according to a reference energy unit.</p> <p> source method Device.set_distance_unit(distance: float) \u2192 None </p> <p>Changes the unit converter according to a reference distance unit.</p> <p> source class MockDevice() </p> <p>Bases : Device</p> <p>An ideal device without constraints.</p> <p> source class AnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p> <p> source class TestAnalogDevice() </p> <p>Bases : Device</p> <p>A realistic device with constraints mimicking a real QPU.</p>"},{"location":"api/qoolqit/devices/unit_converter/","title":"qoolqit.devices.unit_converter","text":"qoolqit.devices.unit_converter<p> source module qoolqit.devices.unit_converter </p> <p> Classes </p> <ul> <li> <p>UnitConverter \u2014 A dataclass representing a unit converter in the Rydberg-Analog model.</p> </li> </ul> <p> source dataclass UnitConverter(C6: float = field(repr=False), time: float, energy: float, distance: float) </p> <p>A dataclass representing a unit converter in the Rydberg-Analog model.</p> <p>Includes three inter-dependent factors for TIME, ENERGY and DISTANCE conversion, also depending on the interaction coeffiecient C6. The converter checks the following invariants, based on the units used by Pulser:</p> <p> Conversion invariants </p> <ol> <li>TIME * ENERGY = 1000 ( &lt;=&gt; TIME = 1000 / ENERGY )</li> <li>DISTANCE^6 * ENERGY = C6 ( &lt;=&gt; ENERGY = C6 / (DISTANCE ^ 6) )</li> </ol> <p> Attributes </p> <ul> <li> <p>C6 :  float \u2014 Time conversion factor.</p> </li> <li> <p>time :  float \u2014 Energy conversion factor.</p> </li> <li> <p>energy :  float \u2014 Distance conversion factor.</p> </li> <li> <p>factors :  tuple[float, ...] \u2014 Return the current conversion factors set.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_factors \u2014 Returns True if the conversion invariants are respected.</p> </li> <li> <p>from_time \u2014 Instantiate from a reference C6 value and a reference time unit.</p> </li> <li> <p>from_energy \u2014 Instantiate from a reference C6 value and a reference energy unit.</p> </li> <li> <p>from_distance \u2014 Instantiate from a reference C6 value and a reference distance unit.</p> </li> <li> <p>factors_from_time \u2014 Get factors from a different reference time than the one set.</p> </li> <li> <p>factors_from_energy \u2014 Get factors from a different reference energy than the one set.</p> </li> <li> <p>factors_from_distance \u2014 Get factors from a different reference distance than the one set.</p> </li> </ul> <p> source method UnitConverter.validate_factors(time: float, energy: float, distance: float) \u2192 bool </p> <p>Returns True if the conversion invariants are respected.</p> <p> source classmethod UnitConverter.from_time(C6: float, time: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference time unit.</p> <p> source classmethod UnitConverter.from_energy(C6: float, energy: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference energy unit.</p> <p> source classmethod UnitConverter.from_distance(C6: float, distance: float) \u2192 UnitConverter </p> <p>Instantiate from a reference C6 value and a reference distance unit.</p> <p> source property UnitConverter.factors: tuple[float, ...] </p> <p>Return the current conversion factors set.</p> <p> source method UnitConverter.factors_from_time(time: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference time than the one set.</p> <p> source method UnitConverter.factors_from_energy(energy: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference energy than the one set.</p> <p> source method UnitConverter.factors_from_distance(distance: float) \u2192 tuple[float, ...] </p> <p>Get factors from a different reference distance than the one set.</p>"},{"location":"api/qoolqit/devices/utils/","title":"qoolqit.devices.utils","text":"qoolqit.devices.utils<p> source module qoolqit.devices.utils </p> <p> Classes </p> <ul> <li> <p>AvailableDevices</p> </li> </ul> <p> source enum AvailableDevices() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>MOCK</p> </li> <li> <p>ANALOG</p> </li> <li> <p>TEST_ANALOG</p> </li> </ul>"},{"location":"api/qoolqit/embedding/","title":"qoolqit.embedding","text":"qoolqit.embedding<p> source package qoolqit.embedding </p> <p> Classes </p> <ul> <li> <p>SpringLayoutEmbedder \u2014 A graph to graph embedder using the spring layout algorithm.</p> </li> <li> <p>InteractionEmbedder \u2014 A matrix to graph embedder using the interaction embedding algorithm.</p> </li> <li> <p>InteractionEmbeddingConfig \u2014 Configuration parameters for the interaction embedding.</p> </li> <li> <p>SpringLayoutConfig \u2014 Configuration parameters for the spring-layout embedding.</p> </li> <li> <p>BaseEmbedder \u2014 Abstract base class for all embedders.</p> </li> <li> <p>EmbeddingConfig \u2014 Base abstract dataclass for all embedding algorithm configurations.</p> </li> <li> <p>GraphToGraphEmbedder \u2014 A family of embedders that map a graph to a graph.</p> </li> <li> <p>MatrixToGraphEmbedder \u2014 A family of embedders that map a matrix to a graph.</p> </li> </ul> <p> source class SpringLayoutEmbedder() </p> <p>Bases : GraphToGraphEmbedder[SpringLayoutConfig]</p> <p>A graph to graph embedder using the spring layout algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source class InteractionEmbedder() </p> <p>Bases : MatrixToGraphEmbedder[InteractionEmbeddingConfig]</p> <p>A matrix to graph embedder using the interaction embedding algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> source dataclass InteractionEmbeddingConfig(method: str = 'Nelder-Mead', maxiter: int = 200000, tol: float = 1e-08) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the interaction embedding.</p> <p> source dataclass SpringLayoutConfig(k: float | None = None, iterations: int = 50, threshold: float = 0.0001, seed: int | None = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the spring-layout embedding.</p> <p> source class BaseEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : ABC, Generic[InDataType, OutDataType, ConfigType]</p> <p>Abstract base class for all embedders.</p> <p>An embedder is a function that maps a InDataType to an OutDataType through an embedding algorithm. Parameters of the embedding algorithm can be customized through the EmbeddingConfig.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input \u2014 Checks if the given data is compatible with the embedder.</p> </li> <li> <p>validate_output \u2014 Checks if the resulting output is expected by the embedder.</p> </li> <li> <p>embed \u2014 Validates the input, runs the embedding algorithm, and validates the output.</p> </li> </ul> <p> source property BaseEmbedder.config: ConfigType </p> <p>Returns the config for the embedding algorithm.</p> <p> source property BaseEmbedder.algorithm: Callable </p> <p>Returns the callable to the embedding algorithm.</p> <p> source property BaseEmbedder.info: str </p> <p>Prints info about the embedding algorithm.</p> <p> source method BaseEmbedder.validate_input(data: InDataType) \u2192 None </p> <p>Checks if the given data is compatible with the embedder.</p> <p>Each embedder should write its own data validator. If the data is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the data is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.validate_output(result: OutDataType) \u2192 None </p> <p>Checks if the resulting output is expected by the embedder.</p> <p>Each embedder should write its own output validator. If the result is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>result :  OutDataType \u2014 the output to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the output is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.embed(data: InDataType) \u2192 OutDataType </p> <p>Validates the input, runs the embedding algorithm, and validates the output.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to embed.</p> </li> </ul> <p> source dataclass EmbeddingConfig() </p> <p>Bases : ABC</p> <p>Base abstract dataclass for all embedding algorithm configurations.</p> <p>Subclasses define parameters specific to their algorithms. Each config should define fields that directly translate to arguments in the respective embedding function it configurates.</p> <p> Methods </p> <ul> <li> <p>dict \u2014 Returns the dataclass as a dictionary.</p> </li> </ul> <p> source method EmbeddingConfig.dict() \u2192 dict </p> <p>Returns the dataclass as a dictionary.</p> <p> source class GraphToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[DataGraph, DataGraph, ConfigType]</p> <p>A family of embedders that map a graph to a graph.</p> <p>Focused on unit-disk graph embedding, where the goal is to find a set of coordinates for a graph that has no coordinates, such that the final unit-disk edges matches the set of edges in the original graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_input(data: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source class MatrixToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[np.ndarray, DataGraph, ConfigType]</p> <p>A family of embedders that map a matrix to a graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_input(data: np.ndarray) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul>"},{"location":"api/qoolqit/embedding/algorithms/","title":"qoolqit.embedding.algorithms","text":"qoolqit.embedding.algorithms<p> source package qoolqit.embedding.algorithms </p> <p> Classes </p> <ul> <li> <p>InteractionEmbeddingConfig \u2014 Configuration parameters for the interaction embedding.</p> </li> <li> <p>SpringLayoutConfig \u2014 Configuration parameters for the spring-layout embedding.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>interaction_embedding \u2014 Matrix embedding into the interaction term of the Rydberg Analog Model.</p> </li> <li> <p>spring_layout_embedding \u2014 Force-directed embedding, wrapping nx.spring_layout.</p> </li> </ul> <p> source dataclass InteractionEmbeddingConfig(method: str = 'Nelder-Mead', maxiter: int = 200000, tol: float = 1e-08) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the interaction embedding.</p> <p> source interaction_embedding(matrix: np.ndarray, method: str, maxiter: int, tol: float) \u2192 np.ndarray </p> <p>Matrix embedding into the interaction term of the Rydberg Analog Model.</p> <p>Uses scipy.minimize to find the optimal set of node coordinates such that the matrix of values 1/(r_ij)^6 approximate the off-diagonal terms of the input matrix.</p> <p>Check scipy.minimize documentation for more information on each parameter.</p> <p> Parameters </p> <ul> <li> <p>matrix :  np.ndarray \u2014 the matrix to embed.</p> </li> <li> <p>method :  str \u2014 the method used by scipy.minimize.</p> </li> <li> <p>maxiter :  int \u2014 maximum number of iterations.</p> </li> <li> <p>tol :  float \u2014 tolerance for termination.</p> </li> </ul> <p> source dataclass SpringLayoutConfig(k: float | None = None, iterations: int = 50, threshold: float = 0.0001, seed: int | None = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the spring-layout embedding.</p> <p> source spring_layout_embedding(graph: DataGraph, k: float | None, iterations: int, threshold: float, seed: int | None) \u2192 DataGraph </p> <p>Force-directed embedding, wrapping nx.spring_layout.</p> <p>Generates a graph with the same nodes and edges as the original graph, but with node coordinates set to be the positions given by nx.spring_layout.</p> <p>Check the documentation for nx.spring_layout for more information on each parameter.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 the graph to embed.</p> </li> <li> <p>k :  float | None \u2014 optimal distance between nodes.</p> </li> <li> <p>iterations :  int \u2014 maximum number of iterations to take.</p> </li> <li> <p>threshold :  float \u2014 threshold value for relative error in node position changes.</p> </li> <li> <p>sed \u2014 random seed.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/algorithms/interaction_embedding/","title":"qoolqit.embedding.algorithms.interaction_embedding","text":"qoolqit.embedding.algorithms.interaction_embedding<p> source module qoolqit.embedding.algorithms.interaction_embedding </p> <p> Classes </p> <ul> <li> <p>InteractionEmbeddingConfig \u2014 Configuration parameters for the interaction embedding.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>interaction_embedding \u2014 Matrix embedding into the interaction term of the Rydberg Analog Model.</p> </li> </ul> <p> source dataclass InteractionEmbeddingConfig(method: str = 'Nelder-Mead', maxiter: int = 200000, tol: float = 1e-08) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the interaction embedding.</p> <p> source interaction_embedding(matrix: np.ndarray, method: str, maxiter: int, tol: float) \u2192 np.ndarray </p> <p>Matrix embedding into the interaction term of the Rydberg Analog Model.</p> <p>Uses scipy.minimize to find the optimal set of node coordinates such that the matrix of values 1/(r_ij)^6 approximate the off-diagonal terms of the input matrix.</p> <p>Check scipy.minimize documentation for more information on each parameter.</p> <p> Parameters </p> <ul> <li> <p>matrix :  np.ndarray \u2014 the matrix to embed.</p> </li> <li> <p>method :  str \u2014 the method used by scipy.minimize.</p> </li> <li> <p>maxiter :  int \u2014 maximum number of iterations.</p> </li> <li> <p>tol :  float \u2014 tolerance for termination.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/algorithms/spring_layout_embedding/","title":"qoolqit.embedding.algorithms.spring_layout_embedding","text":"qoolqit.embedding.algorithms.spring_layout_embedding<p> source module qoolqit.embedding.algorithms.spring_layout_embedding </p> <p> Classes </p> <ul> <li> <p>SpringLayoutConfig \u2014 Configuration parameters for the spring-layout embedding.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>spring_layout_embedding \u2014 Force-directed embedding, wrapping nx.spring_layout.</p> </li> </ul> <p> source dataclass SpringLayoutConfig(k: float | None = None, iterations: int = 50, threshold: float = 0.0001, seed: int | None = None) </p> <p>Bases : EmbeddingConfig</p> <p>Configuration parameters for the spring-layout embedding.</p> <p> source spring_layout_embedding(graph: DataGraph, k: float | None, iterations: int, threshold: float, seed: int | None) \u2192 DataGraph </p> <p>Force-directed embedding, wrapping nx.spring_layout.</p> <p>Generates a graph with the same nodes and edges as the original graph, but with node coordinates set to be the positions given by nx.spring_layout.</p> <p>Check the documentation for nx.spring_layout for more information on each parameter.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 the graph to embed.</p> </li> <li> <p>k :  float | None \u2014 optimal distance between nodes.</p> </li> <li> <p>iterations :  int \u2014 maximum number of iterations to take.</p> </li> <li> <p>threshold :  float \u2014 threshold value for relative error in node position changes.</p> </li> <li> <p>sed \u2014 random seed.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/base_embedder/","title":"qoolqit.embedding.base_embedder","text":"qoolqit.embedding.base_embedder<p> source module qoolqit.embedding.base_embedder </p> <p> Classes </p> <ul> <li> <p>EmbeddingConfig \u2014 Base abstract dataclass for all embedding algorithm configurations.</p> </li> <li> <p>BaseEmbedder \u2014 Abstract base class for all embedders.</p> </li> </ul> <p> source dataclass EmbeddingConfig() </p> <p>Bases : ABC</p> <p>Base abstract dataclass for all embedding algorithm configurations.</p> <p>Subclasses define parameters specific to their algorithms. Each config should define fields that directly translate to arguments in the respective embedding function it configurates.</p> <p> Methods </p> <ul> <li> <p>dict \u2014 Returns the dataclass as a dictionary.</p> </li> </ul> <p> source method EmbeddingConfig.dict() \u2192 dict </p> <p>Returns the dataclass as a dictionary.</p> <p> source class BaseEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : ABC, Generic[InDataType, OutDataType, ConfigType]</p> <p>Abstract base class for all embedders.</p> <p>An embedder is a function that maps a InDataType to an OutDataType through an embedding algorithm. Parameters of the embedding algorithm can be customized through the EmbeddingConfig.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input \u2014 Checks if the given data is compatible with the embedder.</p> </li> <li> <p>validate_output \u2014 Checks if the resulting output is expected by the embedder.</p> </li> <li> <p>embed \u2014 Validates the input, runs the embedding algorithm, and validates the output.</p> </li> </ul> <p> source property BaseEmbedder.config: ConfigType </p> <p>Returns the config for the embedding algorithm.</p> <p> source property BaseEmbedder.algorithm: Callable </p> <p>Returns the callable to the embedding algorithm.</p> <p> source property BaseEmbedder.info: str </p> <p>Prints info about the embedding algorithm.</p> <p> source method BaseEmbedder.validate_input(data: InDataType) \u2192 None </p> <p>Checks if the given data is compatible with the embedder.</p> <p>Each embedder should write its own data validator. If the data is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the data is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.validate_output(result: OutDataType) \u2192 None </p> <p>Checks if the resulting output is expected by the embedder.</p> <p>Each embedder should write its own output validator. If the result is not of the supported type or in the specific supported format for that embedder, an error should be raised.</p> <p> Parameters </p> <ul> <li> <p>result :  OutDataType \u2014 the output to validate.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError \u2014 if the output is not of the supported type.</p> </li> <li> <p>SomeError \u2014 some other error if other constraints are not met.</p> </li> </ul> <p> source method BaseEmbedder.embed(data: InDataType) \u2192 OutDataType </p> <p>Validates the input, runs the embedding algorithm, and validates the output.</p> <p> Parameters </p> <ul> <li> <p>data :  InDataType \u2014 the data to embed.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/graph_embedder/","title":"qoolqit.embedding.graph_embedder","text":"qoolqit.embedding.graph_embedder<p> source module qoolqit.embedding.graph_embedder </p> <p> Classes </p> <ul> <li> <p>GraphToGraphEmbedder \u2014 A family of embedders that map a graph to a graph.</p> </li> <li> <p>SpringLayoutEmbedder \u2014 A graph to graph embedder using the spring layout algorithm.</p> </li> </ul> <p> source class GraphToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[DataGraph, DataGraph, ConfigType]</p> <p>A family of embedders that map a graph to a graph.</p> <p>Focused on unit-disk graph embedding, where the goal is to find a set of coordinates for a graph that has no coordinates, such that the final unit-disk edges matches the set of edges in the original graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_input(data: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source method GraphToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source class SpringLayoutEmbedder() </p> <p>Bases : GraphToGraphEmbedder[SpringLayoutConfig]</p> <p>A graph to graph embedder using the spring layout algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul>"},{"location":"api/qoolqit/embedding/matrix_embedder/","title":"qoolqit.embedding.matrix_embedder","text":"qoolqit.embedding.matrix_embedder<p> source module qoolqit.embedding.matrix_embedder </p> <p> Classes </p> <ul> <li> <p>MatrixToGraphEmbedder \u2014 A family of embedders that map a matrix to a graph.</p> </li> <li> <p>InteractionEmbedder \u2014 A matrix to graph embedder using the interaction embedding algorithm.</p> </li> </ul> <p> source class MatrixToGraphEmbedder(algorithm: Callable, config: ConfigType) </p> <p>Bases : BaseEmbedder[np.ndarray, DataGraph, ConfigType]</p> <p>A family of embedders that map a matrix to a graph.</p> <p>A custom algorithm and configuration can be set at initialization.</p> <p>Default initializer for all embedders, taking an algorithm and a config.</p> <p>An algorithm should be a standalone function that takes a piece of data of an InDataType and maps it to an OutDataType. Any extra configuration parameters taken as input by the algorithm function should be defined in the config dataclass, inheriting from EmbeddingConfig.</p> <p> Parameters </p> <ul> <li> <p>algorithm :  Callable \u2014 a callable to the algorithm function.</p> </li> <li> <p>config :  ConfigType \u2014 a config dataclass holding parameter values for the algorithm.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>validate_input</p> </li> <li> <p>validate_output</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_input(data: np.ndarray) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method MatrixToGraphEmbedder.validate_output(result: DataGraph) \u2192 None </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source class InteractionEmbedder() </p> <p>Bases : MatrixToGraphEmbedder[InteractionEmbeddingConfig]</p> <p>A matrix to graph embedder using the interaction embedding algorithm.</p> <p> Attributes </p> <ul> <li> <p>config :  ConfigType \u2014 Returns the config for the embedding algorithm.</p> </li> <li> <p>algorithm :  Callable \u2014 Returns the callable to the embedding algorithm.</p> </li> <li> <p>info :  str \u2014 Prints info about the embedding algorithm.</p> </li> </ul>"},{"location":"api/qoolqit/execution/","title":"qoolqit.execution","text":"qoolqit.execution<p> source package qoolqit.execution </p> <p> Classes </p> <ul> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> <li> <p>CompilerProfile</p> </li> <li> <p>ResultType</p> </li> <li> <p>BackendName</p> </li> <li> <p>EmuMPSBackend \u2014 Emu-MPS backend.</p> </li> <li> <p>QutipBackend \u2014 Qutip backend.</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> <li> <p>CompilationError</p> </li> </ul> <p> source enum CompilerProfile() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul> <p> source enum ResultType() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>BITSTRINGS</p> </li> <li> <p>STATEVECTOR</p> </li> </ul> <p> source enum BackendName() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>QUTIP</p> </li> <li> <p>EMUMPS</p> </li> </ul> <p> source class EmuMPSBackend(seq: PulserSequence, result_type: ResultType = ResultType.STATEVECTOR, **backend_params: Any) </p> <p>Bases : BaseBackend</p> <p>Emu-MPS backend.</p> <p> Methods </p> <ul> <li> <p>contract_mps \u2014 Contract a MPS state into a full state vector.</p> </li> <li> <p>run</p> </li> </ul> <p> source method EmuMPSBackend.contract_mps(mps_state: emu_mps.MPS) \u2192 torch.Tensor </p> <p>Contract a MPS state into a full state vector.</p> <p> Parameters </p> <ul> <li> <p>mps_state :  MPS \u2014 MPS state to contract</p> </li> </ul> <p> Returns </p> <ul> <li> <p>torch.Tensor \u2014 A flattened torch.Tensor representing the state vector.</p> </li> </ul> <p> source method EmuMPSBackend.run(runs: int = 100, evaluation_times: list[float] = [1.0]) \u2192 OutputType </p> <p> source class QutipBackend(seq: PulserSequence, result_type: ResultType = ResultType.STATEVECTOR, **backend_params: Any) </p> <p>Bases : BaseBackend</p> <p>Qutip backend.</p> <p> Methods </p> <ul> <li> <p>run</p> </li> </ul> <p> source method QutipBackend.run(runs: int = 100, evaluation_times: list[float] = [1.0]) \u2192 OutputType </p>"},{"location":"api/qoolqit/execution/backend/","title":"qoolqit.execution.backend","text":"qoolqit.execution.backend<p> source module qoolqit.execution.backend </p> <p> Classes </p> <ul> <li> <p>BaseBackend</p> </li> <li> <p>EmuMPSBackend \u2014 Emu-MPS backend.</p> </li> <li> <p>QutipBackend \u2014 Qutip backend.</p> </li> </ul> <p> source class BaseBackend(seq: PulserSequence, name: BackendName = BackendName.QUTIP, result_type: ResultType = ResultType.STATEVECTOR, **backend_params: Any) </p> <p>Bases : ABC</p> <p> Methods </p> <ul> <li> <p>build_config</p> </li> <li> <p>build_backend</p> </li> <li> <p>run</p> </li> </ul> <p> source method BaseBackend.build_config(runs: int = 100, evaluation_times: list[float] = [1.0]) \u2192 None </p> <p> source method BaseBackend.build_backend() \u2192 None </p> <p> source method BaseBackend.run() \u2192 Any </p> <p> source class EmuMPSBackend(seq: PulserSequence, result_type: ResultType = ResultType.STATEVECTOR, **backend_params: Any) </p> <p>Bases : BaseBackend</p> <p>Emu-MPS backend.</p> <p> Methods </p> <ul> <li> <p>contract_mps \u2014 Contract a MPS state into a full state vector.</p> </li> <li> <p>run</p> </li> </ul> <p> source method EmuMPSBackend.contract_mps(mps_state: emu_mps.MPS) \u2192 torch.Tensor </p> <p>Contract a MPS state into a full state vector.</p> <p> Parameters </p> <ul> <li> <p>mps_state :  MPS \u2014 MPS state to contract</p> </li> </ul> <p> Returns </p> <ul> <li> <p>torch.Tensor \u2014 A flattened torch.Tensor representing the state vector.</p> </li> </ul> <p> source method EmuMPSBackend.run(runs: int = 100, evaluation_times: list[float] = [1.0]) \u2192 OutputType </p> <p> source class QutipBackend(seq: PulserSequence, result_type: ResultType = ResultType.STATEVECTOR, **backend_params: Any) </p> <p>Bases : BaseBackend</p> <p>Qutip backend.</p> <p> Methods </p> <ul> <li> <p>run</p> </li> </ul> <p> source method QutipBackend.run(runs: int = 100, evaluation_times: list[float] = [1.0]) \u2192 OutputType </p>"},{"location":"api/qoolqit/execution/compilation_functions/","title":"qoolqit.execution.compilation_functions","text":"qoolqit.execution.compilation_functions<p> source module qoolqit.execution.compilation_functions </p> <p> Functions </p> <ul> <li> <p>basic_compilation</p> </li> </ul> <p> source basic_compilation(register: Register, drive: Drive, device: Device, profile: CompilerProfile) \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul>"},{"location":"api/qoolqit/execution/sequence_compiler/","title":"qoolqit.execution.sequence_compiler","text":"qoolqit.execution.sequence_compiler<p> source module qoolqit.execution.sequence_compiler </p> <p> Classes </p> <ul> <li> <p>SequenceCompiler \u2014 Compiles a QoolQit Register and Drive to a Device.</p> </li> </ul> <p> source class SequenceCompiler(register: Register, drive: Drive, device: Device) </p> <p>Compiles a QoolQit Register and Drive to a Device.</p> <p>Initializes the compiler.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the QoolQit Register.</p> </li> <li> <p>drive :  Drive \u2014 the QoolQit Drive.</p> </li> <li> <p>device :  Device \u2014 the QoolQit Device.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>profile :  CompilerProfile \u2014 The compiler profile to use.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_sequence</p> </li> </ul> <p> source property SequenceCompiler.register: Register </p> <p> source property SequenceCompiler.drive: Drive </p> <p> source property SequenceCompiler.device: Device </p> <p> source property SequenceCompiler.profile: CompilerProfile </p> <p>The compiler profile to use.</p> <p> source method SequenceCompiler.compile_sequence() \u2192 PulserSequence </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> <li> <p>CompilationError</p> </li> </ul>"},{"location":"api/qoolqit/execution/utils/","title":"qoolqit.execution.utils","text":"qoolqit.execution.utils<p> source module qoolqit.execution.utils </p> <p> Classes </p> <ul> <li> <p>CompilerProfile</p> </li> <li> <p>BackendName</p> </li> <li> <p>ResultType</p> </li> </ul> <p> source enum CompilerProfile() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>DEFAULT</p> </li> <li> <p>MAX_AMPLITUDE</p> </li> <li> <p>MAX_DURATION</p> </li> <li> <p>MIN_DISTANCE</p> </li> </ul> <p> source enum BackendName() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>QUTIP</p> </li> <li> <p>EMUMPS</p> </li> </ul> <p> source enum ResultType() </p> <p>Bases : StrEnum</p> <p> Attributes </p> <ul> <li> <p>BITSTRINGS</p> </li> <li> <p>STATEVECTOR</p> </li> </ul>"},{"location":"api/qoolqit/graphs/","title":"qoolqit.graphs","text":"qoolqit.graphs<p> source package qoolqit.graphs </p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> <li> <p>BaseGraph \u2014 The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> </li> </ul> <p> Functions </p> <ul> <li> <p>all_node_pairs \u2014 Return all pairs of nodes (u, v) where u &lt; v.</p> </li> <li> <p>distances \u2014 Return a dictionary of edge distances.</p> </li> <li> <p>random_coords \u2014 Generate a random set of node coordinates on a square of side L.</p> </li> <li> <p>random_edge_list \u2014 Generates a random set of k edges linkings items from a set of nodes.</p> </li> <li> <p>scale_coords \u2014 Scale the coordinates by a given value.</p> </li> <li> <p>space_coords \u2014 Spaces the coordinates so the minimum distance is equal to a set spacing.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>from_pyg \u2014 Create a graph from a pyg data object.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float, seed: int | None = None) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod DataGraph.from_pyg(data) \u2192 DataGraph </p> <p>Create a graph from a pyg data object.</p> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> source class BaseGraph(edges: Iterable = []) </p> <p>Bases : nx.Graph</p> <p>The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> <p>Defines basic functionalities for graphs within the Rydberg Analog, such as instantiating from a set of node coordinates, directly accessing node distances, and checking if the graph is unit-disk.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_nodes \u2014 Construct a base graph from a set of nodes.</p> </li> <li> <p>from_coordinates \u2014 Construct a base graph from a set of coordinates.</p> </li> <li> <p>distances \u2014 Returns a dictionary of distances for a given set of edges.</p> </li> <li> <p>interactions \u2014 Rydberg model interaction 1/r^6 between pair of nodes.</p> </li> <li> <p>min_distance \u2014 Returns the minimum distance in the graph.</p> </li> <li> <p>max_distance \u2014 Returns the maximum distance in the graph.</p> </li> <li> <p>ud_radius_range \u2014 Return the range (R_min, R_max) where the graph is unit-disk.</p> </li> <li> <p>is_ud_graph \u2014 Check if the graph is unit-disk.</p> </li> <li> <p>ud_edges \u2014 Returns the set of edges given by the intersection of circles of a given radius.</p> </li> <li> <p>rescale_coords \u2014 Rescales the node coordinates by a factor.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> <li> <p>draw \u2014 Draw the graph.</p> </li> </ul> <p> source classmethod BaseGraph.from_nodes(nodes: Iterable) \u2192 BaseGraph </p> <p>Construct a base graph from a set of nodes.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of nodes.</p> </li> </ul> <p> source classmethod BaseGraph.from_coordinates(coords: list | dict) \u2192 BaseGraph </p> <p>Construct a base graph from a set of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list | dict \u2014 list or dictionary of coordinate pairs.</p> </li> </ul> <p> source property BaseGraph.sorted_edges: set </p> <p>Returns the set of edges (u, v) such that (u &lt; v).</p> <p> source property BaseGraph.all_node_pairs: set </p> <p>Return a list of all possible node pairs in the graph.</p> <p> source property BaseGraph.has_coords: bool </p> <p>Check if the graph has coordinates.</p> <p>Requires all nodes to have coordinates.</p> <p> source property BaseGraph.has_edges: bool </p> <p>Check if the graph has edges.</p> <p> source property BaseGraph.coords: dict </p> <p>Return the dictionary of node coordinates.</p> <p> source method BaseGraph.distances(edge_list: Iterable | None = None) \u2192 dict </p> <p>Returns a dictionary of distances for a given set of edges.</p> <p>Distances are calculated directly from the coordinates. Raises an error if there are no coordinates on the graph.</p> <p> Parameters </p> <ul> <li> <p>edge_list :  Iterable | None \u2014 set of edges.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.interactions() \u2192 dict </p> <p>Rydberg model interaction 1/r^6 between pair of nodes.</p> <p> source method BaseGraph.min_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the minimum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.max_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the maximum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.ud_radius_range() \u2192 tuple </p> <p>Return the range (R_min, R_max) where the graph is unit-disk.</p> <p>The graph is unit-disk if the maximum distance between all connected nodes is smaller than the minimum distance between disconnected nodes. This means that for any value R in that interval, the following condition is true:</p> <p>graph.ud_edges(radius = R) == graph.sorted edges</p> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.is_ud_graph() \u2192 bool </p> <p>Check if the graph is unit-disk.</p> <p> source method BaseGraph.ud_edges(radius: float) \u2192 set </p> <p>Returns the set of edges given by the intersection of circles of a given radius.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the value</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> </ul> <p> source method BaseGraph.rescale_coords(*args: Any, scaling: float | None = None, spacing: float | None = None) \u2192 None </p> <p>Rescales the node coordinates by a factor.</p> <p>Accepts either a scaling or a spacing factor.</p> <p> Parameters </p> <ul> <li> <p>scaling :  float | None \u2014 value to scale by.</p> </li> <li> <p>spacing :  float | None \u2014 value to set as the minimum distance in the graph.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>TypeError</p> </li> </ul> <p> source method BaseGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the radius to use in determining the set of unit-disk edges.</p> </li> </ul> <p> source method BaseGraph.draw(return_fig: bool = False, *args: Any, **kwargs: Any) \u2192 plt.Figure | None </p> <p>Draw the graph.</p> <p>Uses the draw_networkx function from NetworkX.</p> <p> Parameters </p> <ul> <li> <p>*args :  Any \u2014 arguments to pass to draw_networkx.</p> </li> <li> <p>**kwargs :  Any \u2014 keyword-arguments to pass to draw_networkx.</p> </li> </ul> <p> source all_node_pairs(nodes: Iterable) \u2192 set </p> <p>Return all pairs of nodes (u, v) where u &lt; v.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of node indices.</p> </li> </ul> <p> source distances(coords: dict, edge_list: Iterable) \u2192 dict </p> <p>Return a dictionary of edge distances.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>edge_list :  Iterable \u2014 edge list to compute the distances for.</p> </li> </ul> <p> source random_coords(n: int, L: float = 1.0) \u2192 list </p> <p>Generate a random set of node coordinates on a square of side L.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of coordinate pairs to generate.</p> </li> <li> <p>L :  float \u2014 side of the square.</p> </li> </ul> <p> source random_edge_list(nodes: Iterable, k: int) \u2192 list </p> <p>Generates a random set of k edges linkings items from a set of nodes.</p> <p> source scale_coords(coords: dict, scaling: float) \u2192 dict </p> <p>Scale the coordinates by a given value.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>scaling :  float \u2014 value to scale by.</p> </li> </ul> <p> source space_coords(coords: dict, spacing: float) \u2192 dict </p> <p>Spaces the coordinates so the minimum distance is equal to a set spacing.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>spacing :  float \u2014 value to set as minimum distance.</p> </li> </ul>"},{"location":"api/qoolqit/graphs/base_graph/","title":"qoolqit.graphs.base_graph","text":"qoolqit.graphs.base_graph<p> source module qoolqit.graphs.base_graph </p> <p> Classes </p> <ul> <li> <p>BaseGraph \u2014 The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> </li> </ul> <p> source class BaseGraph(edges: Iterable = []) </p> <p>Bases : nx.Graph</p> <p>The BaseGraph in QoolQit, direclty inheriting from the NetworkX Graph.</p> <p>Defines basic functionalities for graphs within the Rydberg Analog, such as instantiating from a set of node coordinates, directly accessing node distances, and checking if the graph is unit-disk.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_nodes \u2014 Construct a base graph from a set of nodes.</p> </li> <li> <p>from_coordinates \u2014 Construct a base graph from a set of coordinates.</p> </li> <li> <p>distances \u2014 Returns a dictionary of distances for a given set of edges.</p> </li> <li> <p>interactions \u2014 Rydberg model interaction 1/r^6 between pair of nodes.</p> </li> <li> <p>min_distance \u2014 Returns the minimum distance in the graph.</p> </li> <li> <p>max_distance \u2014 Returns the maximum distance in the graph.</p> </li> <li> <p>ud_radius_range \u2014 Return the range (R_min, R_max) where the graph is unit-disk.</p> </li> <li> <p>is_ud_graph \u2014 Check if the graph is unit-disk.</p> </li> <li> <p>ud_edges \u2014 Returns the set of edges given by the intersection of circles of a given radius.</p> </li> <li> <p>rescale_coords \u2014 Rescales the node coordinates by a factor.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> <li> <p>draw \u2014 Draw the graph.</p> </li> </ul> <p> source classmethod BaseGraph.from_nodes(nodes: Iterable) \u2192 BaseGraph </p> <p>Construct a base graph from a set of nodes.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of nodes.</p> </li> </ul> <p> source classmethod BaseGraph.from_coordinates(coords: list | dict) \u2192 BaseGraph </p> <p>Construct a base graph from a set of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list | dict \u2014 list or dictionary of coordinate pairs.</p> </li> </ul> <p> source property BaseGraph.sorted_edges: set </p> <p>Returns the set of edges (u, v) such that (u &lt; v).</p> <p> source property BaseGraph.all_node_pairs: set </p> <p>Return a list of all possible node pairs in the graph.</p> <p> source property BaseGraph.has_coords: bool </p> <p>Check if the graph has coordinates.</p> <p>Requires all nodes to have coordinates.</p> <p> source property BaseGraph.has_edges: bool </p> <p>Check if the graph has edges.</p> <p> source property BaseGraph.coords: dict </p> <p>Return the dictionary of node coordinates.</p> <p> source method BaseGraph.distances(edge_list: Iterable | None = None) \u2192 dict </p> <p>Returns a dictionary of distances for a given set of edges.</p> <p>Distances are calculated directly from the coordinates. Raises an error if there are no coordinates on the graph.</p> <p> Parameters </p> <ul> <li> <p>edge_list :  Iterable | None \u2014 set of edges.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.interactions() \u2192 dict </p> <p>Rydberg model interaction 1/r^6 between pair of nodes.</p> <p> source method BaseGraph.min_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the minimum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.max_distance(connected: bool | None = None) \u2192 float </p> <p>Returns the maximum distance in the graph.</p> <p> Parameters </p> <ul> <li> <p>connected :  bool | None \u2014 if True/False, computes only over connected/disconnected nodes.</p> </li> </ul> <p> source method BaseGraph.ud_radius_range() \u2192 tuple </p> <p>Return the range (R_min, R_max) where the graph is unit-disk.</p> <p>The graph is unit-disk if the maximum distance between all connected nodes is smaller than the minimum distance between disconnected nodes. This means that for any value R in that interval, the following condition is true:</p> <p>graph.ud_edges(radius = R) == graph.sorted edges</p> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>ValueError</p> </li> </ul> <p> source method BaseGraph.is_ud_graph() \u2192 bool </p> <p>Check if the graph is unit-disk.</p> <p> source method BaseGraph.ud_edges(radius: float) \u2192 set </p> <p>Returns the set of edges given by the intersection of circles of a given radius.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the value</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> </ul> <p> source method BaseGraph.rescale_coords(*args: Any, scaling: float | None = None, spacing: float | None = None) \u2192 None </p> <p>Rescales the node coordinates by a factor.</p> <p>Accepts either a scaling or a spacing factor.</p> <p> Parameters </p> <ul> <li> <p>scaling :  float | None \u2014 value to scale by.</p> </li> <li> <p>spacing :  float | None \u2014 value to set as the minimum distance in the graph.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>AttributeError</p> </li> <li> <p>TypeError</p> </li> </ul> <p> source method BaseGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p> <p> Parameters </p> <ul> <li> <p>radius :  float \u2014 the radius to use in determining the set of unit-disk edges.</p> </li> </ul> <p> source method BaseGraph.draw(return_fig: bool = False, *args: Any, **kwargs: Any) \u2192 plt.Figure | None </p> <p>Draw the graph.</p> <p>Uses the draw_networkx function from NetworkX.</p> <p> Parameters </p> <ul> <li> <p>*args :  Any \u2014 arguments to pass to draw_networkx.</p> </li> <li> <p>**kwargs :  Any \u2014 keyword-arguments to pass to draw_networkx.</p> </li> </ul>"},{"location":"api/qoolqit/graphs/data_graph/","title":"qoolqit.graphs.data_graph","text":"qoolqit.graphs.data_graph<p> source module qoolqit.graphs.data_graph </p> <p> Classes </p> <ul> <li> <p>DataGraph \u2014 The main graph structure to represent problem data.</p> </li> </ul> <p> source class DataGraph(edges: Iterable = []) </p> <p>Bases : BaseGraph</p> <p>The main graph structure to represent problem data.</p> <p>Default constructor for the BaseGraph.</p> <p> Parameters </p> <ul> <li> <p>edges :  Iterable \u2014 set of edge tuples (i, j)</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>adj \u2014 Graph adjacency object holding the neighbors of each node.</p> </li> <li> <p>name \u2014 String identifier of the graph.</p> </li> <li> <p>nodes \u2014 A NodeView of the Graph as G.nodes or G.nodes().</p> </li> <li> <p>edges \u2014 An EdgeView of the Graph as G.edges or G.edges().</p> </li> <li> <p>degree \u2014 A DegreeView for the Graph as G.degree or G.degree().</p> </li> <li> <p>sorted_edges :  set \u2014 Returns the set of edges (u, v) such that (u &lt; v).</p> </li> <li> <p>all_node_pairs :  set \u2014 Return a list of all possible node pairs in the graph.</p> </li> <li> <p>has_coords :  bool \u2014 Check if the graph has coordinates.</p> </li> <li> <p>has_edges :  bool \u2014 Check if the graph has edges.</p> </li> <li> <p>coords :  dict \u2014 Return the dictionary of node coordinates.</p> </li> <li> <p>node_weights :  dict \u2014 Return the dictionary of node weights.</p> </li> <li> <p>edge_weights :  dict \u2014 Return the dictionary of edge weights.</p> </li> <li> <p>has_node_weights :  bool \u2014 Check if the graph has node weights.</p> </li> <li> <p>has_edge_weights :  bool \u2014 Check if the graph has edge weights.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>line \u2014 Constructs a line graph, with the respective coordinates.</p> </li> <li> <p>circle \u2014 Constructs a circle graph, with the respective coordinates.</p> </li> <li> <p>random_er \u2014 Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> </li> <li> <p>random_ud \u2014 Constructs a random unit-disk graph.</p> </li> <li> <p>from_matrix \u2014 Constructs a graph from a symmetric square matrix.</p> </li> <li> <p>from_pyg \u2014 Create a graph from a pyg data object.</p> </li> <li> <p>set_ud_edges \u2014 Reset the set of edges to be equal to the set of unit-disk edges.</p> </li> </ul> <p> source classmethod DataGraph.line(n: int, spacing: float = 1.0) \u2192 DataGraph </p> <p>Constructs a line graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> </ul> <p> source classmethod DataGraph.circle(n: int, spacing: float = 1.0, center: tuple = (0.0, 0.0)) \u2192 DataGraph </p> <p>Constructs a circle graph, with the respective coordinates.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>spacing :  float \u2014 distance between each node.</p> </li> <li> <p>center :  tuple \u2014 point (x, y) to set as the center of the graph.</p> </li> </ul> <p> source classmethod DataGraph.random_er(n: int, p: float, seed: int | None = None) \u2192 DataGraph </p> <p>Constructs an Erd\u0151s\u2013R\u00e9nyi random graph.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>p :  float \u2014 probability that any two nodes connect.</p> </li> <li> <p>seed :  int | None \u2014 random seed.</p> </li> </ul> <p> source classmethod DataGraph.random_ud(n: int, radius: float = 1.0, L: float | None = None) \u2192 DataGraph </p> <p>Constructs a random unit-disk graph.</p> <p>The nodes are sampled uniformly from a square of size (L x L). If L is not given, it is estimated based on a rough heuristic that of packing N nodes on a square of side L such that the expected minimum distance is R, leading to L ~ (R / 2) * sqrt(\u03c0 * n).</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of nodes.</p> </li> <li> <p>radius :  float \u2014 radius to use for defining the unit-disk edges.</p> </li> <li> <p>L :  float | None \u2014 size of the square on which to sample the node coordinates.</p> </li> </ul> <p> source classmethod DataGraph.from_matrix(data: ArrayLike) \u2192 DataGraph </p> <p>Constructs a graph from a symmetric square matrix.</p> <p>The diagonal values are set as the node weights. For each entry (i, j) where M[i, j] != 0 an edge (i, j) is added to the graph and the value M[i, j] is set as its weight.</p> <p> Parameters </p> <ul> <li> <p>data :  ArrayLike \u2014 symmetric square matrix.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod DataGraph.from_pyg(data) \u2192 DataGraph </p> <p>Create a graph from a pyg data object.</p> <p> Raises </p> <ul> <li> <p>NotImplementedError</p> </li> </ul> <p> source property DataGraph.node_weights: dict </p> <p>Return the dictionary of node weights.</p> <p> source property DataGraph.edge_weights: dict </p> <p>Return the dictionary of edge weights.</p> <p> source property DataGraph.has_node_weights: bool </p> <p>Check if the graph has node weights.</p> <p>Requires all nodes to have a weight.</p> <p> source property DataGraph.has_edge_weights: bool </p> <p>Check if the graph has edge weights.</p> <p>Requires all edges to have a weight.</p> <p> source method DataGraph.set_ud_edges(radius: float) \u2192 None </p> <p>Reset the set of edges to be equal to the set of unit-disk edges.</p>"},{"location":"api/qoolqit/graphs/utils/","title":"qoolqit.graphs.utils","text":"qoolqit.graphs.utils<p> source module qoolqit.graphs.utils </p> <p> Functions </p> <ul> <li> <p>all_node_pairs \u2014 Return all pairs of nodes (u, v) where u &lt; v.</p> </li> <li> <p>distances \u2014 Return a dictionary of edge distances.</p> </li> <li> <p>scale_coords \u2014 Scale the coordinates by a given value.</p> </li> <li> <p>space_coords \u2014 Spaces the coordinates so the minimum distance is equal to a set spacing.</p> </li> <li> <p>random_coords \u2014 Generate a random set of node coordinates on a square of side L.</p> </li> <li> <p>random_edge_list \u2014 Generates a random set of k edges linkings items from a set of nodes.</p> </li> <li> <p>less_or_equal \u2014 Less or approximately equal.</p> </li> </ul> <p> source all_node_pairs(nodes: Iterable) \u2192 set </p> <p>Return all pairs of nodes (u, v) where u &lt; v.</p> <p> Parameters </p> <ul> <li> <p>nodes :  Iterable \u2014 set of node indices.</p> </li> </ul> <p> source distances(coords: dict, edge_list: Iterable) \u2192 dict </p> <p>Return a dictionary of edge distances.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>edge_list :  Iterable \u2014 edge list to compute the distances for.</p> </li> </ul> <p> source scale_coords(coords: dict, scaling: float) \u2192 dict </p> <p>Scale the coordinates by a given value.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>scaling :  float \u2014 value to scale by.</p> </li> </ul> <p> source space_coords(coords: dict, spacing: float) \u2192 dict </p> <p>Spaces the coordinates so the minimum distance is equal to a set spacing.</p> <p> Parameters </p> <ul> <li> <p>coords :  dict \u2014 dictionary of node coordinates.</p> </li> <li> <p>spacing :  float \u2014 value to set as minimum distance.</p> </li> </ul> <p> source random_coords(n: int, L: float = 1.0) \u2192 list </p> <p>Generate a random set of node coordinates on a square of side L.</p> <p> Parameters </p> <ul> <li> <p>n :  int \u2014 number of coordinate pairs to generate.</p> </li> <li> <p>L :  float \u2014 side of the square.</p> </li> </ul> <p> source random_edge_list(nodes: Iterable, k: int) \u2192 list </p> <p>Generates a random set of k edges linkings items from a set of nodes.</p> <p> source less_or_equal(a: float, b: float, rel_tol: float = 0.0, abs_tol: float = ATOL_32) \u2192 bool </p> <p>Less or approximately equal.</p>"},{"location":"api/qoolqit/waveforms/","title":"qoolqit.waveforms","text":"qoolqit.waveforms<p> source package qoolqit.waveforms </p> <p> Classes </p> <ul> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> <li> <p>CompositeWaveform \u2014 Base class for composite waveforms.</p> </li> <li> <p>Waveform \u2014 Base class for waveforms.</p> </li> </ul> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Delay(duration: float, *args: float, **kwargs: float) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p> <p> source class CompositeWaveform(*waveforms: Waveform) </p> <p>Bases : Waveform</p> <p>Base class for composite waveforms.</p> <p>A CompositeWaveform stores a sequence of waveforms occuring one after the other by the order given. When it is evaluated at time t, the corresponding waveform from the sequence is identified depending on the duration of each one, and it is then evaluated for a time t' = t minus the duration of all previous waveforms.</p> <p>Initializes the CompositeWaveform.</p> <p> Parameters </p> <ul> <li> <p>waveforms :  Waveform \u2014 an iterator over waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Identifies the right waveform in the composition and evaluates it at time t.</p> </li> <li> <p>max \u2014 Get the maximum value of the waveform.</p> </li> </ul> <p> source property CompositeWaveform.durations: list[float] </p> <p>Returns the list of durations of each individual waveform.</p> <p> source property CompositeWaveform.times: list[float] </p> <p>Returns the list of times when each individual waveform starts.</p> <p> source property CompositeWaveform.waveforms: list[Waveform] </p> <p>Returns a list of the individual waveforms.</p> <p> source property CompositeWaveform.n_waveforms: int </p> <p>Returns the number of waveforms.</p> <p> source method CompositeWaveform.function(t: float) \u2192 float </p> <p>Identifies the right waveform in the composition and evaluates it at time t.</p> <p> source method CompositeWaveform.max() \u2192 float </p> <p>Get the maximum value of the waveform.</p> <p> source class Waveform(duration: float, *args: float, **kwargs: float) </p> <p>Bases : ABC</p> <p>Base class for waveforms.</p> <p>A Waveform is a function of time for t &gt;= 0. Custom waveforms can be defined by inheriting from the base class and overriding the <code>function</code> method corresponding to the function f(t) that returns the value of the waveform evaluated at time t.</p> <p>A waveform is always a 1D function, so if it includes other parameters, these should be passed and saved at initialization for usage within the <code>function</code> method.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Evaluates the waveform function at a given time t.</p> </li> <li> <p>max \u2014 Get the approximate maximum value of the waveform.</p> </li> <li> <p>min \u2014 Get the approximate minimum value of the waveform.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property Waveform.duration: float </p> <p>Returns the duration of the waveform.</p> <p> source property Waveform.params: dict[str, float] </p> <p>Dictonary of parameters used by the waveform.</p> <p> source method Waveform.function(t: float) \u2192 float </p> <p>Evaluates the waveform function at a given time t.</p> <p> source method Waveform.max() \u2192 float </p> <p>Get the approximate maximum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the maximum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.min() \u2192 float </p> <p>Get the approximate minimum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the minimum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.draw(n_points: int = N_POINTS, return_fig: bool = False, **kwargs: Any) \u2192 plt.Figure | None </p>"},{"location":"api/qoolqit/waveforms/base_waveforms/","title":"qoolqit.waveforms.base_waveforms","text":"qoolqit.waveforms.base_waveforms<p> source module qoolqit.waveforms.base_waveforms </p> <p> Classes </p> <ul> <li> <p>Waveform \u2014 Base class for waveforms.</p> </li> <li> <p>CompositeWaveform \u2014 Base class for composite waveforms.</p> </li> </ul> <p> source class Waveform(duration: float, *args: float, **kwargs: float) </p> <p>Bases : ABC</p> <p>Base class for waveforms.</p> <p>A Waveform is a function of time for t &gt;= 0. Custom waveforms can be defined by inheriting from the base class and overriding the <code>function</code> method corresponding to the function f(t) that returns the value of the waveform evaluated at time t.</p> <p>A waveform is always a 1D function, so if it includes other parameters, these should be passed and saved at initialization for usage within the <code>function</code> method.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Evaluates the waveform function at a given time t.</p> </li> <li> <p>max \u2014 Get the approximate maximum value of the waveform.</p> </li> <li> <p>min \u2014 Get the approximate minimum value of the waveform.</p> </li> <li> <p>draw</p> </li> </ul> <p> source property Waveform.duration: float </p> <p>Returns the duration of the waveform.</p> <p> source property Waveform.params: dict[str, float] </p> <p>Dictonary of parameters used by the waveform.</p> <p> source method Waveform.function(t: float) \u2192 float </p> <p>Evaluates the waveform function at a given time t.</p> <p> source method Waveform.max() \u2192 float </p> <p>Get the approximate maximum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the maximum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.min() \u2192 float </p> <p>Get the approximate minimum value of the waveform.</p> <p>This is a brute-force method that samples the waveform over a pre-defined number of points to find the minimum value in the duration. Custom waveforms that have an easy to compute maximum value should override this method.</p> <p> source method Waveform.draw(n_points: int = N_POINTS, return_fig: bool = False, **kwargs: Any) \u2192 plt.Figure | None </p> <p> source class CompositeWaveform(*waveforms: Waveform) </p> <p>Bases : Waveform</p> <p>Base class for composite waveforms.</p> <p>A CompositeWaveform stores a sequence of waveforms occuring one after the other by the order given. When it is evaluated at time t, the corresponding waveform from the sequence is identified depending on the duration of each one, and it is then evaluated for a time t' = t minus the duration of all previous waveforms.</p> <p>Initializes the CompositeWaveform.</p> <p> Parameters </p> <ul> <li> <p>waveforms :  Waveform \u2014 an iterator over waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function \u2014 Identifies the right waveform in the composition and evaluates it at time t.</p> </li> <li> <p>max \u2014 Get the maximum value of the waveform.</p> </li> </ul> <p> source property CompositeWaveform.durations: list[float] </p> <p>Returns the list of durations of each individual waveform.</p> <p> source property CompositeWaveform.times: list[float] </p> <p>Returns the list of times when each individual waveform starts.</p> <p> source property CompositeWaveform.waveforms: list[Waveform] </p> <p>Returns a list of the individual waveforms.</p> <p> source property CompositeWaveform.n_waveforms: int </p> <p>Returns the number of waveforms.</p> <p> source method CompositeWaveform.function(t: float) \u2192 float </p> <p>Identifies the right waveform in the composition and evaluates it at time t.</p> <p> source method CompositeWaveform.max() \u2192 float </p> <p>Get the maximum value of the waveform.</p>"},{"location":"api/qoolqit/waveforms/waveforms/","title":"qoolqit.waveforms.waveforms","text":"qoolqit.waveforms.waveforms<p> source module qoolqit.waveforms.waveforms </p> <p> Classes </p> <ul> <li> <p>Delay \u2014 An empty waveform.</p> </li> <li> <p>Ramp \u2014 A ramp that linearly interpolates between an initial and final value.</p> </li> <li> <p>Constant \u2014 A constant waveform over a given duration.</p> </li> <li> <p>PiecewiseLinear \u2014 A piecewise linear waveform.</p> </li> <li> <p>Sin \u2014 An arbitrary sine over a given duration.</p> </li> </ul> <p> source class Delay(duration: float, *args: float, **kwargs: float) </p> <p>Bases : Waveform</p> <p>An empty waveform.</p> <p>Initializes the Waveform.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration of the waveform.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Delay.function(t: float) \u2192 float </p> <p> source method Delay.max() \u2192 float </p> <p> source method Delay.min() \u2192 float </p> <p> source class Ramp(duration: float, initial_value: float, final_value: float) </p> <p>Bases : Waveform</p> <p>A ramp that linearly interpolates between an initial and final value.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>initial_value :  float \u2014 the initial value at t = 0.</p> </li> <li> <p>final_value :  float \u2014 the final value at t = duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Ramp.function(t: float) \u2192 float </p> <p> source method Ramp.max() \u2192 float </p> <p> source method Ramp.min() \u2192 float </p> <p> source class Constant(duration: float, value: float) </p> <p>Bases : Waveform</p> <p>A constant waveform over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>value :  float \u2014 the value to take during the duration.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> <li> <p>max</p> </li> <li> <p>min</p> </li> </ul> <p> source method Constant.function(t: float) \u2192 float </p> <p> source method Constant.max() \u2192 float </p> <p> source method Constant.min() \u2192 float </p> <p> source class PiecewiseLinear(durations: list | tuple, values: list | tuple) </p> <p>Bases : CompositeWaveform</p> <p>A piecewise linear waveform.</p> <p>Creates a composite waveform of N ramps that linearly interpolate through the given N+1 values.</p> <p> Parameters </p> <ul> <li> <p>durations :  list | tuple \u2014 list or tuple of N duration values.</p> </li> <li> <p>values :  list | tuple \u2014 list or tuple of N+1 waveform values.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> <li> <p>durations :  list[float] \u2014 Returns the list of durations of each individual waveform.</p> </li> <li> <p>times :  list[float] \u2014 Returns the list of times when each individual waveform starts.</p> </li> <li> <p>waveforms :  list[Waveform] \u2014 Returns a list of the individual waveforms.</p> </li> <li> <p>n_waveforms :  int \u2014 Returns the number of waveforms.</p> </li> </ul> <p> source class Sin(duration: float, amplitude: float = 1.0, omega: float = 1.0, phi: float = 0.0, shift: float = 0.0) </p> <p>Bases : Waveform</p> <p>An arbitrary sine over a given duration.</p> <p> Parameters </p> <ul> <li> <p>duration :  float \u2014 the total duration.</p> </li> <li> <p>amplitude :  float \u2014 the amplitude of the sine wave.</p> </li> <li> <p>omega :  float \u2014 the frequency of the sine wave.</p> </li> <li> <p>phi :  float \u2014 the phase of the sine wave.</p> </li> <li> <p>shift :  float \u2014 the vertical shift of the sine wave.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>duration :  float \u2014 Returns the duration of the waveform.</p> </li> <li> <p>params :  dict[str, float] \u2014 Dictonary of parameters used by the waveform.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>function</p> </li> </ul> <p> source method Sin.function(t: float) \u2192 float </p>"},{"location":"api/qoolqit/drive/","title":"qoolqit.drive","text":"qoolqit.drive<p> source module qoolqit.drive </p> <p> Classes </p> <ul> <li> <p>Drive \u2014 The drive Hamiltonian acting over a duration.</p> </li> </ul> <p> source class Drive(*args: Any, amplitude: Waveform | None = None, detuning: Waveform | None = None, phase: float = 0.0) </p> <p>The drive Hamiltonian acting over a duration.</p> <p>Default constructor for the Drive.</p> <p>Must be instantiated with keyword arguments. Accepts either an amplitude waveform, a detuning waveform, or both. A phase value can also be passed.</p> <p> Parameters </p> <ul> <li> <p>amplitude :  Waveform | None \u2014 waveform representing \u03a9(t) in the drive Hamiltonian.</p> </li> <li> <p>detuning :  Waveform | None \u2014 waveform representing \u03b4(t) in the drive Hamiltonian.</p> </li> <li> <p>phase :  float \u2014 phase value \u0278 for the amplitude term.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>amplitude :  Waveform \u2014 The amplitude waveform in the drive.</p> </li> <li> <p>detuning :  Waveform \u2014 The detuning waveform in the drive.</p> </li> <li> <p>phase :  float \u2014 The phase value in the drive.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>draw</p> </li> </ul> <p> source property Drive.amplitude: Waveform </p> <p>The amplitude waveform in the drive.</p> <p> source property Drive.detuning: Waveform </p> <p>The detuning waveform in the drive.</p> <p> source property Drive.phase: float </p> <p>The phase value in the drive.</p> <p> source property Drive.duration: float </p> <p> source method Drive.draw(n_points: int = 500, return_fig: bool = False) \u2192 plt.Figure | None </p>"},{"location":"api/qoolqit/exceptions/","title":"qoolqit.exceptions","text":"qoolqit.exceptions<p> source module qoolqit.exceptions </p> <p> Classes </p> <ul> <li> <p>CompilationError \u2014 An error raised when attempting to compile a program into a Pulser Sequence.</p> </li> </ul> <p> source class CompilationError() </p> <p>Bases : Exception</p> <p>An error raised when attempting to compile a program into a Pulser Sequence.</p>"},{"location":"api/qoolqit/program/","title":"qoolqit.program","text":"qoolqit.program<p> source module qoolqit.program </p> <p> Classes </p> <ul> <li> <p>QuantumProgram \u2014 A program representing a Sequence acting on a Register of qubits.</p> </li> </ul> <p> source class QuantumProgram(register: Register, drive: Drive) </p> <p>A program representing a Sequence acting on a Register of qubits.</p> <p> Parameters </p> <ul> <li> <p>register :  Register \u2014 the Register of qubits.</p> </li> <li> <p>sequence \u2014 the Sequence of waveforms.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>register :  Register \u2014 The register of qubits.</p> </li> <li> <p>drive :  Drive \u2014 The driving waveforms.</p> </li> <li> <p>is_compiled :  bool \u2014 Check if the program has been compiled.</p> </li> <li> <p>compiled_sequence :  PulserSequence \u2014 The Pulser sequence compiled to a specific device.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>compile_to \u2014 Compiles the given program to a device.</p> </li> <li> <p>draw</p> </li> <li> <p>run \u2014 Run the compiled sequence on selected backend.</p> </li> </ul> <p> source property QuantumProgram.register: Register </p> <p>The register of qubits.</p> <p> source property QuantumProgram.drive: Drive </p> <p>The driving waveforms.</p> <p> source property QuantumProgram.is_compiled: bool </p> <p>Check if the program has been compiled.</p> <p> source property QuantumProgram.compiled_sequence: PulserSequence </p> <p>The Pulser sequence compiled to a specific device.</p> <p> source method QuantumProgram.compile_to(device: Device, profile: CompilerProfile = CompilerProfile.DEFAULT) \u2192 None </p> <p>Compiles the given program to a device.</p> <p> Parameters </p> <ul> <li> <p>device :  Device \u2014 the Device to compile to.</p> </li> <li> <p>profile :  CompilerProfile \u2014 the compiler profile to use during compilation.</p> </li> </ul> <p> source method QuantumProgram.draw(n_points: int = 500, compiled: bool = False, return_fig: bool = False) \u2192 plt.Figure | None </p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source method QuantumProgram.run(backend_name: BackendName = BackendName.QUTIP, result_type: ResultType = ResultType.STATEVECTOR, runs: int = 100, evaluation_times: list[float] = [1.0], **backend_params: Any) \u2192 OutputType </p> <p>Run the compiled sequence on selected backend.</p> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul>"},{"location":"api/qoolqit/register/","title":"qoolqit.register","text":"qoolqit.register<p> source module qoolqit.register </p> <p> Classes </p> <ul> <li> <p>Register \u2014 The Register in QoolQit, representing a set of qubits with coordinates.</p> </li> </ul> <p> source class Register(qubits: dict) </p> <p>The Register in QoolQit, representing a set of qubits with coordinates.</p> <p>Default constructor for the Register.</p> <p> Parameters </p> <ul> <li> <p>qubits :  dict \u2014 a dictionary of qubits and respective coordinates {q: (x, y), ...}.</p> </li> </ul> <p> Attributes </p> <ul> <li> <p>qubits :  dict \u2014 Returns the dictionary of qubits and respective coordinates.</p> </li> <li> <p>n_qubits :  int \u2014 Number of qubits in the Register.</p> </li> </ul> <p> Methods </p> <ul> <li> <p>from_graph \u2014 Initializes a Register from a graph that has coordinates.</p> </li> <li> <p>from_coordinates \u2014 Initializes a Register from a list of coordinates.</p> </li> <li> <p>distances \u2014 Distance between each qubit pair.</p> </li> <li> <p>min_distance \u2014 Minimum distance between all qubit pairs.</p> </li> <li> <p>interactions \u2014 Interaction 1/r^6 between each qubit pair.</p> </li> <li> <p>draw \u2014 Draw the register.</p> </li> </ul> <p> source classmethod Register.from_graph(graph: DataGraph) \u2192 Register </p> <p>Initializes a Register from a graph that has coordinates.</p> <p> Parameters </p> <ul> <li> <p>graph :  DataGraph \u2014 a DataGraph instance.</p> </li> </ul> <p> Raises </p> <ul> <li> <p>ValueError</p> </li> </ul> <p> source classmethod Register.from_coordinates(coords: list) \u2192 Register </p> <p>Initializes a Register from a list of coordinates.</p> <p> Parameters </p> <ul> <li> <p>coords :  list \u2014 a list of coordinates [(x, y), ...]</p> </li> </ul> <p> Raises </p> <ul> <li> <p>TypeError</p> </li> </ul> <p> source property Register.qubits: dict </p> <p>Returns the dictionary of qubits and respective coordinates.</p> <p> source property Register.n_qubits: int </p> <p>Number of qubits in the Register.</p> <p> source method Register.distances() \u2192 dict </p> <p>Distance between each qubit pair.</p> <p> source method Register.min_distance() \u2192 float </p> <p>Minimum distance between all qubit pairs.</p> <p> source method Register.interactions() \u2192 dict </p> <p>Interaction 1/r^6 between each qubit pair.</p> <p> source method Register.draw(return_fig: bool = False) \u2192 plt.Figure | None </p> <p>Draw the register.</p> <p> Parameters </p> <ul> <li> <p>return_fig :  bool \u2014 boolean argument to return the plt.Figure instance.</p> </li> </ul>"},{"location":"api/qoolqit/utils/","title":"qoolqit.utils","text":"qoolqit.utils<p> source module qoolqit.utils </p> <p> Classes </p> <ul> <li> <p>CustomEnumMeta</p> </li> <li> <p>StrEnum</p> </li> </ul> <p> Functions </p> <ul> <li> <p>EQUAL</p> </li> </ul> <p> source EQUAL(a: float, b: float, rtol: float = 0.0, atol: float = ATOL_32) \u2192 bool </p> <p> source class CustomEnumMeta() </p> <p>Bases : EnumMeta</p> <p> source enum StrEnum() </p> <p>Bases : str, Enum</p> <p> Methods </p> <ul> <li> <p>list</p> </li> </ul> <p> source classmethod StrEnum.list(values: bool = False) \u2192 list </p>"}]}